/// @ignore all

// This is a collection of scripts which are generated by Gamemaker when converting a project from 1.4 over to 2.3

/*
background_color = bg_color -> __background_set_colour( bg_color )
background_showcolor = true -> __background_set_showcolour( true )
view_wview[0] = ROOM.width -> __view_set( e__VW.WView, 0, ROOM.width )
view_hview[0] = ROOM.height -> __view_set( e__VW.HView, 0, ROOM.height )
view_visible[0] = true -> __view_set( e__VW.Visible, 0, true )
background_colour=$333333 -> __background_set_colour( $333333 )
view_xview[0] -> __view_get( e__VW.XView, 0 )
view_xview[0]=-view_wview[0] -> __view_set( e__VW.XView, 0, -view_wview[0] )
view_yview[0] -> __view_get( e__VW.YView, 0 )
view_wview[0] -> __view_get( e__VW.WView, 0 )
view_hview[0] -> __view_get( e__VW.HView, 0 )
view_visible[0]=true -> __view_set( e__VW.Visible, 0, true )
view_xview[0]=floor(lerp(__view_get( e__VW.XView, 0 ), myBird[?"x"]-__view_get( e__VW.WView, 0 )*0.2, 0.1)) -> __view_set( e__VW.XView, 0, floor(lerp(__view_get( e__VW.XView, 0 ), myBird[?"x"]-__view_get( e__VW.WView, 0 )*0.2, 0.1)) )
view_xview[0]=floor(lerp(__view_get( e__VW.XView, 0 ), -__view_get( e__VW.WView, 0 ), 0.1)) -> __view_set( e__VW.XView, 0, floor(lerp(__view_get( e__VW.XView, 0 ), -__view_get( e__VW.WView, 0 ), 0.1)) )
view_wview[0]=GAME.view_width -> __view_set( e__VW.WView, 0, GAME.view_width )
view_hview[0]=GAME.view_height -> __view_set( e__VW.HView, 0, GAME.view_height )
view_wport[0]=GAME.view_width -> __view_set( e__VW.WPort, 0, GAME.view_width )
view_hport[0]=GAME.view_height -> __view_set( e__VW.HPort, 0, GAME.view_height )
background_visible[0] = true -> __background_set( e__BG.Visible, 0, true )
background_visible[0] = false -> __background_set( e__BG.Visible, 0, false )
background_visible[1] = true -> __background_set( e__BG.Visible, 1, true )
background_visible[1] = false -> __background_set( e__BG.Visible, 1, false )
background_visible[2] = true -> __background_set( e__BG.Visible, 2, true )
background_visible[2] = false -> __background_set( e__BG.Visible, 2, false )
background_index[i] = background_create_from_surface(surf_bk,0,0,W,H,0,0) -> __background_set( e__BG.Index, i, background_create_from_surface(surf_bk,0,0,W,H,0,0) )
background_index[i] = background_create_colour(W,H,c2) -> __background_set( e__BG.Index, i, background_create_colour(W,H,c2) )
background_colour = c_dkgray -> __background_set_colour( c_dkgray )
background_showcolour = true -> __background_set_showcolour( true )
view_wview[0] = W -> __view_set( e__VW.WView, 0, W )
view_hview[0] = H -> __view_set( e__VW.HView, 0, H )
view_wport[0] = W -> __view_set( e__VW.WPort, 0, W )
view_hport[0] = H -> __view_set( e__VW.HPort, 0, H )
background_index[0] -> __background_get( e__BG.Index, 0 )
background_index[1] -> __background_get( e__BG.Index, 1 )
background_index[0] = background_create_from_surface(_surf, 0, 0, 16*_img_count, 16, false, false) -> __background_set( e__BG.Index, 0, background_create_from_surface(_surf, 0, 0, 16*_img_count, 16, false, false) )
background_index[1] = background_create_colour(32, 32, c_white) -> __background_set( e__BG.Index, 1, background_create_colour(32, 32, c_white) )
background_colour -> __background_get_colour( )
background_colour = make_colour_hsv(irandom(255) + 255 * _msec * 0.000005 , irandom(150)+80, irandom(63)+160) -> __background_set_colour( make_colour_hsv(irandom(255) + 255 * _msec * 0.000005 , irandom(150)+80, irandom(63)+160) )
view_wview[0]   = 360 -> __view_set( e__VW.WView, 0, 360 )
view_hview[0]   = 640 -> __view_set( e__VW.HView, 0, 640 )
view_wport[0]   = 360 -> __view_set( e__VW.WPort, 0, 360 )
view_hport[0]   = 640 -> __view_set( e__VW.HPort, 0, 640 )
background_colour = c_black -> __background_set_colour( c_black )
background_showcolour = false -> __background_set_showcolour( false )
background_color -> __background_get_colour( )
background_color = $FFFFBD -> __background_set_colour( $FFFFBD )

*/

//-------------------------------------------------------------------------------------------------------\\
//     __     It looks like youre looking for advice on initialization,
//    /  \  /   Would you like help with that?
//    |  |
//    @  @    Tinkerer_Red has removed all of the gml_pragma( "global", *);
//    |  |      from the functions to prevent issues importing.
//    || |/     If you would like to re-enable them just un comment them!
//    || ||   
//    |\_/|   He also commented out the MacroExpansion in
//    \___/     `__global_object_depths`
//
//-------------------------------------------------------------------------------------------------------//


#region Init Scripts
function __global_object_depths() {
	// Initialise the global array that allows the lookup of the depth of a given object
	// GM2.0 does not have a depth on objects so on import from 1.x a global array is created
	// NOTE: MacroExpansion is used to insert the array initialisation at import time
	//gml_pragma( "global", "__global_object_depths()");
	
	// insert the generated arrays here
	//${compatibilityObjectDepths}
	
	// create another array that has the correct entries
	var len = array_length_1d(global.__objectDepths);
	global.__objectID2Depth = [];
	for( var i=0; i<len; ++i ) {
		var objID = asset_get_index( global.__objectNames[i] );
		if (objID >= 0) {
			global.__objectID2Depth[ objID ] = global.__objectDepths[i];
		} // end if
	} // end for



}


function __init_action() {
	//gml_pragma( "global", "__init_action();");
	global.__part_syst=-1;
	global.__part_emit=[];
	global.__argument_relative=false;
	global.__part_type=[];

	for( var i=0; i<=15; ++i) 
	{
		global.__part_type[i] = -1;
		global.__part_emit[i] = -1;
	}



}


function __init_background() {
	enum e__BG
	{
		Visible,
		Foreground,
		Index,
		X,
		Y,
		Width,
		Height,
		HTiled,
		VTiled,
		XScale,
		YScale,
		HSpeed,
		VSpeed,
		Blend,
		Alpha,
	};




}


function __init_d3d() {
	//gml_pragma( "global", "__init_d3d();");
	// setup the depth variable to a sensible default
	global.__d3d=false;
	global.__d3dDepth=0;
	global.__d3dCamera=camera_create();
	global.__d3dPrimKind = -1;
	global.__d3dPrimTex = -1;
	global.__d3dPrimBuffer=vertex_create_buffer();
	vertex_format_begin(); 
		vertex_format_add_position_3d(); 
		vertex_format_add_normal(); 
		vertex_format_add_colour();
		vertex_format_add_textcoord(); 
	global.__d3dPrimVF=vertex_format_end();
	global.__d3dDeprecatedMessage = [ false ];

	enum e__YYM
	{
		PointB,
		LineB,
		TriB,
		PointUVB,
		LineUVB,
		TriUVB,
		PointVB,
		LineVB,
		TriVB,	
		Texture,
		Colour,
		NumVerts,
		PrimKind,
		NumPointCols,
		NumLineCols,
		NumTriCols,
		PointCols,
		LineCols,
		TriCols,
	
		// these are used when building model primitives
		V1X,
		V1Y,
		V1Z,
		V1NX,
		V1NY,
		V1NZ,
		V1C,
		V1U,
		V1V,
	
		V2X,
		V2Y,
		V2Z,
		V2NX,
		V2NY,
		V2NZ,
		V2C,
		V2U,
		V2V,
	};

	enum e__YYMKIND
	{
		PRIMITIVE_BEGIN,
		PRIMITIVE_END,
		VERTEX,
		VERTEX_COLOR,
		VERTEX_TEX,
		VERTEX_TEX_COLOR,
		VERTEX_N,
		VERTEX_N_COLOR,
		VERTEX_N_TEX,
		VERTEX_N_TEX_COLOR,
		SHAPE_BLOCK,
		SHAPE_CYLINDER,
		SHAPE_CONE,
		SHAPE_ELLIPSOID,
		SHAPE_WALL,
		SHAPE_FLOOR,
	};



}


function __init_global() {
	//gml_pragma( "global", "__init_global();");

	// set any global defaults
	layer_force_draw_depth(true,0);		// force all layers to draw at depth 0
	draw_set_colour( c_black );



}


function __init_joystick() {
	//gml_pragma( "global", "__init_joystick();");
	//#macro __JOYSTICK_2_GAMEPAD	(argument0 == 2) ? global.__jstick_pad2 : global.__jstick_pad1
	global.__jstick_pad1=4;
	global.__jstick_pad2=5;
	global.__jstick_povangle = [
									-1,		// 0 - centered
									0,		// 1 - up
									90,		// 2 - right
									45,		// 3 - up and right
									180,	// 4 - down
									-1,		// 5 - down and up (invalid)
									135,	// 6 - down and right
									-1,		// 7 - down, up and right (invalid)
									270,	// 8 - left
									315,	// 9 - left and up
									-1,		// 10 - left and right (invalid)
									-1,		// 11 - left, up and right (invalid)
									225,	// 12 - left and down
									-1,		// 13 - left, down and up (invalid)
									-1,		// 14 - left, down and right (invalid)
									-1,		// 16 - left, right, up and down (invalid)
								];


	// reference the function to ensure that it is brought in
	joystick_process_events(true);



}


function __init_view() {
	enum e__VW
	{
		XView,
		YView,
		WView,
		HView,
		Angle,
		HBorder,
		VBorder,
		HSpeed,
		VSpeed,
		Object,
		Visible,
		XPort,
		YPort,
		WPort,
		HPort,
		Camera,
		SurfaceID,
	};



}
#endregion

#region Background
/// @description  @description Adds an image from a file to the set of background resources.
/// @param fname The name (string) of the file to add.
/// @param removeback Indicates whether to make all pixels with the selected colour (left-bottom pixel) transparent.
/// @param smooth Indicates whether to smooth the edges if transparent.
/// @returns {number} resource name for the new background
function background_add(argument0, argument1, argument2) {

	return sprite_add(argument0, 0, argument1, argument2, 0, 0);



}


/// @description  @description Adds an image (with alpha) from a file to the set of background resources.
/// @param with alpha
/// @param fname The name (string) of the file to add.
/// @returns {number} resource name for the new background
function background_add_alpha(argument0, argument1) {
	var __dummy = argument1;
	return sprite_add(argument0, 0, false, false, 0, 0);



}


/// @description  @description Assigns one background to another background index.
/// @param index The index of the background to be copied to (ie: over-written).
/// @param background The background to be copied from.
/// @returns
function background_assign(argument0, argument1) {

	sprite_assign(argument0, argument1);



}


/// @description  @description Creates a new background of a given size and colour.
/// @param w The width of the background.
/// @param h The height of the background.
/// @param col The colour to clear the background to.
/// @returns {number} resource name for the new background
function background_create_color(argument0, argument1, argument2) {

	// First-pass implementation - may need to add engine support if this causes problems
	var __w = argument0;
	var __h = argument1;
	var __col = argument2;

	var __CompTempSurf = surface_create(__w, __h);
	if (surface_exists(__CompTempSurf))
	{
		surface_set_target(__CompTempSurf);
		draw_clear(__col);
		surface_reset_target();
	
		var __sprid = sprite_create_from_surface(__CompTempSurf, 0, 0, __w, __h, false, false, 0, 0);
		surface_free(__CompTempSurf);
		return __sprid;
	}
	else
	{
		return -1;
	}



}


/// @description  @description Creates a new background of a given size and colour.
/// @param w The width of the background.
/// @param h The height of the background.
/// @param col The colour to clear the background to.
/// @returns {number} resource name for the new background
function background_create_colour(argument0, argument1, argument2) {

	// First-pass implementation - may need to add engine support if this causes problems
	var __w = argument0;
	var __h = argument1;
	var __col = argument2;

	var __CompTempSurf = surface_create(__w, __h);
	if (surface_exists(__CompTempSurf))
	{
		surface_set_target(__CompTempSurf);
		draw_clear(__col);
		surface_reset_target();
	
		var __sprid = sprite_create_from_surface(__CompTempSurf, 0, 0, __w, __h, false, false, 0, 0);
		surface_free(__CompTempSurf);
		return __sprid;
	}
	else
	{
		return -1;
	}



}


/// @description  @description Creates a background by copying an area from a surface.
/// @param index The index of the surface to create from.
/// @param x The x position to copy from.
/// @param y The y position to copy from.
/// @param w The width of the area to be copied (from the x position).
/// @param h The height of the area to be copied (from the y position).
/// @param removeback Indicates whether to make all pixels with the same colour (left-bottom pixel) transparent.
/// @param smooth Indicates whether to smooth the edges.
/// @returns {number} resource name for the new background
function background_create_from_surface(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	return sprite_create_from_surface(argument0, argument1, argument2, argument3, argument4, argument5, argument6, 0, 0);



}


/// @description  @description Creates a new background with a coloured gradient.
/// @param w The width of the new background.
/// @param h The height of the new background.
/// @param colour1 The first colour of the gradient.
/// @param colour2 The second colour of the gradient.
/// @param kind  The type of gradient (0 - 5). 
/// @returns {number} resource name for the new background
function background_create_gradient(argument0, argument1, argument2, argument3, argument4) {

	// First-pass implementation - may need to add engine support if this causes problems
	var __w = argument0;
	var __h = argument1;
	var __col1 = argument2;
	var __col2 = argument3;
	var __kind = argument4;

	var __halfw = __w / 2;
	var __halfh = __h / 2;

	var __CompTempSurf = surface_create(__w, __h);
	if (surface_exists(__CompTempSurf))
	{
		surface_set_target(__CompTempSurf);
	
		switch(__kind)
		{
			case 0:
			{
				// Horizontal gradient
				draw_rectangle_colour(0, 0, __w, __h, __col1, __col2, __col2, __col1, false);
			} break;
		
			case 1:
			{
				// Vertical gradient
				draw_rectangle_colour(0, 0, __w, __h, __col2, __col2, __col1, __col1, false);
			} break;
		
			case 2:
			{
				// Rectangular gradient			
				// Cant just use four rectangles due to triangulation artifacts
				// Also cant use a triangle fan because they arent supported on all platforms			
				draw_primitive_begin(pr_trianglelist);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(0, __halfh, __col2, 1);
				draw_vertex_colour(0, 0, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(0, 0, __col2, 1);
				draw_vertex_colour(__halfw, 0, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__halfw, 0, __col2, 1);
				draw_vertex_colour(__w, 0, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__w, 0, __col2, 1);
				draw_vertex_colour(__w, __halfh, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__w, __halfh, __col2, 1);
				draw_vertex_colour(__w, __h, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__w, __h, __col2, 1);
				draw_vertex_colour(__halfw, __h, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(__halfw, __h, __col2, 1);
				draw_vertex_colour(0, __h, __col2, 1);
			
				draw_vertex_colour(__halfw, __halfh, __col1, 1);
				draw_vertex_colour(0, __h, __col2, 1);
				draw_vertex_colour(0, __halfh, __col2, 1);
			
				draw_primitive_end();
			} break;
		
			case 3:
			{
				// Elliptical gradient
				draw_clear(__col2);			
				draw_ellipse_colour(0, 0, __w, __h, __col1, __col2, false);
			} break;
		
			case 4:
			{
				// Symmetrical horizontal gradient
				draw_rectangle_colour(0, 0, __halfw, __h, __col2, __col1, __col1, __col2, false);
				draw_rectangle_colour(__halfw, 0, __w, __h, __col1, __col2, __col2, __col1, false);
			} break;
		
			case 5:
			{
				// Symmetrical vertical gradient
				draw_rectangle_colour(0, 0, __w, __halfh, __col2, __col2, __col1, __col1, false);
				draw_rectangle_colour(0, __halfh, __w, __h, __col1, __col1, __col2, __col2, false);
			} break;
		}
	
		surface_reset_target();
	
		var __sprid = sprite_create_from_surface(__CompTempSurf, 0, 0, __w, __h, false, false, 0, 0);
		surface_free(__CompTempSurf);
		return __sprid;
	}
	else
	{
		return -1;
	}



}


/// @description  @description Deletes the background from memory, freeing the memory used.
/// @param index The index of the background to be deleted.
/// @returns 
function background_delete(argument0) {

	sprite_delete(argument0);



}


/// @description  @description Creates a duplicate of the background with the given index.
/// @param index The index of the background to duplicate.
/// @returns {number} resource name for the new background
function background_duplicate(argument0) {

	return sprite_duplicate(argument0);



}


/// @description  @description Determines whether a background exists or not.
/// @param index The index of the background to check.
/// @returns {boolean} whether the background exists or not
function background_exists(argument0) {

	return sprite_exists(argument0);



}


/// @description  @description Finds the height of a background.
/// @param index The index of the background to find the height of.
/// @returns {number} the height of the background
function background_get_height(argument0) {

	return sprite_get_height(argument0);



}


/// @description  @description Gets the name of a background.
/// @param index The background image asset to get the name of.
/// @returns {string} the name of the background
function background_get_name(argument0) {

	return sprite_get_name(argument0);



}


/// @description  @description Gets whether a background is preloaded
/// @param index The background image asset.
/// @returns {boolean} the preload status
function background_get_preload() {

	return false;



}


/// @description  @description Gets whether a background is smooth
/// @param index The background image asset.
/// @returns {boolean} whether the background is smooth
function background_get_smooth() {

	return false;



}


/// @description  @description Returns the texture id for the given background.
/// @param back The index of the background to use.
/// @returns {pointer} a pointer to the background texture
function background_get_texture(argument0) {

	return sprite_get_texture(argument0, 0);



}


/// @description  @description Gets whether a background is transparent
/// @param index The background image asset.
/// @returns {boolean} whether the background is transparent
function background_get_transparent() {

	return false;



}


/// @description  @description Returns the texture coordinates of the background within the texture page as an array.
/// @param back The index of the background to use.
/// @returns {array} an array containing the uv coordinates of the background on the texture page
function background_get_uvs(argument0) {

	return sprite_get_uvs(argument0, 0);



}


/// @description  @description Finds the width of a background.
/// @param index The index of the background to find the width of.
/// @returns {number} the width of the background
function background_get_width(argument0) {

	return sprite_get_width(argument0);



}


/// @description  @description Gets the name of a background.
/// @param index The background image asset to get the name of.
/// @returns {string} the name of the background
function background_name(argument0) {

	return sprite_get_name(argument0);



}


/// @description  @description Prefetches the specified background
/// @param back The index of the background to prefetch.
/// @returns 
function background_prefetch(argument0) {

	sprite_prefetch(argument0);



}


/// @description  @description Prefetches the specified backgrounds
/// @param back_array An array of backgrounds to prefetch
/// @returns 
function background_prefetch_multi(argument0) {

	sprite_prefetch_multi(argument0);



}


/// @description  @description Replace a background resource with another one.
/// @param ind The index of the background to permanently replace.
/// @param fname The filename of the image to make the new background.
/// @param removeback Indicates whether to make all pixels with the same colour (left-bottom pixel) transparent.
/// @param smooth Indicates whether to smooth the edges.
/// @returns 
function background_replace(argument0, argument1, argument2, argument3) {

	sprite_replace(argument0, argument1, 1, argument2, argument3, 0, 0);



}


/// @description  @description Replace a background resource with another one.
/// @param ind The index of the background to permanently replace.
/// @param fname The filename of the image to make the new background.
/// @param preload Indicates whether to make all pixels with the same colour (left-bottom pixel) transparent.
/// @returns 
function background_replace_alpha(argument0, argument1) {

	sprite_replace(argument0, argument1, 1, false, false, 0, 0);



}


/// @description  @description Save a background to disc.
/// @param back The index of the background to save.
/// @param fname The filename for the saved background.
/// @returns 
function background_save(argument0, argument1) {

	sprite_save(argument0, 0, argument1);



}


/// @description  @description Changes the alpha (transparency) of one given background based on the intensity/value map of another.
/// @param transparency
/// @param ind The index of the background to change the transparency map of.
/// @param back The index of the background to take the transparency map data from.
/// @returns 
function background_set_alpha_from_background(argument0, argument1) {

	sprite_set_alpha_from_sprite(argument0, argument1);



}


function __background_get(argument0, argument1) {
	var __prop = argument0;
	var __bind = argument1;

	var __backinfo = __background_get_element(__bind);

	return __background_get_internal(__prop, __bind, __backinfo);



}


function __background_get_colour() {
	var __colinfo = __background_get_colour_element();

	if (__colinfo[0] == -1)
		return 0;
	
	var __col = layer_background_get_blend(__colinfo[0]);
	return __col;



}


function __background_get_colour_element() {
	// NOTE: this script will only work properly if youre using the standard depth range (-16000 to 16000)
	var __nearestdepth = -15000;
	var __farthestdepth = 15999;
	var __depthinc = 100;

	var __result;
	__result[0] = -1;
	__result[1] = -1;


	// Now look at the existing layers in the room to see if we have any foregrounds or backgrounds
	var __colstring = "Compatibility_Colour";
	var __layerlist = layer_get_all();
	var __layerlistlength = array_length_1d(__layerlist);
	var __i;

	var __layerid = -1;
	var __isforeground = false;

	// Try and find the appropriate background in the list of layers
	for(__i = 0; __i < __layerlistlength; __i++)
	{
		var __layername = layer_get_name(__layerlist[__i]);	
		if (string_pos(__colstring, __layername) > 0)
		{
			__layerid = __layerlist[__i];		
			
			break;		
		}	
	}

	if (__layerid != -1)
	{
		// We have a winner!
		// Get id of background element on this layer
		var __els = layer_get_all_elements(__layerid);
		var __elslength = array_length_1d(__els);
		for(__i = 0; __i < __elslength; __i++)
		{
			if (layer_get_element_type(__els[__i]) == layerelementtype_background)
			{				
				__result[0] = __els[__i];
				__result[1] = __layerid;
			}
		}			
	}
	else
	{
		// Need to construct a new layer with a new background
		var __newback = __background_set_element(-1, false, false, -1, 0, 0, true, true,1,1, true, 0, 0, $0, 1);
		__result[0] = __newback[0];
		__result[1] = __newback[1];	
	}

	return __result;



}


function __background_get_element(argument0) {
	var __bind = argument0;

	var __result;
	__result[0] = -1;
	__result[1] = -1;
	__result[2] = -1;


	// Look at the existing layers in the room to see if we have any foregrounds or backgrounds
	var __fgstring = "Compatibility_Foreground_";
	var __bgstring = "Compatibility_Background_";
	var __fglen = string_length(__fgstring);
	var __bglen = string_length(__bgstring);
	var __layerlist = layer_get_all();
	var __layerlistlength = array_length_1d(__layerlist);
	var __i;

	var __layerid = -1;
	var __isforeground = false;

	// Try and find the appropriate background in the list of layers
	for(__i = 0; __i < __layerlistlength; __i++)
	{
		var __layername = layer_get_name(__layerlist[__i]);	
		if (string_pos(__fgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __fglen + 1);
			if (__slotchr == "")
				continue;
			
			var __slot = real( __slotchr );
		
			if (__slot == __bind)
			{
				__layerid = __layerlist[__i];
				__isforeground = true;
			
				break;
			}		
		}
		else if (string_pos(__bgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __bglen + 1);
			if (__slotchr == "")
				continue;
			
			var __slot = real( __slotchr );
		
			if (__slot == __bind)
			{
				__layerid = __layerlist[__i];
				__isforeground = false;
			
				break;
			}		
		}	
	}

	if (__layerid != -1)
	{
		// We have a winner!
		// Get id of background element on this layer
		var __els = layer_get_all_elements(__layerid);
		var __elslength = array_length_1d(__els);
		for(__i = 0; __i < __elslength; __i++)
		{
			if (layer_get_element_type(__els[__i]) == layerelementtype_background)
			{				
				__result[0] = __els[__i];
				__result[1] = __layerid;
				__result[2] = __isforeground;
			}
		}			
	}
	else
	{
		// Need to construct a new layer with a new background
		var __newback = __background_set_element(__bind, false, false, -1, 0, 0, true, true,1,1, true, 0, 0, $ffffff, 1);
		__result[0] = __newback[0];
		__result[1] = __newback[1];
		__result[2] = false;
	}

	return __result;



}


function __background_get_internal(argument0, argument1, argument2) {
	var __prop = argument0;
	var __bind = argument1;
	var __backinfo = argument2;

	if ((__backinfo[0] == -1)
		|| (layer_background_exists(__backinfo[1], __backinfo[0]) == false))	// this can happen when we change between backgrounds and foregrounds (because layers and elements get destroyed)
	{
		// Try getting the background info again from the bind index
		__backinfo = __background_get_element(__bind);
	
		if (__backinfo[0] == -1)	
			return -1;	// erm
	}



	var __res = -1;

	var __backid = __backinfo[0];
	var __layerid = __backinfo[1];
	var __isfore = __backinfo[2];

	switch(__prop)
	{
	case e__BG.Visible: __res = layer_background_get_visible(__backid); break;
	case e__BG.Foreground: __res = __isfore; break;
	case e__BG.Index: __res = layer_background_get_sprite(__backid)  break;
	case e__BG.X: __res = layer_get_x(__layerid); break;
	case e__BG.Y: __res = layer_get_y(__layerid); break;
	case e__BG.Width: __res = sprite_get_width(layer_background_get_index(__backid)); break;
	case e__BG.Height: __res = sprite_get_height(layer_background_get_index(__backid)); break;
	case e__BG.HTiled: __res = layer_background_get_htiled(__backid); break;
	case e__BG.VTiled: __res = layer_background_get_vtiled(__backid); break;
	case e__BG.XScale: __res = layer_background_get_xscale(__backid); break;
	case e__BG.YScale: __res = layer_background_get_yscale(__backid); break;
	case e__BG.HSpeed: __res = layer_get_hspeed(__layerid); break;
	case e__BG.VSpeed: __res = layer_get_vspeed(__layerid); break;
	case e__BG.Blend: __res = layer_background_get_blend(__backid); break;
	case e__BG.Alpha: __res = layer_background_get_alpha(__backid); break;
	default: break;
	};

	return __res;



}


function __background_get_showcolour() {
	var __colinfo = __background_get_colour_element();

	if (__colinfo[0] == -1)
		return 0;
	
	var __visible = layer_background_get_visible(__colinfo[0]);
	return __visible;



}


function __background_set(argument0, argument1, argument2) {
	var __prop = argument0;
	var __bind = argument1;
	var __val = argument2;

	var __backinfo = __background_get_element(__bind);

	__background_set_internal(__prop, __bind, __val, __backinfo);

	var __res = __background_get_internal(__prop, __bind, __backinfo);
	return __res;



}


function __background_set_colour(argument0) {
	var __newcol = argument0;

	var __colinfo = __background_get_colour_element();

	if (__colinfo[0] == -1)
		return 0;
	
	layer_background_blend(__colinfo[0], __newcol);
	return __newcol;



}


function __background_set_colour_pp(argument0) {
	var __newcol = argument0;

	var __colinfo = __background_get_colour_element();

	if (__colinfo[0] == -1)
		return 0;
	
	var __col = layer_background_get_blend(__colinfo[0]);
	layer_background_blend(__colinfo[0], __newcol);
	return __col;



}


function __background_set_element(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11, argument12, argument13, argument14) {
	// NOTE: this script will only work properly if youre using the standard depth range (-16000 to 16000)
	var __bind = argument0;
	var __vis = argument1;
	var __fore = argument2;
	var __back = argument3;
	var __x = argument4;
	var __y = argument5;
	var __htiled = argument6;
	var __vtiled = argument7;
	var __xscale = argument8;
	var __yscale = argument9;
	var __stretch = argument10;
	var __hspeed = argument11;
	var __vspeed = argument12;
	var __blend = argument13;
	var __alpha = argument14;

	//var __nearestdepth = -15000;
	//var __farthestdepth = 15999;
	var __nearestdepth = 1000000000;
	var __farthestdepth = -1000000000;
	var __depthinc = 100;

	var __result;
	__result[0] = -1;
	__result[1] = -1;


	// Now look at the existing layers in the room to see if we have any foregrounds or backgrounds
	var __fgstring = "Compatibility_Foreground_";
	var __bgstring = "Compatibility_Background_";
	var __colstring = "Compatibility_Colour";
	var __fglen = string_length(__fgstring);
	var __bglen = string_length(__bgstring);
	var __layerlist = layer_get_all();
	var __layerlistlength = array_length_1d(__layerlist);
	var __collayer = -1;
	var __slots;
	var __isforeground;
	var __i;
	for(__i = 0; __i < 8; __i++)
	{
		__slots[__i] = -1;
		__isforeground[__i] = false;
	}


	for(__i = 0; __i < __layerlistlength; __i++)
	{
		var __layername = layer_get_name(__layerlist[__i]);	
		if (string_pos(__fgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __fglen + 1);
			if (__slotchr == "")
				continue;
			
			var __slot = real( __slotchr );
			__slots[__slot] = __layerlist[__i];
		
			__isforeground[__slot] = true;
		
			// Could check the contents of this layer to see if it has a single background element on it but thats probably overkill		
		}
		else if (string_pos(__bgstring, __layername) > 0)
		{
			var __slotchr = string_char_at(__layername, __bglen + 1);
			if (__slotchr == "")
				continue;
			
			var __slot = real( __slotchr );
			__slots[__slot] = __layerlist[__i];
		
			__isforeground[__slot] = false;
		
			// Could check the contents of this layer to see if it has a single background element on it but thats probably overkill		
		}
		else if (string_pos(__colstring, __layername) > 0)
		{
			// Make sure colour is as deep as it can be
			__collayer = __layerlist[__i];
			layer_depth(__layerlist[__i], __farthestdepth);
		}
		else
		{
			var __currdepth = layer_get_depth(__layerlist[__i]);
		
			if (__currdepth < __nearestdepth)
				__nearestdepth = __currdepth;
			
			if (__currdepth > __farthestdepth)
				__farthestdepth = __currdepth;
		}
	}

	// Reassign depths
	__farthestdepth += __depthinc + 1000;		// add some margin for the background layers
	__nearestdepth -= __depthinc;

	//__farthestdepth = max(__farthestdepth, 15999);
	//__nearestdepth = min(__nearestdepth, -15000);
	__farthestdepth = max(__farthestdepth, 2147483600);
	__nearestdepth = min(__nearestdepth, -2147482000);

	for(__i = 0; __i < 8; __i++)
	{
		if (__slots[__i] != -1)
		{
			var __depth = 0;
			if (__isforeground[__i] == true)
			{
				__depth = __nearestdepth - (__i * __depthinc);
			}
			else
			{
				__depth = (__farthestdepth - __depthinc) - (__slot * __depthinc);
			}
		
			layer_depth(__slots[__i], __depth);
		}
	}

	if (__collayer != -1)
	{
		layer_depth(__collayer, __farthestdepth);
	}


	// Construct our layer name and depth
	var __layername;
	var __layerdepth;
	if (__bind == -1)
	{
		// This is the background colour layer
		__layername = __colstring;
		__layerdepth = __farthestdepth;
	}
	else
	{
		if (__fore == true)
		{
			__layername = __fgstring + string(__bind);
			__layerdepth = __nearestdepth - (__bind * __depthinc);
		}
		else
		{
			__layername = __bgstring + string(__bind);
			__layerdepth = (__farthestdepth - __depthinc) - (__bind * __depthinc);	// reserve 16000 for imported colour
		}
	}

	// If we already have a background in this slot, nuke it
	var __layerid;
	if (__bind == -1)
	{
		__layerid = __collayer;
	}
	else
	{
		__layerid = __slots[__bind];
	}
	
	if (__layerid != -1)
	{
		layer_destroy(__layerid);
	}
	__layerid = layer_create(__layerdepth, __layername);

	// Set our layer properties
	layer_x(__layerid, __x);
	layer_y(__layerid, __y);
	layer_hspeed(__layerid, __hspeed);
	layer_vspeed(__layerid, __vspeed);

	// Construct our new background element
	var __backel = layer_background_create(__layerid, __back);
	layer_background_visible(__backel, __vis);
	layer_background_htiled(__backel, __htiled);
	layer_background_vtiled(__backel, __vtiled);
	layer_background_xscale(__backel, __xscale);
	layer_background_yscale(__backel, __yscale);
	layer_background_stretch(__backel, __stretch);
	layer_background_blend(__backel, __blend);
	layer_background_alpha(__backel, __alpha);

	__result[0] = __backel;
	__result[1] = __layerid;

	return __result;



}


function __background_set_internal(argument0, argument1, argument2, argument3) {
	var __prop = argument0;
	var __bind = argument1;
	var __val = argument2;
	var __backinfo = argument3;

	if (__backinfo[0] == -1)
	{
		return -1;	// erm
	}

	var __backid = __backinfo[0];
	var __layerid = __backinfo[1];
	var __isfore = __backinfo[2];

	if (__prop == e__BG.Foreground)
	{
		// This requires quite a bit of extra logic (we need to modify our layer list)
		if (round(__val) != round(__isfore))
		{
			// okay, we have a mismatch
			// Get all properties, then set the background again and copy the properties
			var __visible = layer_background_get_visible(__backid);
			var __index = layer_background_get_sprite(__backid);
			var __htiled = layer_background_get_htiled(__backid);
			var __vtiled = layer_background_get_vtiled(__backid);
			var __stretch = layer_background_get_stretch(__backid);
			var __blend = layer_background_get_blend(__backid);
			var __alpha = layer_background_get_alpha(__backid);
			var __xscale = layer_background_get_xscale(__backid);
			var __yscale = layer_background_get_yscale(__backid);
		
			var __x = layer_get_x(__layerid);
			var __y = layer_get_y(__layerid);
			var __hspeed = layer_get_hspeed(__layerid);
			var __vspeed = layer_get_vspeed(__layerid);
		
			__background_set_element(__bind, __visible, __val, __index, __x, __y, __htiled, __vtiled,__xscale,__yscale, __stretch, __hspeed, __vspeed, __blend, __alpha);
		}
	}
	else
	{
		switch(__prop)
		{
		case e__BG.Visible: layer_background_visible(__backid, __val); break;	
		case e__BG.Index: layer_background_change(__backid, __val)  break;
		case e__BG.X: layer_x(__layerid, __val); break;
		case e__BG.Y: layer_y(__layerid, __val); break;	
		case e__BG.HTiled: layer_background_htiled(__backid, __val); break;
		case e__BG.VTiled: layer_background_vtiled(__backid, __val); break;
		case e__BG.XScale: layer_background_xscale(__backid, __val); break;
		case e__BG.YScale: layer_background_yscale(__backid, __val); break;
		case e__BG.HSpeed: layer_hspeed(__layerid, __val); break;
		case e__BG.VSpeed: layer_vspeed(__layerid, __val); break;
		case e__BG.Blend: layer_background_blend(__backid, __val); break;
		case e__BG.Alpha: layer_background_alpha(__backid, __val); break;
		default: break;
		};
	}

	return -1;



}


function __background_set_pp(argument0, argument1, argument2) {
	var __prop = argument0;
	var __bind = argument1;
	var __val = argument2;

	var __backinfo = __background_get_element(__bind);
	var __res = __background_get_internal(__prop, __bind, __backinfo);

	__background_set_internal(__prop, __bind, __val, __backinfo);

	return __res;



}


function __background_set_showcolour(argument0) {
	var __newvis = argument0;

	var __colinfo = __background_get_colour_element();

	if (__colinfo[0] == -1)
		return 0;
	
	layer_background_visible(__colinfo[0], __newvis);
	return __newvis;



}


function __background_set_showcolour_pp(argument0) {
	var __newvis = argument0;

	var __colinfo = __background_get_colour_element();

	if (__colinfo[0] == -1)
		return 0;
	
	var __vis = layer_background_get_visible(__colinfo[0]);
	layer_background_visible(__colinfo[0], __newvis);
	return __vis;



}
#endregion

#region D3D
/// @description  @description Draws a simple 3D block.
/// @param x1 The initial x coordinate of the block. 
/// @param y1 The initial y coordinate of the block.
/// @param z1 The initial z coordinate of the block.
/// @param x2 The opposite x coordinate of the block.
/// @param y2 The opposite y coordinate of the block.
/// @param z2 The opposite z coordinate of the block.
/// @param tex The id of the texture to use (-1 for no texture)
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @returns 
function d3d_draw_block(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	

	d3d_primitive_begin_texture(pr_trianglelist, __tex);


	d3d_vertex_normal_texture(__x1, __y1, __z1, 0, 0, -1, 0, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z1, 0, 0, -1, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);

	d3d_vertex_normal_texture(__x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z1, 0, 0, -1, __hrepeat, 0);
	d3d_vertex_normal_texture(__x1, __y1, __z1, 0, 0, -1, 0, 0);


	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, 0, 1, 0, 0);
	d3d_vertex_normal_texture(__x2, __y1, __z2, 0, 0, 1, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);

	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y2, __z2, 0, 0, 1, 0, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, 0, 1, 0, 0);


	d3d_vertex_normal_texture(__x1, __y2, __z1, 0, 1, 0, 0, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z2, 0, 1, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);

	d3d_vertex_normal_texture(__x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z1, 0, 1, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z1, 0, 1, 0, 0, 0);


	d3d_vertex_normal_texture(__x2, __y2, __z1, 1, 0, 0, 0, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z2, 1, 0, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);

	d3d_vertex_normal_texture(__x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z1, 1, 0, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z1, 1, 0, 0, 0, 0);


	d3d_vertex_normal_texture(__x2, __y1, __z1, 0, -1, 0, 0, 0);
	d3d_vertex_normal_texture(__x2, __y1, __z2, 0, -1, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);

	d3d_vertex_normal_texture(__x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z1, 0, -1, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y1, __z1, 0, -1, 0, 0, 0);


	d3d_vertex_normal_texture(__x1, __y1, __z1, -1, 0, 0, 0, 0);
	d3d_vertex_normal_texture(__x1, __y1, __z2, -1, 0, 0, 0, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);

	d3d_vertex_normal_texture(__x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y2, __z1, -1, 0, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x1, __y1, __z1, -1, 0, 0, 0, 0);

	d3d_primitive_end();

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description Draws a simple 3D cone.
/// @param x1 The initial x coordinate of the cone.
/// @param y1 The initial y coordinate of the cone.
/// @param z1 The initial z coordinate of the cone.
/// @param x2 The opposite x coordinate of the cone.
/// @param y2 The opposite y coordinate of the cone. 
/// @param z2 The opposite z coordinate of the cone.
/// @param tex The id of the texture to use (-1 for no texture)
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @param closed Sets whether to close (true) the bottom of the cone or not (false).
/// @param steps How many steps are used to make the cone "round" (typically 24)
/// @returns 
function d3d_draw_cone(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;

	if (__steps < 3)
	{
		__steps = 3;
	}

	if (__steps > 128)
	{
		__steps = 128;
	}

	// Create sin and cos tables
	var __cc;
	var __ss;

	__cc[__steps] = 0;
	__ss[__steps] = 0;

	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}

	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	

	d3d_primitive_begin_texture(pr_trianglestrip, __tex);

	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_vertex_normal_texture(__mx, __my, __z2, 0, 0, 1, __hrepeat * __i / __steps, __vrepeat);
		d3d_vertex_normal_texture(__mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}

	d3d_primitive_end();

	if (__closed == true)
	{
		d3d_primitive_begin_texture(pr_trianglefan, __tex);
		d3d_vertex_normal_texture(__mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_vertex_normal_texture(__mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_primitive_end();
	}

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description Draws a simple 3D cylinder.
/// @param x1 The initial x coordinate of the cylinder.
/// @param y1 The initial y coordinate of the cylinder.
/// @param z1 The initial z coordinate of the cylinder.
/// @param x2 The opposite x coordinate of the cylinder.
/// @param y2 The opposite y coordinate of the cylinder. 
/// @param z2 The opposite z coordinate of the cylinder.
/// @param tex The id of the texture to use (-1 for no texture)
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @param closed Sets whether to close (true) the bottom and top of the cylinder or not (false).
/// @param steps How many steps are used to make the cylinder "round" (typically 24)
/// @returns 
function d3d_draw_cylinder(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;

	if (__steps < 3)
	{
		__steps = 3;
	}

	if (__steps > 128)
	{
		__steps = 128;
	}

	// Create sin and cos tables
	var __cc;
	var __ss;

	__cc[__steps] = 0;
	__ss[__steps] = 0;

	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}

	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	

	if (__closed == true)
	{
		d3d_primitive_begin_texture(pr_trianglefan, __tex);
		d3d_vertex_normal_texture(__mx, __my, __z2, 0, 0, 1, 0, __vrepeat);
		for(__i = 0; __i <= __steps; __i++)
		{
			d3d_vertex_normal_texture(__mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z2, 0, 0, 1, 0, __vrepeat);		
		}
		d3d_primitive_end();
	}

	d3d_primitive_begin_texture(pr_trianglestrip, __tex);

	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_vertex_normal_texture(__mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z2, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, __vrepeat);
		d3d_vertex_normal_texture(__mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}

	d3d_primitive_end();

	if (__closed == true)
	{
		d3d_primitive_begin_texture(pr_trianglefan, __tex);
		d3d_vertex_normal_texture(__mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_vertex_normal_texture(__mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_primitive_end();
	}

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description Draws a simple 3D ellipsoid.
/// @param x1 The initial x coordinate of the ellipsoid.
/// @param y1 The initial y coordinate of the ellipsoid.
/// @param z1 The initial z coordinate of the ellipsoid.
/// @param x2 The opposite x coordinate of the ellipsoid.
/// @param y2 The opposite y coordinate of the ellipsoid. 
/// @param z2 The opposite z coordinate of the ellipsoid.
/// @param tex The id of the texture to use (-1 for no texture)
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @param steps How many steps are used to make the ellipsoid "round" (typically 24)
/// @returns 
function d3d_draw_ellipsoid(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9) {

	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __steps = argument9;

	if (__steps < 3)
	{
		__steps = 3;
	}

	if (__steps > 128)
	{
		__steps = 128;
	}

	// Create sin and cos tables
	var __cc;
	var __ss;

	__cc[__steps] = 0;
	__ss[__steps] = 0;

	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}

	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __mz = (__z2 + __z1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	var __rz = (__z2 - __z1) / 2;

	var __rows = (__steps + 1) / 2;
	var __j;

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	

	for(__j = 0; __j <= (__rows - 1); __j++)
	{
		var __row1rad = (__j*pi)/__rows;
		var __row2rad = ((__j+1)*pi)/__rows;
		var __rh1 = cos(__row1rad);
		var __rd1 = sin(__row1rad);
		var __rh2 = cos(__row2rad);
		var __rd2 = sin(__row2rad);
	
		d3d_primitive_begin_texture(pr_trianglestrip, __tex);
	
		for(__i = 0; __i <= __steps; __i++)
		{
			// Some common subexpressions here that could be eliminated
			d3d_vertex_normal_texture(__mx+__rx*__rd1*__cc[__i], __my+__ry*__rd1*__ss[__i], __mz+__rz*__rh1,__rd1*__cc[__i], __rd1*__ss[__i], __rh1, __hrepeat*__i/__steps, __j*__vrepeat/__rows);
			d3d_vertex_normal_texture(__mx+__rx*__rd2*__cc[__i], __my+__ry*__rd2*__ss[__i], __mz+__rz*__rh2,__rd2*__cc[__i], __rd2*__ss[__i], __rh2, __hrepeat*__i/__steps, (__j+1)*__vrepeat/__rows);
		}
	
		d3d_primitive_end();
	}

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description Draws a simple 3D floor.
/// @param x1 The initial x coordinate of the floor.
/// @param y1 The initial y coordinate of the floor.
/// @param z1 The initial z coordinate of the floor.
/// @param x2 The opposite x coordinate of the floor.
/// @param y2 The opposite y coordinate of the floor. 
/// @param z2 The opposite z coordinate of the floor.
/// @param tex The id of the texture to use (-1 for no texture)
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @returns 
function d3d_draw_floor(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;

	var __xdiff = __x2 - __x1;
	var __zdiff = __z2 - __z1;

	var __lsquared = (__xdiff * __xdiff) + (__zdiff * __zdiff);
	if (__lsquared == 0)
		return 0;
	
	var __l = sqrt(__lsquared);

	var __nx = -__zdiff / __l;
	var __nz = __xdiff / __l;

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)

	d3d_primitive_begin_texture(pr_trianglefan, __tex);

	d3d_vertex_normal_texture(__x1, __y1, __z1, __nx, 0, __nz, 0, 0);
	d3d_vertex_normal_texture(__x1, __y2, __z1, __nx, 0, __nz, 0, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y2, __z2, __nx, 0, __nz, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x2, __y1, __z2, __nx, 0, __nz, __hrepeat, 0);

	d3d_primitive_end();

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description Draws a simple 3D vertical wall.
/// @param x1 The initial x coordinate of the wall.
/// @param y1 The initial y coordinate of the wall.
/// @param z1 The initial z coordinate of the wall.
/// @param x2 The opposite x coordinate of the wall.
/// @param y2 The opposite y coordinate of the wall. 
/// @param z2 The opposite z coordinate of the wall.
/// @param tex The id of the texture to use (-1 for no texture)
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @returns 
function d3d_draw_wall(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	//var ret = global.__d3d;
	//global.__d3d = false;
	//return ret;

	var __x1 = argument0;
	var __y1 = argument1;
	var __z1 = argument2;
	var __x2 = argument3;
	var __y2 = argument4;
	var __z2 = argument5;
	var __tex = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;

	var __xdiff = __x2 - __x1;
	var __ydiff = __y2 - __y1;

	var __lsquared = (__xdiff * __xdiff) + (__ydiff * __ydiff);
	if (__lsquared == 0)
		return 0;
	
	var __l = sqrt(__lsquared);

	var __nx = __ydiff / __l;
	var __ny = -__xdiff / __l;

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	

	d3d_primitive_begin_texture(pr_trianglefan, __tex);

	d3d_vertex_normal_texture(__x1, __y1, __z1, __nx, __ny, 0, 0, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z1, __nx, __ny, 0, __hrepeat, 0);
	d3d_vertex_normal_texture(__x2, __y2, __z2, __nx, __ny, 0, __hrepeat, __vrepeat);
	d3d_vertex_normal_texture(__x1, __y1, __z2, __nx, __ny, 0, 0, __vrepeat);

	d3d_primitive_end();

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description d3d - disable 3d
/// @param enable true if enabled, false if disabled
function d3d_end() {
	var ret = global.__d3d;
	global.__d3d = false;
	gpu_set_ztestenable(false);
	gpu_set_zwriteenable(false);
	return ret;



}


/// @description  @description d3d - set the ambient colour
/// @param colour colour for the ambient light
function d3d_light_define_ambient(argument0) {
	draw_light_define_ambient( argument0 );




}


/// @description  @description d3d - set the direction of a specific light
/// @param index	number of light 
/// @param x	x component
/// @param y	y component
/// @param z	z component
/// @param col	colour for this light
function d3d_light_define_direction(argument0, argument1, argument2, argument3, argument4) {
	draw_light_define_direction( argument0, argument1, argument2, argument3, argument4 );




}


/// @description  @description d3d - set the point and of a specific light
/// @param index	number of light 
/// @param x	x component
/// @param y	y component
/// @param z	z component
/// @param range	range for this light
/// @param col	colour for this light
function d3d_light_define_point(argument0, argument1, argument2, argument3, argument4, argument5) {
	draw_light_define_point( argument0, argument1, argument2, argument3, argument4, argument5 );




}


/// @description  @description d3d - enable lighting
/// @param index	number of light 
/// @param enable	true if enabled, false if disabled
function d3d_light_enable(argument0, argument1) {
	draw_light_enable( argument0, argument1 );



}


/// @description  @description Adds a block shape to the model.
/// @param ind The model index to add the block to.
/// @param x1 The initial x coordinate of the block. 
/// @param y1 The initial y coordinate of the block.
/// @param z1 The initial z coordinate of the block.
/// @param x2 The opposite x coordinate of the block.
/// @param y2 The opposite y coordinate of the block.
/// @param z2 The opposite z coordinate of the block.
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @returns 
function d3d_model_block(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var __ind = argument0
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	

	d3d_model_primitive_begin(__ind, pr_trianglelist);


	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, 0, 0, -1, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, 0, 0, -1, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);

	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 0, 0, -1, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 0, 0, -1, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, 0, 0, -1, 0, 0);


	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, 0, 1, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 0, 0, 1, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);

	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 0, 1, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, 0, 0, 1, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, 0, 1, 0, 0);


	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, 0, 1, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, 0, 1, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);

	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 0, 1, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 0, 1, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, 0, 1, 0, 0, 0);


	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 1, 0, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, 1, 0, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);

	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 1, 0, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 1, 0, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, 1, 0, 0, 0, 0);


	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 0, -1, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, 0, -1, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);

	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, 0, -1, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, 0, -1, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z1, 0, -1, 0, 0, 0);


	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, -1, 0, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, -1, 0, 0, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);

	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z2, -1, 0, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, -1, 0, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, -1, 0, 0, 0, 0);

	d3d_model_primitive_end(__ind);



}


/// @description  @description Clears the model with the given index, removing all its primitives.
/// @param ind The index of the model to be cleared.
/// @returns 
function d3d_model_clear(argument0) {

	var __m = argument0;

	// Scrub any buffers we have created
	if (__m[e__YYM.PointB] != undefined)
	{
		buffer_delete(__m[e__YYM.PointB]);
		__m[e__YYM.PointB] = undefined;
	}

	if (__m[e__YYM.LineB] != undefined)
	{
		buffer_delete(__m[e__YYM.LineB]);
		__m[e__YYM.LineB] = undefined;
	}

	if (__m[e__YYM.TriB] != undefined)
	{
		buffer_delete(__m[e__YYM.TriB]);
		__m[e__YYM.TriB] = undefined;
	}

	if (__m[e__YYM.PointUVB] != undefined)
	{
		buffer_delete(__m[e__YYM.PointUVB]);
		__m[e__YYM.PointUVB] = undefined;
	}

	if (__m[e__YYM.LineUVB] != undefined)
	{
		buffer_delete(__m[e__YYM.LineUVB]);
		__m[e__YYM.LineUVB] = undefined;
	}

	if (__m[e__YYM.TriUVB] != undefined)
	{
		buffer_delete(__m[e__YYM.TriUVB]);
		__m[e__YYM.TriUVB] = undefined;
	}

	// Scrub any vertex buffers we have created
	if (__m[e__YYM.PointVB] != undefined)
	{
		vertex_delete_buffer(__m[e__YYM.PointVB]);
		__m[e__YYM.PointVB] = undefined;
	}

	if (__m[e__YYM.LineVB] != undefined)
	{
		vertex_delete_buffer(__m[e__YYM.LineVB]);
		__m[e__YYM.LineVB] = undefined;
	}

	if (__m[e__YYM.TriVB] != undefined)
	{
		vertex_delete_buffer(__m[e__YYM.TriVB]);
		__m[e__YYM.TriVB] = undefined;
	}

	// Set num verts to zero
	__m[e__YYM.NumVerts] = 0;
	__m[e__YYM.NumPointCols] = 0;
	__m[e__YYM.NumLineCols] = 0;
	__m[e__YYM.NumTriCols] = 0;



}


/// @description  @description Adds a cone shape to the model.
/// @param ind The model index to add the cone to.
/// @param x1 The initial x coordinate of the cone.
/// @param y1 The initial y coordinate of the cone.
/// @param z1 The initial z coordinate of the cone.
/// @param x2 The opposite x coordinate of the cone.
/// @param y2 The opposite y coordinate of the cone. 
/// @param z2 The opposite z coordinate of the cone.
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @param closed Sets whether to close (true) the bottom of the cone or not (false).
/// @param steps How many steps are used to make the cone "round" (typically 24)
/// @returns 
function d3d_model_cone(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;

	if (__steps < 3)
	{
		__steps = 3;
	}

	if (__steps > 128)
	{
		__steps = 128;
	}

	// Create sin and cos tables
	var __cc;
	var __ss;

	__cc[__steps] = 0;
	__ss[__steps] = 0;

	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}

	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;

	d3d_model_primitive_begin(__ind, pr_trianglestrip);

	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z2, 0, 0, 1, __hrepeat * __i / __steps, __vrepeat);
		d3d_model_vertex_normal_texture(__ind, __mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}

	d3d_model_primitive_end(__ind);

	if (__closed == true)
	{
		d3d_model_primitive_begin(__ind, pr_trianglefan);
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_model_vertex_normal_texture(__ind, __mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_model_primitive_end(__ind);
	}



}


/// @description  @description Creates a new model and returns its index.
/// @returns {number} returns the new model
function d3d_model_create() {

	var pointcols;
	var linecols;
	var tricols;
	pointcols[0] = -1;
	linecols[0] = -1;
	tricols[0] = -1;

	var model = [ undefined,				// point buffer
				  undefined,				// line buffer
				  undefined,				// tri list buffer
				  undefined,				// point uv buffer
				  undefined,				// line uv buffer
				  undefined,				// tri uv buffer
				  undefined,				// point vertex buffer
				  undefined,				// line vertex buffer
				  undefined,				// tri list buffer			  
				  $00010000,/*draw_get_colour(),*/		// colour used when creating
				  -1,						// last texture used for drawing
				  0,						// num vertices
				  0,						// prim kind
				  0,						// number of non-colour point vertices
				  0,						// number of non-colour line vertices
				  0,						// number of non-colour tri vertices
				  pointcols,				// offsets to point colours
				  linecols,					// offsets to line colours
				  tricols,					// offsets to tri colours
			  
				  0, 0, 0, 0, 0, 0, 0, 0, 0,	// vertex 1
				  0, 0, 0, 0, 0, 0, 0, 0, 0,	// vertex 2
			  
				];
			  
	return model;





}


/// @description  @description Adds a cylinder shape to the model.
/// @param ind The model index to add the cylinder to.
/// @param x1 The initial x coordinate of the cylinder.
/// @param y1 The initial y coordinate of the cylinder.
/// @param z1 The initial z coordinate of the cylinder.
/// @param x2 The opposite x coordinate of the cylinder.
/// @param y2 The opposite y coordinate of the cylinder. 
/// @param z2 The opposite z coordinate of the cylinder.
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @param closed Sets whether to close (true) the bottom and top of the cylinder or not (false).
/// @param steps How many steps are used to make the cylinder "round" (typically 24)
/// @returns 
function d3d_model_cylinder(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __closed = argument9;
	var __steps = argument10;

	if (__steps < 3)
	{
		__steps = 3;
	}

	if (__steps > 128)
	{
		__steps = 128;
	}

	// Create sin and cos tables
	var __cc;
	var __ss;

	__cc[__steps] = 0;
	__ss[__steps] = 0;

	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}

	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;

	if (__closed == true)
	{
		d3d_model_primitive_begin(__ind, pr_trianglefan);
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z2, 0, 0, 1, 0, __vrepeat);
		for(__i = 0; __i <= __steps; __i++)
		{
			d3d_model_vertex_normal_texture(__ind, __mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z2, 0, 0, 1, 0, __vrepeat);		
		}
		d3d_model_primitive_end(__ind);
	}

	d3d_model_primitive_begin(__ind, pr_trianglestrip);

	for(__i = 0; __i <= __steps; __i++)
	{
		d3d_model_vertex_normal_texture(__ind, __mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z2, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, __vrepeat);
		d3d_model_vertex_normal_texture(__ind, __mx + __cc[__i]*__rx, __my + __ss[__i]*__ry, __z1, __cc[__i] , __ss[__i] ,0 , __hrepeat * __i / __steps, 0);
	}

	d3d_model_primitive_end(__ind);

	if (__closed == true)
	{
		d3d_model_primitive_begin(__ind, pr_trianglefan);
		d3d_model_vertex_normal_texture(__ind, __mx, __my, __z1, 0, 0, -1, 0, 0);
		for(__i = __steps; __i >= 0; __i--)
		{
			d3d_model_vertex_normal_texture(__ind, __mx+__cc[__i]*__rx, __my+__ss[__i]*__ry, __z1, 0, 0, -1, 0, 0);		
		}
		d3d_model_primitive_end(__ind);
	}



}


/// @description  @description Destroys the model with the given index, freeing its memory.
/// @param ind The index of the model to be destroyed.
/// @returns 
function d3d_model_destroy(argument0) {

	d3d_model_clear(argument0);



}


/// @description  @description Draws the model at position (x, y, z).
/// @param x
/// @param  y
/// @param  z
/// @param ind The index of the model to be drawn.
/// @param x The x position to draw the model. 
/// @param y The y position to draw the model.
/// @param z The z position to draw the model.
/// @param texid The texture to use for drawing the model (use -1 to use no texture).
/// @returns
function d3d_model_draw(argument0, argument1, argument2, argument3, argument4) {

	var m = argument0;

	var tex = argument4;
	var vertsize = 36;
	var vertuvoffset = 28;
	if (tex!=-1 && tex != m[e__YYM.Texture])
	{	

		var texuvs = texture_get_uvs(tex);
		var uspan = texuvs[2] - texuvs[0];
		var vspan = texuvs[3] - texuvs[1];
		var ubase  = texuvs[0];
		var vbase  = texuvs[1];

	
		// Copy and scale\bias the unmolested UV coords to our buffers
		var __i;
	
		if ((m[e__YYM.PointB] != undefined) && (m[e__YYM.PointUVB] != undefined))
		{
			var numverts = buffer_tell(m[e__YYM.PointUVB]) / 8;
				
			buffer_seek(m[e__YYM.PointUVB], buffer_seek_start, 0);
			var __uvpos = vertuvoffset;
			var __src = m[e__YYM.PointUVB];
			var __dest = m[e__YYM.PointB];
			for(__i = 0; __i < numverts; __i++)
			{
				var __u = buffer_read(__src, buffer_f32);
				var __v = buffer_read(__src, buffer_f32);
			
				__u = (__u * uspan) + ubase;
				__v = (__v * vspan) + vbase;
						
				buffer_poke(__dest, __uvpos, buffer_f32, __u);
				buffer_poke(__dest, __uvpos + 4, buffer_f32, __v);
			
				__uvpos += vertsize;
			}
		}
	
		if ((m[e__YYM.LineB] != undefined) && (m[e__YYM.LineUVB] != undefined))
		{
			var numverts = buffer_tell(m[e__YYM.LineUVB]) / 8;
				
			buffer_seek(m[e__YYM.LineUVB], buffer_seek_start, 0);
			var __uvpos = vertuvoffset;
			var __src = m[e__YYM.LineUVB];
			var __dest = m[e__YYM.LineB];
			for(__i = 0; __i < numverts; __i++)
			{
				var __u = buffer_read(__src, buffer_f32);
				var __v = buffer_read(__src, buffer_f32);
			
				__u = (__u * uspan) + ubase;
				__v = (__v * vspan) + vbase;
						
				buffer_poke(__dest, __uvpos, buffer_f32, __u);
				buffer_poke(__dest, __uvpos + 4, buffer_f32, __v);
			
				__uvpos += vertsize;
			}
		}
	
		if ((m[e__YYM.TriB] != undefined) && (m[e__YYM.TriUVB] != undefined))
		{
			var numverts = buffer_tell(m[e__YYM.TriUVB]) / 8;
				
			buffer_seek(m[e__YYM.TriUVB], buffer_seek_start, 0);
			var __uvpos = vertuvoffset;
			var __src = m[e__YYM.TriUVB];
			var __dest =m[e__YYM.TriB];
			for(__i = 0; __i < numverts; __i++)
			{
				var __u = buffer_read(__src, buffer_f32);
				var __v = buffer_read(__src, buffer_f32);
			
				__u = (__u * uspan) + ubase;
				__v = (__v * vspan) + vbase;
						
				buffer_poke(__dest, __uvpos, buffer_f32, __u);
				buffer_poke(__dest, __uvpos + 4, buffer_f32, __v);
			
				__uvpos += vertsize;
			}
		}
	
	
		m[@e__YYM.Texture] = tex;

		// remove the current Vertex Buffers if present
		if (m[e__YYM.PointVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.PointVB]);
			m[@e__YYM.PointVB] = undefined;
		} // end if

		if (m[e__YYM.LineVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.LineVB]);
			m[@e__YYM.LineVB] = undefined;
		} // end if
	
		if (m[e__YYM.TriVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.TriVB]);
			m[@e__YYM.TriVB] = undefined;
		} // end if
	}


	var currColour = draw_get_colour() | ((draw_get_alpha()*255.0) << 24);
	// if colour is different from the previous cached entry then rebuild the model
	if ((currColour != m[e__YYM.Colour]) && ((m[e__YYM.NumPointCols] > 0) || (m[e__YYM.NumLineCols] > 0) || (m[e__YYM.NumTriCols] > 0))) {

		var __numPointCols = m[e__YYM.NumPointCols];
		var __numLineCols = m[e__YYM.NumLineCols];
		var __numTriCols = m[e__YYM.NumTriCols];

		// go through and change all the entries with no colour in them to be the same as the draw colour
		var __i;
	
		if (m[e__YYM.PointB] != undefined)
		{
			var __offsets = m[e__YYM.PointCols];
			var __dest = m[e__YYM.PointB];
			for(__i = 0; __i < __numPointCols; __i++)
			{
				buffer_poke(__dest, __offsets[__i], buffer_u32, currColour);
			}
		}
	
		if (m[e__YYM.LineB] != undefined)
		{
			var __offsets = m[e__YYM.LineCols];
			var __dest = m[e__YYM.LineB];
			for(__i = 0; __i < __numLineCols; __i++)
			{
				buffer_poke(__dest, __offsets[__i], buffer_u32, currColour);
			}
		}
	
		if (m[e__YYM.TriB] != undefined)
		{
			var __offsets = m[e__YYM.TriCols];
			var __dest = m[e__YYM.TriB];
			for(__i = 0; __i < __numTriCols; __i++)
			{
				buffer_poke(__dest, __offsets[__i], buffer_u32, currColour);
			}
		}

		// remove the current Vertex Buffers if present
		if (m[e__YYM.PointVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.PointVB]);
			m[@e__YYM.PointVB] = undefined;
		} // end if

		if (m[e__YYM.LineVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.LineVB]);
			m[@e__YYM.LineVB] = undefined;
		} // end if
	
		if (m[e__YYM.TriVB] != undefined) {
			vertex_delete_buffer(m[e__YYM.TriVB]);
			m[@e__YYM.TriVB] = undefined;
		} // end if
	
		m[@e__YYM.Colour] = currColour;
	} // end if

	// set the translation to this (argument1, argument2, argument3)
	var mW = matrix_get( matrix_world );
	var mT = matrix_build( argument1, argument2, argument3, 0, 0, 0, 1, 1, 1 );
	var mNew = matrix_multiply( mT, mW );
	matrix_set( matrix_world, mNew );

	var __oldrep = gpu_get_texrepeat();
	gpu_set_texrepeat(true)	

	// draw the tri list buffer
	if (m[e__YYM.TriB] != undefined) {

		// convert to a vertex buffer if need be
		if (m[e__YYM.TriVB] == undefined) {
			m[@e__YYM.TriVB] = vertex_create_buffer_from_buffer( m[e__YYM.TriB], global.__d3dPrimVF );
			vertex_freeze(m[e__YYM.TriVB]);		
		} // end if
	
		vertex_submit( m[e__YYM.TriVB], pr_trianglelist, argument4 );
	} // end if

	// draw the line buffer
	if (m[e__YYM.LineB] != undefined) {

		// convert to a vertex buffer if need be
		if (m[e__YYM.LineVB] == undefined) {
			m[@e__YYM.LineVB] = vertex_create_buffer_from_buffer( m[e__YYM.LineB], global.__d3dPrimVF );
			vertex_freeze(m[e__YYM.LineVB]);
		} // end if
	
		vertex_submit( m[e__YYM.LineVB], pr_linelist, argument4 );
	} // end if

	// draw the point buffer
	if (m[e__YYM.PointB] != undefined) {

		// convert to a vertex buffer if need be
		if (m[e__YYM.PointVB] == undefined) {
			m[@e__YYM.PointVB] = vertex_create_buffer_from_buffer( m[e__YYM.PointB], global.__d3dPrimVF );
			vertex_freeze(m[e__YYM.PointVB]);
		} // end if
	
		vertex_submit( m[e__YYM.PointVB], pr_pointlist,  argument4 );
	} // end if

	// Restore the matrix
	matrix_set( matrix_world, mW );

	gpu_set_texrepeat(__oldrep);



}


/// @description  @description Adds an ellipsoid shape to the model.
/// @param ind The model index to add the ellipsoid to.
/// @param x1 The initial x coordinate of the ellipsoid.
/// @param y1 The initial y coordinate of the ellipsoid.
/// @param z1 The initial z coordinate of the ellipsoid.
/// @param x2 The opposite x coordinate of the ellipsoid.
/// @param y2 The opposite y coordinate of the ellipsoid. 
/// @param z2 The opposite z coordinate of the ellipsoid.
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @param steps How many steps are used to make the ellipsoid "round" (typically 24)
/// @returns 
function d3d_model_ellipsoid(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9) {

	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;
	var __steps = argument9;

	if (__steps < 3)
	{
		__steps = 3;
	}

	if (__steps > 128)
	{
		__steps = 128;
	}

	// Create sin and cos tables
	var __cc;
	var __ss;

	__cc[__steps] = 0;
	__ss[__steps] = 0;

	var __i;
	for(__i = 0; __i <= __steps; __i++)
	{
		var __rad = (__i * 2.0 * pi) / __steps;
		__cc[__i] = cos(__rad);
		__ss[__i] = sin(__rad);
	}

	var __mx = (__x2 + __x1) / 2;
	var __my = (__y2 + __y1) / 2;
	var __mz = (__z2 + __z1) / 2;
	var __rx = (__x2 - __x1) / 2;
	var __ry = (__y2 - __y1) / 2;
	var __rz = (__z2 - __z1) / 2;

	var __rows = (__steps + 1) / 2;
	var __j;

	for(__j = 0; __j <= (__rows - 1); __j++)
	{
		var __row1rad = (__j*pi)/__rows;
		var __row2rad = ((__j+1)*pi)/__rows;
		var __rh1 = cos(__row1rad);
		var __rd1 = sin(__row1rad);
		var __rh2 = cos(__row2rad);
		var __rd2 = sin(__row2rad);
	
		d3d_model_primitive_begin(__ind, pr_trianglestrip);
	
		for(__i = 0; __i <= __steps; __i++)
		{
			// Some common subexpressions here that could be eliminated
			d3d_model_vertex_normal_texture(__ind, __mx+__rx*__rd1*__cc[__i], __my+__ry*__rd1*__ss[__i], __mz+__rz*__rh1,__rd1*__cc[__i], __rd1*__ss[__i], __rh1, __hrepeat*__i/__steps, __j*__vrepeat/__rows);
			d3d_model_vertex_normal_texture(__ind, __mx+__rx*__rd2*__cc[__i], __my+__ry*__rd2*__ss[__i], __mz+__rz*__rh2,__rd2*__cc[__i], __rd2*__ss[__i], __rh2, __hrepeat*__i/__steps, (__j+1)*__vrepeat/__rows);
		}
	
		d3d_model_primitive_end(__ind);
	}



}


/// @description  @description Adds a floor shape to the model.
/// @param ind The model index to add the floor to.
/// @param x1 The initial x coordinate of the floor.
/// @param y1 The initial y coordinate of the floor.
/// @param z1 The initial z coordinate of the floor.
/// @param x2 The opposite x coordinate of the floor.
/// @param y2 The opposite y coordinate of the floor. 
/// @param z2 The opposite z coordinate of the floor.
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @returns 
function d3d_model_floor(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;

	var __xdiff = __x2 - __x1;
	var __zdiff = __z2 - __z1;

	var __lsquared = (__xdiff * __xdiff) + (__zdiff * __zdiff);
	if (__lsquared == 0)
		return 0;
	
	var __l = sqrt(__lsquared);

	var __nx = -__zdiff / __l;
	var __nz = __xdiff / __l;

	d3d_model_primitive_begin(__ind, pr_trianglefan);

	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, __nx, 0, __nz, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x1, __y2, __z1, __nx, 0, __nz, 0, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, __nx, 0, __nz, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x2, __y1, __z2, __nx, 0, __nz, __hrepeat, 0);

	d3d_model_primitive_end(__ind);



}


/// @description  @description  Loads the model from the indicated file name.
/// @param ind The index of the model to be loaded.
/// @param fname The name of the file to load the model from.
function d3d_model_load(argument0, argument1) {

	var __ind = argument0;
	var __fname = argument1;

	var __file = file_text_open_read(__fname);
	if (__file == -1)
		return -1;
	
	// Get version number
	var __version = file_text_read_real(__file);
	if (__version != 100)
	{
		file_text_close(__file);
		return - 1; // wrong version
	}
	file_text_readln(__file);

	// Get number of entries
	var __numthings = file_text_read_real(__file);
	file_text_readln(__file);

	// At this point, scrub the contents of the passed-in model
	d3d_model_clear(__ind);

	// Now parse the contents of the file
	var __currthing = 0;
	var __i;
	while(__currthing < __numthings)
	{
		// Every entry is 11 values - 1 command and 10 parameters
		var __kind = round(file_text_read_real(__file));
		var __args;
		for(__i = 0; __i < 10; __i++)
		{
			__args[__i] = file_text_read_real(__file);
		}
		file_text_readln(__file);
	
		switch(__kind)
		{
			case e__YYMKIND.PRIMITIVE_BEGIN:	d3d_model_primitive_begin(__ind, round(__args[0])); break;
			case e__YYMKIND.PRIMITIVE_END:		d3d_model_primitive_end(__ind); break;
			case e__YYMKIND.VERTEX:				d3d_model_vertex(__ind, __args[0], __args[1], __args[2]); break;
			case e__YYMKIND.VERTEX_COLOR:		d3d_model_vertex_color(__ind, __args[0], __args[1], __args[2], round(__args[3]), __args[4]); break;
			case e__YYMKIND.VERTEX_TEX:			d3d_model_vertex_texture(__ind, __args[0], __args[1], __args[2], __args[3], __args[4]); break;
			case e__YYMKIND.VERTEX_TEX_COLOR:	d3d_model_vertex_texture_color(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], round(__args[5]), __args[6]); break;
			case e__YYMKIND.VERTEX_N:			d3d_model_vertex_normal(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5]); break;
			case e__YYMKIND.VERTEX_N_COLOR:		d3d_model_vertex_normal_color(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], round(__args[6]), __args[7]); break;
			case e__YYMKIND.VERTEX_N_TEX:		d3d_model_vertex_normal_texture(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;
			case e__YYMKIND.VERTEX_N_TEX_COLOR: d3d_model_vertex_normal_texture_color(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8]), __args[9]); break;
			case e__YYMKIND.SHAPE_BLOCK:		d3d_model_block(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;
			case e__YYMKIND.SHAPE_CYLINDER:		d3d_model_cylinder(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8]), round(__args[9])); break;
			case e__YYMKIND.SHAPE_CONE:			d3d_model_cone(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8]), round(__args[9])); break;
			case e__YYMKIND.SHAPE_ELLIPSOID:	d3d_model_ellipsoid(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7], round(__args[8])); break;
			case e__YYMKIND.SHAPE_WALL:			d3d_model_wall(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;
			case e__YYMKIND.SHAPE_FLOOR:		d3d_model_floor(__ind, __args[0], __args[1], __args[2], __args[3], __args[4], __args[5], __args[6], __args[7]); break;		
		};
	
		__currthing++;
	}

	
	file_text_close(__file);



}


/// @description  @description  Begins the process of defining a primitive that is to be added to a model in 3D.
/// @param ind The index of the model to add the primitive to.
/// @param kind The kind of primitive you are going to draw.
function d3d_model_primitive_begin(argument0, argument1) {

	var m = argument0;
	m[@ e__YYM.PrimKind] = argument1;




}


/// @description  @description  Ends the process of adding primitives to a model in 3D.
/// @param ind The index of the model to end the addition of primitives to.
function d3d_model_primitive_end(argument0) {

	var m = argument0;
	m[@ e__YYM.PrimKind] = 0;




}


/// @description  @description  Saves the model to the indicated file name.
/// @param ind The index of the model to be saved.
/// @param fname The name of the file to save the model to.
function d3d_model_save(argument0, argument1) {

	var __ind = argument0;
	var __fname = argument1;

	var __file = file_text_open_write(__fname);
	if (__file == -1)
		return -1;
	
	var __vertexsize = 36;		// combined size of position, normal, colour and uv
	
	// Count up the number of things we have in the model
	var __numthings = 0;
	var __numpointverts = 0;
	var __numlineverts = 0;
	var __numtriverts = 0;

	if (__ind[e__YYM.PointB] != undefined)
	{
		var __buffpos = buffer_tell(__ind[e__YYM.PointB]);
		if (__buffpos > 0)
		{
			__numthings += 2;		// include primitive begin\end
		}
	
		// Now add the number of vertices
		__numpointverts = __buffpos / __vertexsize;
		__numthings += __numpointverts;
	}

	if (__ind[e__YYM.LineB] != undefined)
	{
		var __buffpos = buffer_tell(__ind[e__YYM.LineB]);
		if (__buffpos > 0)
		{
			__numthings += 2;		// include primitive begin\end
		}
	
		// Now add the number of vertices
		__numlineverts = __buffpos / __vertexsize;
		__numthings += __numlineverts;
	}

	if (__ind[e__YYM.TriB] != undefined)
	{
		var __buffpos = buffer_tell(__ind[e__YYM.TriB]);
		if (__buffpos > 0)
		{
			__numthings += 2;		// include primitive begin\end
		}
	
		// Now add the number of vertices
		__numtriverts = __buffpos / __vertexsize;
		__numthings += __numtriverts;
	}

	file_text_write_string(__file, "100");
	file_text_writeln(__file);
	file_text_write_string(__file, string_format(__numthings, 0, 0));
	file_text_writeln(__file);

	if (__ind[e__YYM.PointB] != undefined)
	{	
		var __buf = __ind[e__YYM.PointB];
		if (__numpointverts > 0)
		{
			// Primitive begin (pointlist)
			file_text_write_string(__file, "0 " + string_format(pr_pointlist, 10, 4) + " 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		
			// Vertices		
			buffer_seek(__buf, buffer_seek_start, 0);		// after reading through the whole buffer we should end up back at the end
			var __i;
			for(__i = 0; __i < __numpointverts; __i++)
			{			
				var __x = buffer_read(__buf, buffer_f32);
				var __y = buffer_read(__buf, buffer_f32);
				var __z = buffer_read(__buf, buffer_f32);
				var __nx = buffer_read(__buf, buffer_f32);
				var __ny = buffer_read(__buf, buffer_f32);
				var __nz = buffer_read(__buf, buffer_f32);
				var __colalpha = buffer_read(__buf, buffer_u32);
				var __u = buffer_read(__buf, buffer_f32);
				var __v = buffer_read(__buf, buffer_f32);
			
				// Need to separate colour and alpha
				var __col = __colalpha & $00ffffff;
				var __alpha = ((__colalpha >> 24) & $ff) / 255.0;
			
				file_text_write_string(__file, "9"
										+ " " + string_format(__x, 10, 4)
										+ " " + string_format(__y, 10, 4)
										+ " " + string_format(__z, 10, 4)
										+ " " + string_format(__nx, 10, 4)
										+ " " + string_format(__ny, 10, 4)
										+ " " + string_format(__nz, 10, 4)
										+ " " + string_format(__u, 10, 4)
										+ " " + string_format(__v, 10, 4)
										+ " " + string_format(__col, 10, 4)
										+ " " + string_format(__alpha, 10, 4)
										);
				file_text_writeln(__file);
			}
		
			// Primitive end
			file_text_write_string(__file, "1 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		}
	}

	if (__ind[e__YYM.LineB] != undefined)
	{	
		var __buf = __ind[e__YYM.LineB];
		if (__numlineverts > 0)
		{
			// Primitive begin (pointlist)
			file_text_write_string(__file, "0 " + string_format(pr_linelist, 10, 4) + " 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		
			// Vertices		
			buffer_seek(__buf, buffer_seek_start, 0);		// after reading through the whole buffer we should end up back at the end
			var __i;
			for(__i = 0; __i < __numlineverts; __i++)
			{			
				var __x = buffer_read(__buf, buffer_f32);
				var __y = buffer_read(__buf, buffer_f32);
				var __z = buffer_read(__buf, buffer_f32);
				var __nx = buffer_read(__buf, buffer_f32);
				var __ny = buffer_read(__buf, buffer_f32);
				var __nz = buffer_read(__buf, buffer_f32);
				var __colalpha = buffer_read(__buf, buffer_u32);
				var __u = buffer_read(__buf, buffer_f32);
				var __v = buffer_read(__buf, buffer_f32);
			
				// Need to separate colour and alpha
				var __col = __colalpha & $00ffffff;
				var __alpha = ((__colalpha >> 24) & $ff) / 255.0;
			
				file_text_write_string(__file, "9"
										+ " " + string_format(__x, 10, 4)
										+ " " + string_format(__y, 10, 4)
										+ " " + string_format(__z, 10, 4)
										+ " " + string_format(__nx, 10, 4)
										+ " " + string_format(__ny, 10, 4)
										+ " " + string_format(__nz, 10, 4)
										+ " " + string_format(__u, 10, 4)
										+ " " + string_format(__v, 10, 4)
										+ " " + string_format(__col, 10, 4)
										+ " " + string_format(__alpha, 10, 4)
										);
				file_text_writeln(__file);
			}
		
			// Primitive end
			file_text_write_string(__file, "1 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		}
	}

	if (__ind[e__YYM.TriB] != undefined)
	{	
		var __buf = __ind[e__YYM.TriB];
		if (__numtriverts > 0)
		{
			// Primitive begin (pointlist)
			file_text_write_string(__file, "0 " + string_format(pr_trianglelist, 10, 4) + " 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		
			// Vertices		
			buffer_seek(__buf, buffer_seek_start, 0);		// after reading through the whole buffer we should end up back at the end
			var __i;
			for(__i = 0; __i < __numtriverts; __i++)
			{			
				var __x = buffer_read(__buf, buffer_f32);
				var __y = buffer_read(__buf, buffer_f32);
				var __z = buffer_read(__buf, buffer_f32);
				var __nx = buffer_read(__buf, buffer_f32);
				var __ny = buffer_read(__buf, buffer_f32);
				var __nz = buffer_read(__buf, buffer_f32);
				var __colalpha = buffer_read(__buf, buffer_u32);
				var __u = buffer_read(__buf, buffer_f32);
				var __v = buffer_read(__buf, buffer_f32);
			
				// Need to separate colour and alpha
				var __col = __colalpha & $00ffffff;
				var __alpha = ((__colalpha >> 24) & $ff) / 255.0;
			
				file_text_write_string(__file, "9"
										+ " " + string_format(__x, 10, 4)
										+ " " + string_format(__y, 10, 4)
										+ " " + string_format(__z, 10, 4)
										+ " " + string_format(__nx, 10, 4)
										+ " " + string_format(__ny, 10, 4)
										+ " " + string_format(__nz, 10, 4)
										+ " " + string_format(__u, 10, 4)
										+ " " + string_format(__v, 10, 4)
										+ " " + string_format(__col, 10, 4)
										+ " " + string_format(__alpha, 10, 4)
										);
				file_text_writeln(__file);
			}
		
			// Primitive end
			file_text_write_string(__file, "1 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000 0000000000.0000");
			file_text_writeln(__file);
		}
	}
	
	file_text_close(__file);



}


/// @description  @description  Add vertex (x,y,z) to the model.
/// @param x
/// @param y
/// @param z
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
function d3d_model_vertex(argument0, argument1, argument2, argument3) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, $00010000, 0, 0 );



}


/// @description  @description  Add vertex (x,y,z) to the model with colour values.
/// @param x
/// @param y
/// @param z
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param col The color to blend with vertex.
/// @param alpha The alpha value of the vertex.
function d3d_model_vertex_color(argument0, argument1, argument2, argument3, argument4, argument5) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument4 + ((argument5*255)<<24), 0, 0 );



}


/// @description  @description  Add vertex (x,y,z) to the model with colour values.
/// @param x
/// @param y
/// @param z
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param col The colour to blend with vertex.
/// @param alpha The alpha value of the vertex.
function d3d_model_vertex_colour(argument0, argument1, argument2, argument3, argument4, argument5) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument4 + ((argument5*255)<<24), 0, 0 );



}


/// @description  @description  Defines a vertex for a primitive in 3D along with its corresponding normal.
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xn The x component of the normal vector.
/// @param yn The y component of the normal vector.
/// @param zn The z component of the normal vector.
function d3d_model_vertex_normal(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, $00010000, 0, 0 );



}


/// @description  @description  Defines a primitive vertex for a model in 3D along with its corresponding normal, colour blending and alpha.
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xn The x component of the normal vector.
/// @param yn The y component of the normal vector.
/// @param zn The z component of the normal vector.
/// @param col The color to blend with the vertex (c_white or -1 is no blend).
/// @param alpha The alpha of the vertex (0 - 1).
function d3d_model_vertex_normal_color(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7 + ((argument8*255)<<24), 0, 0 );




}


/// @description  @description  Defines a primitive vertex for a model in 3D along with its corresponding normal, colour blending and alpha.
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xn The x component of the normal vector.
/// @param yn The y component of the normal vector.
/// @param zn The z component of the normal vector.
/// @param col The colour to blend with the vertex (c_white or -1 is no blend).
/// @param alpha The alpha of the vertex (0 - 1).
function d3d_model_vertex_normal_colour(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7 + ((argument8*255)<<24), 0, 0 );



}


/// @description  @description  Defines a primitive vertex for a textured model in 3D along with its corresponding normal.
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xn The x component of the normal vector.
/// @param yn The y component of the normal vector.
/// @param zn The z component of the normal vector.
/// @param xtex Starting x coordinate within the texture (0 - 1). 
/// @param ytex Starting y coordinate within the texture (0 - 1).
function d3d_model_vertex_normal_texture(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, $00010000, argument7, argument8 );



}


/// @description  @description  Defines a primitive vertex for a textured model in 3D along with its corresponding normal, color blending and alpha.
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xn The x component of the normal vector.
/// @param yn The y component of the normal vector.
/// @param zn The z component of the normal vector.
/// @param xtex Starting x coordinate within the texture (0 - 1). 
/// @param ytex Starting y coordinate within the texture (0 - 1).
/// @param col The color to blend with the vertex (c_white or -1 is no blend).
/// @param alpha The alpha of the vertex (0 - 1).
function d3d_model_vertex_normal_texture_color(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument9 + ((argument10*255)<<24), argument7, argument8  );



}


/// @description  @description  Defines a primitive vertex for a textured model in 3D along with its corresponding normal, colour blending and alpha.
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xn The x component of the normal vector.
/// @param yn The y component of the normal vector.
/// @param zn The z component of the normal vector.
/// @param xtex Starting x coordinate within the texture (0 - 1). 
/// @param ytex Starting y coordinate within the texture (0 - 1).
/// @param col The colour to blend with the vertex (c_white or -1 is no blend).
/// @param alpha The alpha of the vertex (0 - 1).
function d3d_model_vertex_normal_texture_colour(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument9 + ((argument10*255)<<24), argument7, argument8  );



}


/// @description  @description  Add vertex (x,y,z) to the model with texture values.
/// @param x
/// @param y
/// @param z
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xtex Starting x coordinate within the texture (0 - 1). 
/// @param ytex Starting y coordinate within the texture (0 - 1).
function d3d_model_vertex_texture(argument0, argument1, argument2, argument3, argument4, argument5) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, $00010000, argument4, argument5 );



}


/// @description  @description  Add vertex (x,y,z) to the model with texture and color values.
/// @param x
/// @param y
/// @param z
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xtex Starting x coordinate within the texture (0 - 1). 
/// @param ytex Starting y coordinate within the texture (0 - 1).
/// @param col The color to blend with the vertex (c_white or -1 is no blend).
/// @param alpha The alpha of the vertex (0 - 1).
function d3d_model_vertex_texture_color(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument6 + ((argument7*255)<<24), argument4, argument5 );



}


/// @description  @description  Add vertex (x,y,z) to the model with texture and colour values.
/// @param x
/// @param y
/// @param z
/// @param ind The index of the model to add the primitive to.
/// @param x The x coordinate of the vertex.
/// @param y The y coordinate of the vertex. 
/// @param z The z coordinate of the vertex.
/// @param xtex Starting x coordinate within the texture (0 - 1). 
/// @param ytex Starting y coordinate within the texture (0 - 1).
/// @param col The colour to blend with the vertex (c_white or -1 is no blend).
/// @param alpha The alpha of the vertex (0 - 1).
function d3d_model_vertex_texture_colour(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	__d3d_model_add_vertex( argument0, argument1, argument2, argument3, 0, 0, 0, argument6 + ((argument7*255)<<24), argument4, argument5 );



}


/// @description  @description Adds a wall shape to the model.
/// @param ind The model index to add the wall to.
/// @param x1 The initial x coordinate of the wall.
/// @param y1 The initial y coordinate of the wall.
/// @param z1 The initial z coordinate of the wall.
/// @param x2 The opposite x coordinate of the wall.
/// @param y2 The opposite y coordinate of the wall. 
/// @param z2 The opposite z coordinate of the wall.
/// @param hrepeat Amount of horizontal repetitions for the texture.
/// @param vrepeat Amount of vertical repetitions for the texture.
/// @returns 
function d3d_model_wall(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var __ind = argument0;
	var __x1 = argument1;
	var __y1 = argument2;
	var __z1 = argument3;
	var __x2 = argument4;
	var __y2 = argument5;
	var __z2 = argument6;
	var __hrepeat = argument7;
	var __vrepeat = argument8;

	var __xdiff = __x2 - __x1;
	var __ydiff = __y2 - __y1;

	var __lsquared = (__xdiff * __xdiff) + (__ydiff * __ydiff);
	if (__lsquared == 0)
		return 0;
	
	var __l = sqrt(__lsquared);

	var __nx = __ydiff / __l;
	var __ny = -__xdiff / __l;

	d3d_model_primitive_begin(__ind, pr_trianglefan);

	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z1, __nx, __ny, 0, 0, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z1, __nx, __ny, 0, __hrepeat, 0);
	d3d_model_vertex_normal_texture(__ind, __x2, __y2, __z2, __nx, __ny, 0, __hrepeat, __vrepeat);
	d3d_model_vertex_normal_texture(__ind, __x1, __y1, __z2, __nx, __ny, 0, 0, __vrepeat);

	d3d_model_primitive_end(__ind);



}


/// @description  @description  d3d - begin making a primitive stream
/// @param kind Primitive kind
function d3d_primitive_begin(argument0) {

	if (global.__d3dPrimKind != -1) {
		pprint( "ERROR : cannot begin a primitive before end called on previous")
	}

	global.__d3dPrimKind = argument0;
	global.__d3dPrimTex = -1;
	vertex_begin(global.__d3dPrimBuffer, global.__d3dPrimVF);



}


/// @description  @description  d3d - begin making a primitive stream
/// @param kind Primitive kind
/// @param tex Texture Index
function d3d_primitive_begin_texture(argument0, argument1) {

	if (global.__d3dPrimKind != -1) {
		pprint( "ERROR : cannot begin a primitive before end called on previous")
	}

	global.__d3dPrimKind = argument0;
	global.__d3dPrimTex = argument1;
	var __uvs = texture_get_uvs(global.__d3dPrimTex);
	global.__d3dPrimTexX = __uvs[0];
	global.__d3dPrimTexY = __uvs[1];
	global.__d3dPrimTexW = __uvs[2] - __uvs[0];
	global.__d3dPrimTexH = __uvs[3] - __uvs[1];
	vertex_begin( global.__d3dPrimBuffer, global.__d3dPrimVF );



}


/// @description  @description d3d - end the primitive stream
function d3d_primitive_end() {

	if (global.__d3dPrimKind != -1) {

		vertex_end( global.__d3dPrimBuffer );
		vertex_submit( global.__d3dPrimBuffer, global.__d3dPrimKind, global.__d3dPrimTex );

		// mark this as finished
		global.__d3dPrimKind = -1;
	} else {
		pprint( "d3d_primitive_end :: with no d3d_primitive_begin ");
	}



}


/// @description  @description  d3d - backface culling on or off
/// @param enable true if enabled, false if disabled
function d3d_set_culling(argument0) {

	//gpu_set_cullmode( argument0 ? cull_clockwise : cull_noculling );
	gpu_set_cullmode( argument0 ? cull_counterclockwise : cull_noculling );



}


/// @description  @description d3d - set depth
/// @param val value of depth
function d3d_set_depth(argument0) {
	global.__d3dDepth=argument0;



}


/// @description  @description  d3d - set fog enable/disable and colour
/// @param enable true if enabled, false if disabled
/// @param colour	colour of the fog
/// @param near	distance to when fog starts
/// @param far	distance to when fog becomes absolute
function d3d_set_fog(argument0, argument1, argument2, argument3) {

	gpu_set_fog(argument0, argument1, argument2, argument3 );



}


/// @description  @description d3d - set depth testing
/// @param enable true if enabled, false if disabled
function d3d_set_hidden(argument0) {

	gpu_set_ztestenable( argument0 );



}


/// @description  @description  d3d - set lighting
/// @param enable true if enabled, false if disabled
function d3d_set_lighting(argument0) {

	draw_set_lighting( argument0 );



}


/// @description  @description d3d - set perspective
/// @param enable true if enabled, false if disabled
function d3d_set_perspective(argument0) {

	//camera_apply(global.__d3dCamera);

	var __persp = argument0;
	if (global.__d3d == false)
		__persp = false;
	
	// Now find all cameras everywhere - the default camera, all the views in the current room and all the cameras in every other room
	// NOTE: this currently wont handle rooms that are created in code (using room_add())

	// The default camera is automatically updated by the runner so we just need to give it a hint of whether it is ortho or perspective
	var __mat = camera_get_proj_mat(camera_get_default());

	if (__persp)
	{
		__mat[11] = 1.0;
	}
	else
	{
		__mat[11] = 0.0;
	}

	camera_set_proj_mat(camera_get_default(), __mat);


	// Now loop through all the others
	var __numcams = 0;
	var __cams = [];
	var __i;
	for(__i = 0; __i < 8; __i++)
	{
		if (__view_get( e__VW.Camera, __i ) != -1)
		{
			__cams[__numcams*3] = __view_get( e__VW.Camera, __i );
			__cams[__numcams*3+1] = __view_get( e__VW.Camera, __i );
			__cams[__numcams*3+2] = __view_get( e__VW.Camera, __i );
			__numcams++;
		}
	}

	var __currroom = room_first;
	while(__currroom != -1)
	{
		for(__i = 0; __i < 8; __i++)
		{
			var __cam = room_get_camera(__currroom, __i);
			if (__cam != -1)
			{
				__cams[__numcams] = __cam;
				__numcams++;
			}
		}
	
		__currroom = room_next(__currroom);
	}

	// Now loop through all the cameras
	for(__i = 0; __i < __numcams; __i++)
	{
		var __cam = __cams[__i];
		var __mat = camera_get_proj_mat(__cam);
		var __ispersp = (__mat[11] != 0.0) ? true : false;
	
		if (__ispersp != __persp)
		{
			// Okay, Im going to assume that, if this is an imported project, all the cameras that have been set up are view-based
			// This means that they should have valid view parameters
			if (camera_get_view_width(__cam) > 0.0)
			{
				// okay, well assume this is a camera that has been previously set up with a view
				var __width = camera_get_view_width(__cam);
				var __height = camera_get_view_height(__cam);			
			
				if (__persp)
				{
					var __projmat = matrix_build_projection_perspective(1.0, -(__height/__width), 1.0, 32000.0);
					camera_set_proj_mat(__cam, __projmat);
				}
				else
				{
					var __projmat = matrix_build_projection_ortho(__width, __height, -16000.0, 16000.0);
					camera_set_proj_mat(__cam, __projmat);
				}
			}
		}
	}

	//camera_apply(camera_get_active());




}


/// @description  @description  @description d3d - set projection 
/// @param xFrom	x of from position
/// @param yFrom	y of from position
/// @param zFrom	z of from position
/// @param xTo		x of to position
/// @param yTo		y of to position
/// @param zTo		z of to position
/// @param xUp		x of up vector
/// @param yUp		y of up vector
/// @param zUp		z of up vector
function d3d_set_projection(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var m = matrix_build_lookat( argument0, argument1, argument2, 
								 argument3, argument4, argument5,
								 argument6, argument7, argument8 );
	//camera_set_view_mat( global.__d3dCamera, m );
	//camera_apply( global.__d3dCamera );
	camera_set_view_mat( camera_get_active(), m );
	camera_apply( camera_get_active() );



}


/// @description  @description d3d - set projection 
/// @param xFrom	x of from position
/// @param yFrom	y of from position
/// @param zFrom	z of from position
/// @param xTo		x of to position
/// @param yTo		y of to position
/// @param zTo		z of to position
/// @param xUp		x of up vector
/// @param yUp		y of up vector
/// @param zUp		z of up vector
/// @param fov		field of view angle
/// @param aspect	aspect ration
/// @param zmin		z buffer min
/// @param zmax		z buffer max
function d3d_set_projection_ext(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11, argument12) {

	var mV = matrix_build_lookat( argument0, argument1, argument2, 
								 argument3, argument4, argument5,
								 argument6, argument7, argument8 );
	var mP = matrix_build_projection_perspective_fov( -argument9, -argument10, argument11, argument12 );

	camera_set_view_mat( camera_get_active(), mV );
	camera_set_proj_mat( camera_get_active(), mP );
	camera_apply( camera_get_active() );



}


/// @description  @description d3d - set orthographic 
/// @param x		x of tl corner
/// @param y		y of tl corner
/// @param w		w of view
/// @param h		h of view
/// @param angle	rotation angle of the projection
function d3d_set_projection_ortho(argument0, argument1, argument2, argument3, argument4) {

	var xx = argument0;
	var yy = argument1;
	var ww = argument2;
	var hh = argument3;
	var angle = argument4;

	var mV = matrix_build_lookat( xx+ww/2, yy+hh/2, -16000, 
								  xx+ww/2, yy+hh/2, 0,
								 dsin(-angle), dcos(-angle), 0 );
	var mP = matrix_build_projection_ortho( ww, hh, 1, 32000 );

	//camera_set_view_mat( global.__d3dCamera, mV );
	//camera_set_proj_mat( global.__d3dCamera, mP );
	//camera_apply( global.__d3dCamera );
	camera_set_view_mat( camera_get_active(), mV );
	camera_set_proj_mat( camera_get_active(), mP );
	camera_apply( camera_get_active() );



}


/// @description  @description d3d - set projection perspective
/// @param x		x of tl corner
/// @param y		y of tl corner
/// @param w		w of view
/// @param h		h of view
/// @param angle	rotation angle of the projection
function d3d_set_projection_perspective(argument0, argument1, argument2, argument3, argument4) {
	var xx = argument0;
	var yy = argument1;
	var ww = argument2;
	var hh = argument3;
	var angle = argument4;

	var mV = matrix_build_lookat( xx+ww/2, yy+hh/2, -ww, 
								  xx+ww/2, yy+hh/2, 0,
								 dsin(-angle), dcos(-angle), 0 );
	var mP = matrix_build_projection_perspective( ww/ww, -hh/ww, 1, 32000 );

	camera_set_view_mat( camera_get_active(), mV );
	camera_set_proj_mat( camera_get_active(), mP );
	camera_apply( camera_get_active() );



}


/// @description  @description d3d - set shading
/// @param enable	true if enabled, false if disabled
function d3d_set_shading() {

	if (!global.__d3dDeprecatedMessage[0]) {
		pprint( "d3d_set_shading is deprecated as it needs to be done in the shader now" );
		global.__d3dDeprecatedMessage[0] = true;
	} 



}


/// @description  @description d3d - set z write enable
/// @param enable	true if enabled, false if disabled
function d3d_set_zwriteenable(argument0) {

	gpu_set_zwriteenable( argument0 );



}


/// @description  @description d3d - enable 3d
function d3d_start() {

	var ret = global.__d3d;
	global.__d3d = true;
	//camera_apply(global.__d3dCamera);
	gpu_set_ztestenable(true);
	gpu_set_zwriteenable(true);
	return ret;



}


/// @description  @description d3d - Sets the transformation to a rotation around the axis indicated by the vector with the indicated amount.
/// @param xa the x component of the transform vector
/// @param ya the y component of the transform vector
/// @param za the z component of the transform vector
/// @param angle the angle to rotate the transform through the vector
function d3d_transform_add_rotation_axis(argument0, argument1, argument2, argument3) {

	// get the sin and cos of the angle passed in
	var c = dcos(-argument3);
	var s = dsin(-argument3);
	var omc = 1 - c;

	// normalise the input vector
	var xx = argument0;
	var yy = argument1;
	var zz = argument2;
	var length2 = sqr(xx) + sqr(yy) + sqr(zz);
	var length = sqrt(length2);
	xx /= length;
	yy /= length;
	zz /= length;

	// build the rotation matrix
	var mT;
	mT[0] = omc * xx * xx + c;
	mT[1] = omc * xx * yy + s * zz;
	mT[2] = omc * xx * zz - s * yy;
	mT[3] = 0;

	mT[4] = omc * xx * yy - s * zz;
	mT[5] = omc * yy * yy + c;
	mT[6] = omc * yy * zz + s * xx;
	mT[7] = 0;

	mT[8] = omc * xx * zz + s * yy;
	mT[9] = omc * yy * zz - s * xx;
	mT[10] = omc * zz * zz + c;
	mT[11] = 0;

	mT[12] = 0;
	mT[13] = 0;
	mT[14] = 0;
	mT[15] = 1;

	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );



}


/// @description  @description d3d - Sets the transformation to a rotation around the x-axis with the indicated amount.
/// @param angle the angle to rotate
function d3d_transform_add_rotation_x(argument0) {

	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);

	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[5] = c;
	mT[6] = -s;

	mT[9] = s;
	mT[10] = c;

	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );



}


/// @description  @description d3d - Adds a rotation around the y-axis with the indicated amount.
/// @param angle the angle to rotate
function d3d_transform_add_rotation_y(argument0) {

	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);

	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[0] = c;
	mT[2] = s;

	mT[8] = -s;
	mT[10] = c;

	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );



}


/// @description  @description d3d - Adds a rotation around the z-axis with the indicated amount.
/// @param angle the angle to rorate the transform through the vector
function d3d_transform_add_rotation_z(argument0) {

	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);

	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[0] = c;
	mT[1] = -s;

	mT[4] = s;
	mT[5] = c;

	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );



}


/// @description  @description d3d - Sets the transformation to a scaling with the indicated amounts.
/// @param xs the x scale amount
/// @param ys the y scale amount
/// @param zs the z scale amount
function d3d_transform_add_scaling(argument0, argument1, argument2) {

	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[0] = argument0;
	mT[5] = argument1;
	mT[10] = argument2;
	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );




}


/// @description  @description d3d - Sets the transformation to a translation over the indicated vector.
/// @param xt x value
/// @param yt y value
/// @param zt z value
function d3d_transform_add_translation(argument0, argument1, argument2) {

	// build the rotation matrix
	var mT = matrix_build_identity();
	mT[12] = argument0;
	mT[13] = argument1;
	mT[14] = argument2;

	var m = matrix_get( matrix_world );
	var mR = matrix_multiply( m, mT );
	matrix_set( matrix_world, mR );



}


/// @description  @description d3d - set transform identiy matrix
function d3d_transform_set_identity() {

	var i = matrix_build_identity();
	matrix_set( matrix_world, i)



}


/// @description  @description d3d - Sets the transformation to a rotation around the axis indicated by the vector with the indicated amount.
/// @param xa the x component of the transform vector
/// @param ya the y component of the transform vector
/// @param za the z component of the transform vector
/// @param angle the angle to rotate the transform through the vector
function d3d_transform_set_rotation_axis(argument0, argument1, argument2, argument3) {

	// get the sin and cos of the angle passed in
	var c = dcos(-argument3);
	var s = dsin(-argument3);
	var omc = 1 - c;

	// normalise the input vector
	var xx = argument0;
	var yy = argument1;
	var zz = argument2;
	var length2 = sqr(xx) + sqr(yy) + sqr(zz);
	var length = sqrt(length2);
	xx /= length;
	yy /= length;
	zz /= length;

	// build the rotation matrix
	var m;
	m[0] = omc * xx * xx + c;
	m[1] = omc * xx * yy + s * zz;
	m[2] = omc * xx * zz - s * yy;
	m[3] = 0;

	m[4] = omc * xx * yy - s * zz;
	m[5] = omc * yy * yy + c;
	m[6] = omc * yy * zz + s * xx;
	m[7] = 0;

	m[8] = omc * xx * zz + s * yy;
	m[9] = omc * yy * zz - s * xx;
	m[10] = omc * zz * zz + c;
	m[11] = 0;

	m[12] = 0;
	m[13] = 0;
	m[14] = 0;
	m[15] = 1;

	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Sets the transformation to a rotation around the x-axis with the indicated amount.
/// @param angle the angle to rotate
function d3d_transform_set_rotation_x(argument0) {

	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);

	// build the rotation matrix
	var m = matrix_build_identity();
	m[5] = c;
	m[6] = -s;

	m[9] = s;
	m[10] = c;

	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Sets the transformation to a rotation around the y-axis with the indicated amount.
/// @param angle the angle to rotate
function d3d_transform_set_rotation_y(argument0) {

	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);

	// build the rotation matrix
	var m = matrix_build_identity();
	m[0] = c;
	m[2] = s;

	m[8] = -s;
	m[10] = c;

	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Sets the transformation to a rotation around the z-axis with the indicated amount.
/// @param angle the angle to rorate the transform through the vector
function d3d_transform_set_rotation_z(argument0) {

	// get the sin and cos of the angle passed in
	var c = dcos(argument0);
	var s = dsin(argument0);

	// build the rotation matrix
	var m = matrix_build_identity();
	m[0] = c;
	m[1] = -s;

	m[4] = s;
	m[5] = c;

	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Sets the transformation to a scaling with the indicated amounts.
/// @param xs the x scale amount
/// @param ys the y scale amount
/// @param zs the z scale amount
function d3d_transform_set_scaling(argument0, argument1, argument2) {

	// build the rotation matrix
	var m = matrix_build_identity();
	m[0] = argument0;
	m[5] = argument1;
	m[10] = argument2;
	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Sets the transformation to a translation over the indicated vector.
/// @param xt x value
/// @param yt y value
/// @param zt z value
function d3d_transform_set_translation(argument0, argument1, argument2) {

	// build the rotation matrix
	var m = matrix_build_identity();
	m[12] = argument0;
	m[13] = argument1;
	m[14] = argument2;
	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Clears the stack of transformations.
function d3d_transform_stack_clear() {
	matrix_stack_clear();



}


/// @description  @description d3d - Removes the top transformation from the stack.
function d3d_transform_stack_discard() {
	matrix_stack_pop();



}


/// @description  @description d3d - Returns whether the transformation stack is empty.
function d3d_transform_stack_empty() {
	return matrix_stack_is_empty();



}


/// @description  @description d3d - Pops the top transformation from the stack and makes it the current one.
function d3d_transform_stack_pop() {
	var m = matrix_stack_top();
	matrix_stack_pop();
	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Pushes the current transformation onto the stack.
function d3d_transform_stack_push() {
	var m = matrix_get( matrix_world );
	matrix_stack_push();
	matrix_stack_set( m );
	return true;



}


/// @description  @description d3d - Makes the top transformation the current one.
function d3d_transform_stack_top() {
	var m = matrix_stack_top();
	matrix_set( matrix_world, m);



}


/// @description  @description d3d - Sets the transformation to a scaling with the indicated amounts.
/// @param xs the x scale amount
/// @param ys the y scale amount
/// @param zs the z scale amount
function d3d_transform_vertex(argument0, argument1, argument2) {
	var m = matrix_get( matrix_world );
	return matrix_transform_vertex( m, argument0, argument1, argument2 );



}


/// @description  @description d3d - Sets the primitive vertex
/// @param x the x position
/// @param y the y position
/// @param z the z position
function d3d_vertex(argument0, argument1, argument2) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha());
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );






}


/// @description  @description d3d - Sets the primitive vertex and colour
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_color(argument0, argument1, argument2, argument3, argument4) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument3, argument4 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );






}


/// @description  @description d3d - Sets the primitive vertex and colour
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_colour(argument0, argument1, argument2, argument3, argument4) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument3, argument4 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );





}


/// @description  @description d3d - Sets the primitive vertex and normal
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param nx the normal x
/// @param ny the normal y
/// @param nz the normal z
function d3d_vertex_normal(argument0, argument1, argument2, argument3, argument4, argument5) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha() );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );





}


/// @description  @description d3d - Sets the primitive vertex and normal
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param nx the normal x
/// @param ny the normal y
/// @param nz the normal z
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_normal_color(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument6, argument7 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );





}


/// @description  @description d3d - Sets the primitive vertex and normal
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param nx the normal x
/// @param ny the normal y
/// @param nz the normal z
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_normal_colour(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument6, argument7 );
	vertex_texcoord( global.__d3dPrimBuffer, 0, 0 );





}


/// @description  @description d3d - Defines a vertex for a textured primitive in 3D along with its corresponding normal.
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param nx the normal x
/// @param ny the normal y
/// @param nz the normal z
/// @param u the normal u
/// @param v the normal v
function d3d_vertex_normal_texture(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha() );
	vertex_texcoord( global.__d3dPrimBuffer, (argument6 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument7 * global.__d3dPrimTexH) + global.__d3dPrimTexY );



}


/// @description  @description d3d - Sets the primitive vertex and normal
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param nx the normal x
/// @param ny the normal y
/// @param nz the normal z
/// @param u the normal u
/// @param v the normal v
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_normal_texture_color(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument8, argument9 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument6 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument7 * global.__d3dPrimTexH) + global.__d3dPrimTexY );





}


/// @description  @description d3d - Sets the primitive vertex and normal
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param nx the normal x
/// @param ny the normal y
/// @param nz the normal z
/// @param u the normal u
/// @param v the normal v
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_normal_texture_colour(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, argument3, argument4, argument5 );
	vertex_colour( global.__d3dPrimBuffer, argument8, argument9 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument6 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument7 * global.__d3dPrimTexH) + global.__d3dPrimTexY );





}


/// @description  @description d3d - Sets the primitive vertex
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param u the normal u
/// @param v the normal v
function d3d_vertex_texture(argument0, argument1, argument2, argument3, argument4) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, draw_get_colour(), draw_get_alpha() );
	vertex_texcoord( global.__d3dPrimBuffer, (argument3 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument4 * global.__d3dPrimTexH) + global.__d3dPrimTexY );





}


/// @description  @description d3d - Sets the primitive vertex
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param u the normal u
/// @param v the normal v
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_texture_color(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument5, argument6 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument3 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument4 * global.__d3dPrimTexH) + global.__d3dPrimTexY );





}


/// @description  @description d3d - Sets the primitive vertex
/// @param x the x position
/// @param y the y position
/// @param z the z position
/// @param u the normal u
/// @param v the normal v
/// @param col the colour
/// @param alpha the alpha
function d3d_vertex_texture_colour(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	vertex_position_3d( global.__d3dPrimBuffer, argument0, argument1, argument2 );
	vertex_normal( global.__d3dPrimBuffer, 0, 0, 0 );
	vertex_colour( global.__d3dPrimBuffer, argument5, argument6 );
	vertex_texcoord( global.__d3dPrimBuffer, (argument3 * global.__d3dPrimTexW) + global.__d3dPrimTexX, (argument4 * global.__d3dPrimTexH) + global.__d3dPrimTexY );





}


function __d3d_model_add_vertex(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9) {

	var m = argument0;
	var i = e__YYM.TriB;
	var uv_i = e__YYM.TriUVB;
	var colarrayi = e__YYM.TriCols;
	var colnum = e__YYM.NumTriCols;
	switch(m[e__YYM.PrimKind])
	{
	case pr_pointlist:
		i = e__YYM.PointB;
		uv_i = e__YYM.PointUVB;
		colarrayi = e__YYM.PointCols;
		colnum = e__YYM.NumPointCols;
		break;
	case pr_linelist:
	case pr_linestrip:
		i = e__YYM.LineB;
		uv_i = e__YYM.LineUVB;
		colarrayi = e__YYM.LineCols;
		colnum = e__YYM.NumLineCols;
		break;
	}

	var colarray = m[colarrayi];

	// create the buffer if we need to
	var b = m[i];
	if (b == undefined) {
		b = buffer_create( 36, buffer_grow, 1 );
		m[@i] = b;
	} // end if

	// create the uv buffer if we need to
	var uvb = m[uv_i];
	if (uvb == undefined)
	{
		uvb = buffer_create(8, buffer_grow, 1);
		m[@uv_i] = uvb;
	}

	var globalcol = false;
	if (argument7 == $00010000)
	{
		globalcol = true;
	}

	// add the vertex in
	var c = m[e__YYM.NumVerts];
	switch(m[e__YYM.PrimKind])
	{
	case pr_pointlist:
	case pr_linelist:
	case pr_trianglelist:
		buffer_write( b, buffer_f32, argument1 );		// x
		buffer_write( b, buffer_f32, argument2 );		// y
		buffer_write( b, buffer_f32, argument3 );		// z
		buffer_write( b, buffer_f32, argument4 );		// nx
		buffer_write( b, buffer_f32, argument5 );		// ny
		buffer_write( b, buffer_f32, argument6 );		// nz
		buffer_write( b, buffer_u32, argument7 );		// colour
		buffer_write( b, buffer_f32, argument8 );		// u
		buffer_write( b, buffer_f32, argument9 );		// v		
	
		buffer_write( uvb, buffer_f32, argument8 );
		buffer_write( uvb, buffer_f32, argument9 );
		++c;
	
		if (globalcol)
		{
			colarray[ m[colnum]] = buffer_tell(b) - 12;
			m[@ colnum]++;
		}
		break;
	case pr_linestrip:
		// add the previous if we are on vertex 1 or above
		if (c >= 2) {
			buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
			buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
			buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
			buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
			buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
			buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
			buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
			buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
			buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
		
			buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
			buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );	
			++c;
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}
		} // end if	
	
		m[@ e__YYM.V1X ] = argument1;
		m[@ e__YYM.V1Y ] = argument2;
		m[@ e__YYM.V1Z ] = argument3;
		m[@ e__YYM.V1NX ] = argument4;
		m[@ e__YYM.V1NY ] = argument5;
		m[@ e__YYM.V1NZ ] = argument6;
		m[@ e__YYM.V1C ] = argument7;
		m[@ e__YYM.V1U ] = argument8;
		m[@ e__YYM.V1V ] = argument9;
	
		buffer_write( b, buffer_f32, argument1 );		// x
		buffer_write( b, buffer_f32, argument2 );		// y
		buffer_write( b, buffer_f32, argument3 );		// z
		buffer_write( b, buffer_f32, argument4 );		// nx
		buffer_write( b, buffer_f32, argument5 );		// ny
		buffer_write( b, buffer_f32, argument6 );		// nz
		buffer_write( b, buffer_u32, argument7 );		// colour
		buffer_write( b, buffer_f32, argument8 );		// u
		buffer_write( b, buffer_f32, argument9 );		// v	
	
		buffer_write( uvb, buffer_f32, argument8 );
		buffer_write( uvb, buffer_f32, argument9 );
		++c;
	
		if (globalcol)
		{
			colarray[ m[colnum]] = buffer_tell(b) - 12;
			m[@ colnum]++;
		}	
		break;
	case pr_trianglestrip:
		// add the previous if we are on vertex 1 or above
		if (c >= 3) {
			buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
			buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
			buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
			buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
			buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
			buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
			buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
			buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
			buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
		
			buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
			buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );
			++c;
		
			buffer_write( b, buffer_f32, m[ e__YYM.V2X ] );		// x
			buffer_write( b, buffer_f32, m[ e__YYM.V2Y ] );		// y
			buffer_write( b, buffer_f32, m[ e__YYM.V2Z ] );		// z
			buffer_write( b, buffer_f32, m[ e__YYM.V2NX ] );	// nx
			buffer_write( b, buffer_f32, m[ e__YYM.V2NY ] );	// ny
			buffer_write( b, buffer_f32, m[ e__YYM.V2NZ ] );	// nz
			buffer_write( b, buffer_u32, m[ e__YYM.V2C ] );		// colour
			buffer_write( b, buffer_f32, m[ e__YYM.V2U ] );		// u
			buffer_write( b, buffer_f32, m[ e__YYM.V2V ] );		// v
		
			buffer_write( uvb, buffer_f32, m[ e__YYM.V2U ] );
			buffer_write( uvb, buffer_f32, m[ e__YYM.V2V ] );
			++c;
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - (12 + 36) ;
				m[@ colnum]++;
			
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}	
		} // end if	
	
		m[@ e__YYM.V1X ] = m[ e__YYM.V2X ];
		m[@ e__YYM.V1Y ] = m[ e__YYM.V2Y ];
		m[@ e__YYM.V1Z ] = m[ e__YYM.V2Z ];
		m[@ e__YYM.V1NX ] = m[ e__YYM.V2NX ];
		m[@ e__YYM.V1NY ] = m[ e__YYM.V2NY ];
		m[@ e__YYM.V1NZ ] = m[ e__YYM.V2NZ ];
		m[@ e__YYM.V1C ] = m[ e__YYM.V2C ];
		m[@ e__YYM.V1U ] = m[ e__YYM.V2U ];
		m[@ e__YYM.V1V ] = m[ e__YYM.V2V ];
	
		m[@ e__YYM.V2X ] = argument1;
		m[@ e__YYM.V2Y ] = argument2;
		m[@ e__YYM.V2Z ] = argument3;
		m[@ e__YYM.V2NX ] = argument4;
		m[@ e__YYM.V2NY ] = argument5;
		m[@ e__YYM.V2NZ ] = argument6;
		m[@ e__YYM.V2C ] = argument7;
		m[@ e__YYM.V2U ] = argument8;
		m[@ e__YYM.V2V ] = argument9;
	
		buffer_write( b, buffer_f32, argument1 );		// x
		buffer_write( b, buffer_f32, argument2 );		// y
		buffer_write( b, buffer_f32, argument3 );		// z
		buffer_write( b, buffer_f32, argument4 );		// nx
		buffer_write( b, buffer_f32, argument5 );		// ny
		buffer_write( b, buffer_f32, argument6 );		// nz
		buffer_write( b, buffer_u32, argument7 );		// colour
		buffer_write( b, buffer_f32, argument8 );		// u
		buffer_write( b, buffer_f32, argument9 );		// v
	
		buffer_write( uvb, buffer_f32, argument8 );
		buffer_write( uvb, buffer_f32, argument9 );
	
		if (globalcol)
		{
			colarray[ m[colnum]] = buffer_tell(b) - 12;
			m[@ colnum]++;
		}	
		++c;
		break;
	case pr_trianglefan:
		if (c==0) {
			m[@ e__YYM.V1X ] = argument1;
			m[@ e__YYM.V1Y ] = argument2;
			m[@ e__YYM.V1Z ] = argument3;
			m[@ e__YYM.V1NX ] = argument4;
			m[@ e__YYM.V1NY ] = argument5;
			m[@ e__YYM.V1NZ ] = argument6;
			m[@ e__YYM.V1C ] = argument7;
			m[@ e__YYM.V1U ] = argument8;
			m[@ e__YYM.V1V ] = argument9;
		} // end if
	
		if (c >= 3) {
			buffer_write( b, buffer_f32, m[ e__YYM.V1X ] );		// x
			buffer_write( b, buffer_f32, m[ e__YYM.V1Y ] );		// y
			buffer_write( b, buffer_f32, m[ e__YYM.V1Z ] );		// z
			buffer_write( b, buffer_f32, m[ e__YYM.V1NX ] );	// nx
			buffer_write( b, buffer_f32, m[ e__YYM.V1NY ] );	// ny
			buffer_write( b, buffer_f32, m[ e__YYM.V1NZ ] );	// nz
			buffer_write( b, buffer_u32, m[ e__YYM.V1C ] );		// colour
			buffer_write( b, buffer_f32, m[ e__YYM.V1U ] );		// u
			buffer_write( b, buffer_f32, m[ e__YYM.V1V ] );		// v
		
			buffer_write( uvb, buffer_f32, m[ e__YYM.V1U ] );
			buffer_write( uvb, buffer_f32, m[ e__YYM.V1V ] );
			++c;
		
			buffer_write( b, buffer_f32, m[ e__YYM.V2X ] );		// x
			buffer_write( b, buffer_f32, m[ e__YYM.V2Y ] );		// y
			buffer_write( b, buffer_f32, m[ e__YYM.V2Z ] );		// z
			buffer_write( b, buffer_f32, m[ e__YYM.V2NX ] );	// nx
			buffer_write( b, buffer_f32, m[ e__YYM.V2NY ] );	// ny
			buffer_write( b, buffer_f32, m[ e__YYM.V2NZ ] );	// nz
			buffer_write( b, buffer_u32, m[ e__YYM.V2C ] );		// colour
			buffer_write( b, buffer_f32, m[ e__YYM.V2U ] );		// u
			buffer_write( b, buffer_f32, m[ e__YYM.V2V ] );		// v
		
			buffer_write( uvb, buffer_f32, m[ e__YYM.V2U ] );
			buffer_write( uvb, buffer_f32, m[ e__YYM.V2V ] );
			++c;
		
			if (globalcol)
			{
				colarray[ m[colnum]] = buffer_tell(b) - (12 + 36) ;
				m[@ colnum]++;
			
				colarray[ m[colnum]] = buffer_tell(b) - 12;
				m[@ colnum]++;
			}	
		} // end if	
	
		m[@ e__YYM.V2X ] = argument1;
		m[@ e__YYM.V2Y ] = argument2;
		m[@ e__YYM.V2Z ] = argument3;
		m[@ e__YYM.V2NX ] = argument4;
		m[@ e__YYM.V2NY ] = argument5;
		m[@ e__YYM.V2NZ ] = argument6;
		m[@ e__YYM.V2C ] = argument7;
		m[@ e__YYM.V2U ] = argument8;
		m[@ e__YYM.V2V ] = argument9;
	
		buffer_write( b, buffer_f32, argument1 );		// x
		buffer_write( b, buffer_f32, argument2 );		// y
		buffer_write( b, buffer_f32, argument3 );		// z
		buffer_write( b, buffer_f32, argument4 );		// nx
		buffer_write( b, buffer_f32, argument5 );		// ny
		buffer_write( b, buffer_f32, argument6 );		// nz
		buffer_write( b, buffer_u32, argument7 );		// colour
		buffer_write( b, buffer_f32, argument8 );		// u
		buffer_write( b, buffer_f32, argument9 );		// v
	
		buffer_write( uvb, buffer_f32, argument8 );
		buffer_write( uvb, buffer_f32, argument9 );
		++c;
	
		if (globalcol)
		{
			colarray[ m[colnum]] = buffer_tell(b) - 12;
			m[@ colnum]++;
		}	
		break;
	} 
	m[@ e__YYM.NumVerts ] = c;
	m[@ colarrayi] = colarray;	// this is probably super-bad - may switch over to using buffers for the colour offset tables rather than arrays to avoid copies



}
#endregion

#region Joystick
/// @description  @description Returns the number of axes the joystick has.
/// @param id	the id of the joystick (1 or 2)
function joystick_axes(argument0) {
	var jid=__joystick_2_gamepad(argument0);
	return gamepad_axis_count(jid);



}


/// @description  @description Returns the number of buttons the joystick has.
/// @param id	the id of the joystick (1 or 2)
function joystick_buttons(argument0) {

	var jid=__joystick_2_gamepad(argument0);
	return gamepad_button_count(jid);



}


/// @description  @description Checks to see if a joystick button has been pressed.
/// @param id	the id of the joystick (1 or 2)
/// @param numb The number of the button to check (from 1 to 32).
/// @return {Boolean} true if selected button pressed / false otherwise
function joystick_check_button(argument0, argument1) {
	var jid=__joystick_2_gamepad(argument0);

	var button = 0;
	switch( argument1 )
	{
	case 0:	button = gp_face1; break;
	case 1:	button = gp_face2; break;
	case 2:	button = gp_face3; break;
	case 3:	button = gp_face4; break;
	case 4:	button = gp_shoulderl; break;
	case 5:	button = gp_shoulderlb; break;
	case 6:	button = gp_shoulderr; break;
	case 7:	button = gp_shoulderrb; break;
	case 8:	button = gp_select; break;
	case 9:	button = gp_start; break;
	case 10: button = gp_stickl; break;
	case 11: button = gp_stickr; break;
	default:
		button = argument1;
		break;
	}

	return (gamepad_button_value(jid, button) != 0);



}


/// @description  @description Checks to see if a joystick button has been pressed.
/// @param id	the id of the joystick (1 or 2)
/// @return  {Number} virtual key code for the numberpad buttons depending on direction being pressed by the joystick/gamepad with the given id
function joystick_direction(argument0) {
	var jid=__joystick_2_gamepad(argument0);

	var haxis = gamepad_axis_value( jid, gp_axislh );
	var vaxis = gamepad_axis_value( jid, gp_axislv );

	var ret = vk_numpad5;
	var dir = 0;
	if (vaxis < -0.3)
		dir = 6;
	else
	if (vaxis > 0.3)
		dir = 0;
	else
		dir = 3;

	if (haxis < -0.3)
		dir += 1;
	else
	if (haxis > 0.3)
		dir += 3;
	else 
		dir += 2;

	return vk_numpad0+dir;



}


/// @description  @description Checks for a joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return  {Boolean} true if a joystick/gamepad with the given id is connected or false if it is not
function joystick_exists(argument0) {

	var jid=__joystick_2_gamepad(argument0);
	return gamepad_is_connected(jid);



}


/// @description  @description Checks the point of view capabilities of the joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return  {Boolean} true if the joystick/gamepad with the given id has point of view capabilities or false if it does not
function joystick_has_pov() {

	return true;



}


/// @description  @description Returns the name of the joystick.
/// @param id	the id of the joystick (1 or 2)
function joystick_name(argument0) {

	var jid=__joystick_2_gamepad(argument0);
	return gamepad_get_description(jid);



}


/// @description  @description Returns the name of the joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the point-of view position of the joystick/gamepad with the given id. This is an angle between 0 and 360 degrees, where 0 is forwards, 90 to the right, 180 backwards and 270 to the left
function joystick_pov(argument0) {

	var jid=__joystick_2_gamepad(argument0);

	var mask = 0;
	mask |= (gamepad_button_value( jid, gp_padu) > 0) ? 1 : 0;
	mask |= (gamepad_button_value( jid, gp_padr) > 0) ? 2 : 0;
	mask |= (gamepad_button_value( jid, gp_padd) > 0) ? 4 : 0;
	mask |= (gamepad_button_value( jid, gp_padl) > 0) ? 8 : 0;

	return global.__jstick_povangle[mask];




}


/// @description  @description Process joystick events (since the Runner no longer processes them directly)
/// @param since the Runner no longer processes them directly
function joystick_process_events() {
	if (argument_count > 0) and (argument[0] > 0) return;

	// check to see if joystick 1 exists and process its events
	if (joystick_exists(1)) {

		var xaxis = joystick_xpos(1);
		if (xaxis < -0.3) event_perform(ev_mouse, ev_joystick1_left );
		if (xaxis >  0.3) event_perform(ev_mouse, ev_joystick1_right );
	
		var yaxis = joystick_ypos(1);
		if (yaxis < -0.3) event_perform(ev_mouse, ev_joystick1_up );
		if (yaxis >  0.3) event_perform(ev_mouse, ev_joystick1_down );

		if (joystick_check_button(1, 0)) event_perform(ev_mouse, ev_joystick1_button1 );
		if (joystick_check_button(1, 1)) event_perform(ev_mouse, ev_joystick1_button2 );
		if (joystick_check_button(1, 2)) event_perform(ev_mouse, ev_joystick1_button3 );
		if (joystick_check_button(1, 3)) event_perform(ev_mouse, ev_joystick1_button4 );
		if (joystick_check_button(1, 4)) event_perform(ev_mouse, ev_joystick1_button5 );
		if (joystick_check_button(1, 5)) event_perform(ev_mouse, ev_joystick1_button6 );
		if (joystick_check_button(1, 6)) event_perform(ev_mouse, ev_joystick1_button7 );
		if (joystick_check_button(1, 7)) event_perform(ev_mouse, ev_joystick1_button8 );
	}

	// check to see if joystick 1 exists and process its events
	if (joystick_exists(2)) {

		var xaxis = joystick_xpos(2);
		if (xaxis < -0.3) event_perform(ev_mouse, ev_joystick1_left );
		if (xaxis >  0.3) event_perform(ev_mouse, ev_joystick1_right );
	
		var yaxis = joystick_ypos(2);
		if (yaxis < -0.3) event_perform(ev_mouse, ev_joystick1_up );
		if (yaxis >  0.3) event_perform(ev_mouse, ev_joystick1_down );

		if (joystick_check_button(2, 0)) event_perform(ev_mouse, ev_joystick1_button1 );
		if (joystick_check_button(2, 1)) event_perform(ev_mouse, ev_joystick1_button2 );
		if (joystick_check_button(2, 2)) event_perform(ev_mouse, ev_joystick1_button3 );
		if (joystick_check_button(2, 3)) event_perform(ev_mouse, ev_joystick1_button4 );
		if (joystick_check_button(2, 4)) event_perform(ev_mouse, ev_joystick1_button5 );
		if (joystick_check_button(2, 5)) event_perform(ev_mouse, ev_joystick1_button6 );
		if (joystick_check_button(2, 6)) event_perform(ev_mouse, ev_joystick1_button7 );
		if (joystick_check_button(2, 7)) event_perform(ev_mouse, ev_joystick1_button8 );
	}



}


/// @description  @description Returns the position of the r-axis of joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the position of the r-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
function joystick_rpos(argument0) {

	var jid=__joystick_2_gamepad(argument0);

	return gamepad_axis_value( jid, 3);



}


/// @description  @description Returns the position of the u-axis of joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the position of the u-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
function joystick_upos(argument0) {

	var jid=__joystick_2_gamepad(argument0);

	return gamepad_axis_value( jid, 4);



}


/// @description  @description Returns the position of the v-axis of joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the position of the v-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
function joystick_vpos(argument0) {

	var jid=__joystick_2_gamepad(argument0);

	return gamepad_axis_value( jid, 5);



}


/// @description  @description Returns the position of the x-axis of joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the position of the x-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
function joystick_xpos(argument0) {

	var jid=__joystick_2_gamepad(argument0);

	return gamepad_axis_value( jid, 0);



}


/// @description  @description Returns the position of the yx-axis of joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the position of the y-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
function joystick_ypos(argument0) {


	var jid=__joystick_2_gamepad(argument0);

	return gamepad_axis_value( jid, 1);



}


/// @description  @description Returns the position of the z-axis of joystick.
/// @param id	the id of the joystick (1 or 2)
/// @return {Number} the position of the z-axis of the joystick/gamepad with the given id, with the value being somewhere between -1 and 1
function joystick_zpos(argument0) {

	var jid=__joystick_2_gamepad(argument0);

	return gamepad_axis_value( jid, 2);



}


function __joystick_2_gamepad(argument0) {
	if (argument0 == 2) 
		return global.__jstick_pad2;
	else
		return global.__jstick_pad1;



}
#endregion

#region Action
/// @description  @description (Old DnD) - move to another room
/// @param Old DnD
/// @param roomIndex room index to go to.
function action_another_room(argument0) {
	room_goto( argument0 );



}


/// @description  @description (Old DnD) - Allows bouncing of the calling instance
/// @param Old DnD
/// @param advanced Whether to enable advanced bouncing (true) or not (false)
/// @param useall true if bouncing off non-solid and solid
function action_bounce(argument0, argument1) {
	var __useall = argument1;
	if (!__useall) {
		move_bounce_solid(argument0);
	} else {
		move_bounce_all(argument0);
	}



}


/// @description  @description action_cd_pause - deprecated function
function action_cd_pause() {
	pprint( "action_cd_pause is a deprecated function" );
	return 0;



}


/// @description  @description action_cd_play - deprecated function
function action_cd_play() {
	pprint( "action_cd_play is a deprecated function" );
	return 0;



}


/// @description  @description action_cd_playing - deprecated function
function action_cd_playing() {
	pprint( "action_cd_playing is a deprecated function" );
	return 0;



}


/// @description  @description action_cd_present - deprecated function
function action_cd_present() {
	pprint( "action_cd_present is a deprecated function" );
	return 0;



}


/// @description  @description action_cd_resume - deprecated function
function action_cd_resume() {
	pprint( "action_cd_resume is a deprecated function" );
	return 0;



}


/// @description  @description action_cd_stop - deprecated function
function action_cd_stop() {
	pprint( "action_cd_stop is a deprecated function" );
	return 0;



}


/// @description  @description (Old DnD) - Changes the calling instance to an instance of a different object
/// @param Old DnD
/// @param objInd The new object the calling object will change into.
/// @param performEvents Whether to perform that new objects create and destroy events (true) or not (false).
function action_change_object(argument0, argument1) {
	instance_change( argument0, argument1 );



}


/// @description  @description (Old DnD) - Sets the base color for the draw functions
/// @param Old DnD
/// @param col The color to set for drawing.
function action_color(argument0) {
	draw_set_color( argument0 );



}


/// @description  @description (Old DnD) - Sets the base colour for the draw functions
/// @param Old DnD
/// @param col The colour to set for drawing.
function action_colour(argument0) {
	draw_set_color( argument0 );



}


/// @description  @description (Old DnD) - creates an instance of an object at a position
/// @param Old DnD
/// @param objInd object to create
/// @param xPos		X position to create at
/// @param yPos		Y position to create at
function action_create_object(argument0, argument1, argument2) {

	if (!object_exists(argument0)) {
		show_message( "creating instance for non-existent object" + string(id) );
		return 0;
	}

	if (global.__argument_relative)
	{
		instance_create( x+argument1, y+argument2, argument0);
	} else {
		instance_create( argument1, argument2, argument0);
	}



}


/// @description  @description (Old DnD) - creates an instance of an object at a position with specified motion
/// @param Old DnD
/// @param objInd object to create
/// @param xPos		X position to create at
/// @param yPos		Y position to create at
/// @param speed 	initial speed of instance
/// @param speed 	initial direction of instance
function action_create_object_motion(argument0, argument1, argument2, argument3, argument4) {
	if (!object_exists(argument0)) {
		show_message( "creating instance for non-existent object" + string(id) );
		return 0;
	}

	var i = -1;
	if (global.__argument_relative)
	{
		i = instance_create( x+argument1, y+argument2, argument0);
	} else {
		i = instance_create( argument1, argument2, argument0);
	}
	i.speed = argument3;
	i.direction = argument4;



}


/// @description  @description (Old DnD) - creates an instance of an object (from a choice of 4) at a position
/// @param Old DnD
/// @param objInd0 	possible object to create
/// @param objInd1 	possible object to create
/// @param objInd2 	possible object to create
/// @param objInd3 	possible object to create
/// @param xPos		X position to create at
/// @param yPos		Y position to create at
function action_create_object_random(argument0, argument1, argument2, argument3, argument4, argument5) {

	var ob = choose( argument0, argument1, argument2, argument3 );

	if (!object_exists(ob)) {
		return 0;
	} // end if

	if (global.__argument_relative)	{
		i = instance_create( x+argument4, y+argument5, ob);
	} else {
		i = instance_create( argument4, argument5, ob);
	} // end if




}


/// @description  @description (Old DnD) - restart the current room
/// @param Old DnD
function action_current_room() {
	room_restart();



}


/// @description  @description (Old DnD) - draw and arrow
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param size size of the arrow head
function action_draw_arrow() {

	if (global.__argument_relative) {
		draw_arrow( x+x1, y+y1, x+x2, y+y2, size );
	} else {
		draw_arrow( x1, y1, x2, y2, size );	
	} // end if



}


/// @description  @description (Old DnD) - draw background
/// @param Old DnD
/// @param index resource index
/// @param x	x position
/// @param y	y position
/// @param tiled	true if tiled
function action_draw_background(argument0, argument1, argument2, argument3) {

	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	// draw tiled if argument3 is true
	if (argument3) {
		draw_sprite_tiled( argument0, 0, xx, yy )
	} else {
		draw_sprite( argument0, 0, xx, yy );
	} // end if



}


/// @description  @description (Old DnD) - draw ellipse
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param outline	true if outline
function action_draw_ellipse(argument0, argument1, argument2, argument3, argument4) {

	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	draw_ellipse( xx1, yy1, xx2, yy2, argument4 );



}


/// @description  @description (Old DnD) - draw ellipse with gradient
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param c1   colour 1
/// @param c2   colour 2
function action_draw_ellipse_gradient(argument0, argument1, argument2, argument3, argument4, argument5) {

	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	draw_ellipse_ext( xx1, yy1, xx2, yy2, argument4, argument5, false );



}


/// @description  @description (Old DnD) - deprecated
/// @param Old DnD
function action_draw_font() {
	pprint( "action_draw_font deprecated");



}


/// @description  @description (Old DnD) - deprecated
/// @param Old DnD
function action_draw_font_old() {
	pprint( "action_draw_font_old deprecated");



}


/// @description  @description (Old DnD) - draw gradient horizontal
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param c1   colour 1
/// @param c2   colour 2
function action_draw_gradient_hor(argument0, argument1, argument2, argument3, argument4, argument5) {

	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	var c1 = argument4;
	var c2 = argument5;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	draw_rectangle_ext( xx1, yy1, xx2, yy2, c1, c2, c2, c1, false );



}


/// @description  @description (Old DnD) - draw gradient vertical
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param c1   colour 1
/// @param c2   colour 2
function action_draw_gradient_vert(argument0, argument1, argument2, argument3, argument4, argument5) {

	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	var c1 = argument4;
	var c2 = argument5;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	draw_rectangle_ext( xx1, yy1, xx2, yy2, c1, c1, c2, c2, false );



}


/// @description  @description (Old DnD) - draw health
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param c1   colour 1
/// @param c2   colour 2
function action_draw_health(argument0, argument1, argument2, argument3, argument4, argument5) {

	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	var c1Type = argument4;
	var c2Type= argument5;
	var showBack = argument4;
	var c1=0, c2=0, c3=0;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	switch( c1Type ) {
		case 0: c1=c_black; break;
		case 1: c1=c_black; break;
		case 2: c1=c_gray; break;
		case 3: c1=c_silver; break;
		case 4: c1=c_white; break;
		case 5: c1=c_maroon; break;
		case 6: c1=c_green; break;
		case 7: c1=c_olive; break;
		case 8: c1=c_navy; break;
		case 9: c1=c_purple; break;
		case 10: c1=c_teal; break;
		case 11: c1=c_red; break;
		case 12: c1=c_lime; break;
		case 13: c1=c_yellow; break;
		case 14: c1=c_blue; break;
		case 15: c1=c_fuchsia; break;
		case 16: c1=c_aqua; break;
	} // end switch

	switch( c2Type ) {
		case 0: { c2=c_red; c3=c_lime; } break;
		case 1: { c2=c_black; c3=c_white; } break;
		case 2: c2=c_black; break;
		case 3: c2=c_gray; break;
		case 4: c2=c_silver; break;
		case 5: c2=c_white; break;
		case 6: c2=c_maroon; break;
		case 7: c2=c_green; break;
		case 8: c2=c_olive; break;
		case 9: c2=c_navy; break;
		case 10: c2=c_purple; break;
		case 11: c2=c_teal; break;
		case 12: c2=c_red; break;
		case 13: c2=c_lime; break;
		case 14: c2=c_yellow; break;
		case 15: c2=c_blue; break;
		case 16: c2=c_fuchsia; break;
		case 17: c2=c_aqua; break;
	} // end switch

	if (c2Type>1) { c3=c2; }
	draw_healthbar( xx1, yy1, xx2, yy2, health, c1, c2, c3, 0, showBack, true );



}


/// @description  @description (Old DnD) - draw life
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
/// @param msg	message to disply before lives
function action_draw_life(argument0, argument1, argument2) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	draw_text( xx, yy, string_hash_to_newline(string_hash_to_newline(argument2)+string(lives)));




}


/// @description  @description (Old DnD) - draw life with images
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
/// @param index sprite index to use
function action_draw_life_images(argument0, argument1, argument2) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	var w = sprite_get_width( argument2 );
	for( var i=0; i<lives; ++i) {
		draw_sprite( argument2, 0, xx+(i*w), yy);
	} // end for




}


/// @description  @description (Old DnD) - draw line
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
function action_draw_line(argument0, argument1, argument2, argument3) {
	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	draw_line( xx1, yy1, xx2, yy2 );



}


/// @description  @description (Old DnD) - draw rectangle
/// @param Old DnD
/// @param x1	x position of start point
/// @param y1	y position of start point
/// @param x2	x position of end point
/// @param y2	y position of end point
/// @param outline	true if outline
function action_draw_rectangle(argument0, argument1, argument2, argument3, argument4) {

	var xx1 = argument0;
	var yy1 = argument1;
	var xx2 = argument2;
	var yy2 = argument3;
	if (global.__argument_relative) {
		xx1 += x;
		yy1 += y;
		xx2 += x;
		yy2 += y;
	}  // end if

	draw_rectangle( xx1, yy1, xx2, yy2, argument4 );



}


/// @description  @description (Old DnD) - draw score
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
/// @param msg	message to display before score
function action_draw_score(argument0, argument1, argument2) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	draw_text( xx, yy, string_hash_to_newline(string_hash_to_newline(argument2)+string(score)));




}


/// @description  @description (Old DnD) - draw sprite
/// @param Old DnD
/// @param index	sprite index
/// @param x	x position 
/// @param y	y position 
/// @param subimg	sub image number
function action_draw_sprite(argument0, argument1, argument2, argument3) {

	var index =argument0;
	var xx = argument1;
	var yy = argument2;
	var subimg = argument3;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	if (subimg<0) subimg=image_index;
	draw_sprite(index,subimg, xx, yy);




}


/// @description  @description (Old DnD) - draw text
/// @param Old DnD
/// @param msg	text to display
/// @param x	x position 
/// @param y	y position 
function action_draw_text(argument0, argument1, argument2) {

	var msg =argument0;
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	draw_text( xx, yy, string_hash_to_newline(string_hash_to_newline(msg)));



}


/// @description  @description (Old DnD) - draw text transformed
/// @param Old DnD
/// @param msg	text to display
/// @param x	x position 
/// @param y	y position 
/// @param xscale	x scale
/// @param yscale	y scale
/// @param angle	angle
function action_draw_text_transformed(argument0, argument1, argument2, argument3, argument4, argument5) {

	var msg = argument0;
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	draw_text_transformed( xx, yy, string_hash_to_newline(string_hash_to_newline(msg)), argument3, argument4, argument5 );



}


/// @description  @description (Old DnD) - draw variable
/// @param Old DnD
/// @param v    variable to display
/// @param x	x position 
/// @param y	y position 
function action_draw_variable(argument0, argument1, argument2) {

	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	draw_text( xx, yy, string_hash_to_newline(string_hash_to_newline(string(argument0))));



}


/// @description  @description (Old DnD) - create a particle effect
/// @param Old DnD
/// @param kind particle kind
/// @param x	x position 
/// @param y	y position 
/// @param size	size
/// @param col	colour
/// @param below true if below, false if above
function action_effect(argument0, argument1, argument2, argument3, argument4, argument5) {

	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if


	if (argument5) {
		effect_create_below( argument0, xx, yy, argument3, argument4 );
	} else {	
		effect_create_above( argument0, xx, yy, argument3, argument4 );
	} // end if



}


/// @description  @description (Old DnD) - end the game
/// @param Old DnD
function action_end_game() {
	game_end();



}


/// @description  @description (Old DnD) - end the sound
/// @param Old DnD
/// @param soundid sound id
function action_end_sound(argument0) {
	audio_stop_sound( argument0 );



}


/// @description  @description (Old DnD) - execute script
/// @param Old DnD
function action_execute_script() {
	script_execute( argument[0], argument[1], argument[2], argument[3], argument[4] );



}


/// @description  @description (Old DnD) - fill color
/// @param Old DnD
function action_fill_color() {
	pprint( "action_fill_color is deprecated");



}


/// @description  @description (Old DnD) - fill colour
/// @param Old DnD
function action_fill_colour() {
	pprint( "action_fill_colour is deprecated");



}


/// @description  @description (Old DnD) - set the font and horizontal alignment
/// @param Old DnD
/// @param fontid	font id
/// @param haligh   horizontal alignment
function action_font(argument0, argument1) {
	draw_set_font( argument0 );
	draw_set_halign( argument1 );



}


/// @description  @description (Old DnD) - fullscreen
/// @param Old DnD
/// @param type type of fullscreen (1 == not fullscreen, 2 == fullscreen, anything else change what you are )
function action_fullscreen(argument0) {
	switch( argument0 ) {
	case 1: 
		window_set_fullscreen( true ); 
		break;
	case 2: 
		window_set_fullscreen( false ); 
		break;
	default:
		window_set_fullscreen( window_get_fullscreen() ? false : true );
		break;
	} // end switch



}


/// @description  @description (Old DnD) - highscore (deprecated)
/// @param Old DnD
function action_highscore() {
	pprint( "action_highscore is deprecated");



}


/// @description  @description (Old DnD) - highscore clear
/// @param Old DnD
function action_highscore_clear() {
	highscore_clear();



}


/// @description  @description (Old DnD) - highscore show
/// @param Old DnD
function action_highscore_show() {
	var rw = room_width;
	var rh = room_height;
	var xx = rw/2 - 100;
	var yy = rh/2 - 100
	draw_highscore( xx, yy, xx+200, yy+200 );



}


/// @description  @description (Old DnD) - if evaluation
/// @param Old DnD
function action_if(argument0) {
	return argument0;



}


/// @description  @description (Old DnD) - if aligned evauation
/// @param Old DnD
/// @param xxG 	x alignment value
/// @param yyG 	y alignment value
function action_if_aligned(argument0, argument1) {
	var xxG = argument0;
	var yyG = argument1;
	var ret = false;
	if ((xxG>0) && ((x % xxG)!=0) && (yyG>0) && ((y % yyG)!=0)) {
		ret = true;
	} // end if
	return ret;



}


/// @description  @description (Old DnD) - if collision evauation
/// @param Old DnD
/// @param xxG 	x value
/// @param yyG 	y value
/// @param flag false for free, true for empty check
function action_if_collision(argument0, argument1, argument2) {
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	if (argument2) {
		return !place_empty( xx, yy);
	} else {
		return !place_free( xx, yy );
	} // end if



}


/// @description  @description (Old DnD) - if dice evauation
/// @param Old DnD
/// @param v number of sides of the dice
function action_if_dice(argument0) {
	var ret = true;
	var v = argument0;
	if (v > 1) {
		ret = random( 1000*v ) <= 1000;
	} // endif
	return ret;



}


/// @description  @description (Old DnD) - if empty evauation
/// @param Old DnD
/// @param xx	x value
/// @param yy 	y value
/// @param flag true for empty, false for free check
function action_if_empty(argument0, argument1, argument2) {
	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	if (argument2) {
		return place_empty( xx, yy );
	} else {
		return place_free( xx, yy);
	} // end if



}


/// @description  @description (Old DnD) - if health evauation
/// @param Old DnD
/// @param val  value to check against
/// @param type	type of check (1==<, 2==>, anything else is ==)
function action_if_health(argument0, argument1) {
	var ret = false;
	switch( argument1 )
	{
		case 1:	ret = (health < argument0); break;	
		case 2:	ret = (health > argument0); break;	
		default:ret = (health == argument0); break;	
	}
	return ret;



}


/// @description  @description (Old DnD) - if life evauation
/// @param Old DnD
function action_if_life(argument0, argument1) {
	// @param val  value to check against
	/// @param type	type of check (1==<, 2==>, anything else is ==)
	var ret = false;
	switch( argument1 )
	{
		case 1:	ret = (lives < argument0); break;	
		case 2:	ret = (lives > argument0); break;	
		default:ret = (lives == argument0); break;	
	}
	return ret;



}


/// @description  @description (Old DnD) - if mouse evauation
/// @param Old DnD
/// @param button	button to check
function action_if_mouse(argument0) {
	var ret = mouse_button_down(argument0) || mouse_button_released(argument0);
	switch( argument0 )
	{
		case 1:	
		case 2:	
		case 3:
			ret = mouse_button_down(argument0) || mouse_button_released(argument0);
			break;
		default:
			ret = (mouse_button == 0);
			break;	
	} // end switch
	return ret;



}


/// @description  @description (Old DnD) - if next room evauation
/// @param Old DnD
function action_if_next_room() {
	return (room != room_last);



}


/// @description  @description (Old DnD) - if number evauation
/// @param Old DnD
/// @param index  instance index to check against
/// @param value value to compare against
/// @param type	type of check (1==<, 2==>, anything else is ==)
function action_if_number(argument0, argument1, argument2) {
	var ret = false;
	var n = instance_number(argument0);
	switch( argument2 )
	{
		case 1:	ret = (n < argument1); break;	
		case 2:	ret = (n > argument1); break;	
		default:ret = (n == argument1); break;	
	}
	return ret;



}


/// @description  @description (Old DnD) - if object evauation
/// @param Old DnD
/// @param xx 	x value
/// @param yy 	y value
/// @param flag false for free, true for empty check
function action_if_object(argument0, argument1, argument2) {
	var xx = argument1;
	var yy = argument2;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if

	return place_meeting( xx, yy, argument0);



}


/// @description  @description (Old DnD) - if next room evauation
/// @param Old DnD
function action_if_previous_room() {
	return (room != room_first);



}


function action_if_question(argument0) {
	// insert code here 
	var ret = show_question( argument0 );
	io_clear();
	return ret;



}


/// @description  @description (Old DnD) - if score evauation
/// @param Old DnD
/// @param val  value to check against
/// @param type	type of check (1==<, 2==>, anything else is ==)
function action_if_score(argument0, argument1) {
	var ret = false;
	switch( argument1 )
	{
		case 1:	ret = (score < argument0); break;	
		case 2:	ret = (score > argument0); break;	
		default:ret = (score == argument0); break;	
	}
	return ret;



}


/// @description  @description (Old DnD) - if sound evauation
/// @param Old DnD
/// @param index sound index to check
function action_if_sound(argument0) {
	return audio_is_playing( argument0 );



}


/// @description  @description (Old DnD) - if variable evauation
/// @param Old DnD
/// @param val1  value to check against
/// @param val2  value2 to check against
/// @param type	type of check (1==<, 2==>, 3==<=, 4==>=anything else is ==)
function action_if_variable(argument0, argument1, argument2) {
	var ret = false;
	switch( argument2 )
	{
		case 1:	ret = (argument0 < argument1); break;	
		case 2:	ret = (argument0 > argument1); break;	
		case 3:	ret = (argument0 <= argument1); break;	
		case 4:	ret = (argument0 >= argument1); break;	
		default:ret = (argument0 == argument1); break;	
	}
	return ret;



}


/// @description  @description (Old DnD) - perform the inherited event
/// @param Old DnD
function action_inherited() {
	event_inherited();




}


/// @description  @description (Old DnD) - destroy the self object
/// @param Old DnD
function action_kill_object() {
	instance_destroy();



}


/// @description  @description (Old DnD) - destroy instances at position
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
function action_kill_position(argument0, argument1) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	position_destroy( xx, yy );



}


/// @description  @description (Old DnD) - linear step
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
/// @param speed	speed
/// @param checkall	true if checking all
function action_linear_step(argument0, argument1, argument2, argument3) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	mp_linear_step( xx, yy, argument2, argument3 );



}


/// @description  @description (Old DnD) - line color
/// @param Old DnD
function action_line_color() {
	pprint( "action_line_color is deprecated");



}


/// @description  @description (Old DnD) - line colour
/// @param Old DnD
function action_line_colour() {
	pprint( "action_line_colour is deprecated");



}


/// @description  @description (Old DnD) - load a game
/// @param Old DnD
/// @param filename filename
function action_load_game(argument0) {
	game_load( argument0 );



}


/// @description  @description (Old DnD) - show a message in a dialog box
/// @param Old DnD
/// @param msg message
function action_message(argument0) {
	show_message( argument0 );
	io_clear();



}


/// @description  @description (Old DnD) - move the current instance in a direction
/// @param Old DnD
/// @param dir string of 0s and 1s that indicates a valid direction
/// @param speed speed to move
function action_move(argument0, argument1) {
	if (argument0 == "000000000") return;

	var spd = argument1;
	if (global.__argument_relative) {
		spd += speed;
	}  // end if

	speed = spd;

	// find a valid direction
	var d = irandom(9);
	while( string_char_at(argument0, d+1) != "1" ) {
		d = irandom(9);
	} // end while

	switch(d)
	{
		case 0: direction = 225; break;
		case 1: direction = 270; break;
		case 2: direction = 315; break;
		case 3: direction = 180; break;
		case 4: direction = 0; speed = 0; break;
		case 5: direction = 0; break;
		case 6: direction = 135; break;
		case 7: direction = 90; break;
		case 8: direction = 45; break;
	}



}


/// @description  @description (Old DnD) - move the current instance until contact
/// @param Old DnD
/// @param dir direction
/// @param maxdist maximum distance
/// @param useall true if using all
function action_move_contact(argument0, argument1, argument2) {
	if (argument2) {
		move_contact_all( argument0, argument1 );
	} else {
		move_contact_solid( argument0, argument1 );
	}




}


/// @description  @description (Old DnD) - move towards point
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
/// @param speed	speed
function action_move_point(argument0, argument1, argument2) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	move_towards_point( xx, yy, argument2);



}


/// @description  @description (Old DnD) - move random
/// @param Old DnD
/// @param x	x grid
/// @param y	y grid
function action_move_random(argument0, argument1) {

	var xmin=0, xmax=room_width;
	var ymin=0, ymax=room_height;
	if (sprite_exists(sprite_index) || sprite_exists(mask_index)) {
		xmin = round(x - bbox_left);
		xmax = round(xmax + x - bbox_right);
		ymin = round(y - bbox_top);
		ymax = round(ymax + y - bbox_bottom);
	}

	var sx = argument0;
	var sy = argument1;
	for( var i=0; i<100; ++i) {
		var xx = xmin + irandom( xmax-xmin );
		if (sx > 0) xx = sx * floor(xx/sx);
		var yy = ymin + irandom( ymax - ymin );
		if (sy > 0) yy = sy * floor(yy/sy);
		if (place_free( xx, yy)) {
			x = xx;
			y = yy;
			return;
		} // end if
	} // end for



}


/// @description  @description (Old DnD) - move start
/// @param Old DnD
function action_move_start() {
	x = xstart;
	y = ystart;




}


/// @description  @description (Old DnD) - move to
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
function action_move_to(argument0, argument1) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	x = xx;
	y = yy;



}


/// @description  @description (Old DnD) - next room
/// @param Old DnD
function action_next_room() {
	room_goto_next();



}


/// @description  @description (Old DnD) - particle system emitter burst
/// @param Old DnD
/// @param index emitter index
/// @param ptype particle type
/// @param num number
function action_partemit_burst(argument0, argument1, argument2) {

	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		show_message( "The particle emitter must first be created" );
		return;
	} // end if
	var ptype = argument1;
	var num = argument2;
	part_emitter_burst(global.__part_syst,  global.__part_emit[index], ptype, num )



}


/// @description  @description (Old DnD) - particle system emitter create in a region
/// @param Old DnD
/// @param index emitter index
/// @param shape shape to use
/// @param xMin	x min
/// @param xMax	x max
/// @param yMin	y min
/// @param yMax	y max
function action_partemit_create(argument0, argument1, argument2, argument3, argument4, argument5) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		global.__part_emit[index] = part_emitter_create(global.__part_syst);
	} // end if
	part_emitter_region( global.__part_syst, global.__part_emit[index], argument2, argument3, argument4, argument5, argument1, 0);



}


/// @description  @description (Old DnD) - particle system emitter destroy
/// @param Old DnD
/// @param index emitter index
function action_partemit_destroy(argument0) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		return;
	} // end if
	part_emitter_destroy( global.__part_syst, global.__part_emit[index]);



}


/// @description  @description (Old DnD) - particle system emitter stream
/// @param Old DnD
/// @param index emitter index
/// @param ptype particle type
/// @param num number
function action_partemit_stream(argument0, argument1, argument2) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_emit[index] < 0) {
		show_message( "The particle emitter must first be created" );
		return;
	} // end if
	var ptype = argument1;
	var num = argument2;
	part_emitter_stream(global.__part_syst,  global.__part_emit[index], ptype, num )



}


/// @description  @description (Old DnD) - particle system clear
/// @param Old DnD
function action_partsyst_clear() {
	if (global.__part_syst >= 0) { 
		part_system_clear( global.__part_syst ); 
	}



}


/// @description  @description (Old DnD) - particle system create
/// @param Old DnD
/// @param depth 
function action_partsyst_create(argument0) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	part_system_clear(global.__part_syst);
	part_system_depth(global.__part_syst, argument0);
	for( var i=0; i<=15; ++i) {
		global.__part_type[i] = -1;
		global.__part_emit[i] = -1;
	} // end for



}


/// @description  @description (Old DnD) - particle system destroy
/// @param Old DnD
function action_partsyst_destroy() {
	if (global.__part_syst >= 0) { 
		part_system_destroy(global.__part_syst);
	}
	global.__part_syst = -1;



}


/// @description  @description (Old DnD) - particle type set color
/// @param Old DnD
/// @param index type index
/// @param type particle type
/// @param col1 colour 1
/// @param col2 colour 2
/// @param alpha1 alpha 1
/// @param alpha2 alpha 2
function action_parttype_color(argument0, argument1, argument2, argument3, argument4, argument5) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	if (argument1 == 0) {
		part_type_color_mix(global.__part_type[index], argument2, argument3);
	} else {
		part_type_color2(global.__part_type[index], argument2, argument3);
	}
	part_type_alpha2(global.__part_type[index], argument4, argument5 );



}


/// @description  @description (Old DnD) - particle type set colour
/// @param Old DnD
/// @param index type index
/// @param type particle type
/// @param col1 colour 1
/// @param col2 colour 2
/// @param alpha1 alpha 1
/// @param alpha2 alpha 2
function action_parttype_colour(argument0, argument1, argument2, argument3, argument4, argument5) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	if (argument1 == 0) {
		part_type_colour_mix(global.__part_type[index], argument2, argument3);
	} else {
		part_type_colour2(global.__part_type[index], argument2, argument3);
	}
	part_type_alpha2(global.__part_type[index], argument4, argument5 );



}


/// @description  @description (Old DnD) - particle type create
/// @param Old DnD
/// @param index type index
/// @param shape
/// @param sprite sprite index
/// @param sizeMin minimum size
/// @param sizeMax maximum size
/// @param sizeIncr size increments
function action_parttype_create(argument0, argument1, argument2, argument3, argument4, argument5) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_shape(global.__part_type[index], argument1 );
	part_type_sprite(global.__part_type[index], argument2, true, false, false );
	part_type_size(global.__part_type[index], argument3, argument4, argument5, 0 );



}


/// @description  @description (Old DnD) - particle type create (older version)
/// @param Old DnD
/// @param index type index
/// @param shape
/// @param sizeMin minimum size
/// @param sizeMax maximum size
/// @param colStart colour at start
/// @param colEnd colour at end
function action_parttype_create_old(argument0, argument1, argument2, argument3, argument4, argument5) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_shape(global.__part_type[index], argument1 );
	part_type_size(global.__part_type[index], argument2, argument3, 0, 0 );
	part_type_colour2(global.__part_type[index], argument4, argument5 );



}


/// @description  @description (Old DnD) - particle type gravity
/// @param Old DnD
/// @param index type index
/// @param gravity magnitude of gravity
/// @param direction direction of gravity
function action_parttype_gravity(argument0, argument1, argument2) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_gravity(global.__part_type[index], argument1, argument2 );



}


/// @description  @description (Old DnD) - particle type life
/// @param Old DnD
/// @param index type index
/// @param lifeMin minimum lifetime
/// @param lifeMax maximum lifetime
function action_parttype_life(argument0, argument1, argument2) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_life(global.__part_type[index], argument1, argument2 );



}


/// @description  @description (Old DnD) - particle type secondary
/// @param Old DnD
/// @param index type index
/// @param stepType
/// @param stepNumber 
/// @param deathType
/// @param deathNumber
function action_parttype_secondary(argument0, argument1, argument2, argument3, argument4) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_step(global.__part_type[index], argument2, global.__part_type[argument1] );
	part_type_death(global.__part_type[index], argument4, global.__part_type[argument3] );



}


/// @description  @description (Old DnD) - particle type speed
/// @param Old DnD
/// @param index type index
/// @param speedMin
/// @param speedMax
/// @param dirMin
/// @param dirMax
/// @param stepInc
function action_parttype_speed(argument0, argument1, argument2, argument3, argument4, argument5) {
	if (global.__part_syst < 0) { global.__part_syst = part_system_create(); }
	var index = argument0;
	if (global.__part_type[index] < 0) {
		global.__part_type[index] = part_type_create();
	} // end if
	part_type_speed(global.__part_type[index], argument1, argument2, -argument5, 0 );
	part_type_direction(global.__part_type[index], argument3, argument4, 0, 0 );



}


/// @description  @description (Old DnD) - path start
/// @param Old DnD
/// @param index path index
/// @param speed
/// @param endAct
/// @param relative
function action_path(argument0, argument1, argument2, argument3) {
	path_start( argument0, argument1, argument2, argument3 );



}


/// @description  @description (Old DnD) - path end
/// @param Old DnD
function action_path_end() {
	path_end();



}


/// @description  @description (Old DnD) - path old
/// @param Old DnD
function action_path_old() {
	pprint( "action_path_old is deprecated");



}


/// @description  @description (Old DnD) - set path position
/// @param Old DnD
/// @param position new position
function action_path_position(argument0) {
	var pos = argument0;
	if (global.__argument_relative) {
		pos += path_position;
	}  // end if
	path_position = pos;



}


/// @description  @description (Old DnD) - set path speed
/// @param Old DnD
/// @param speed new speed
function action_path_speed(argument0) {
	var spd = argument0;
	if (global.__argument_relative) {
		spd += path_speed;
	}  // end if
	path_speed = spd;



}


/// @description  @description (Old DnD) - potential step
/// @param Old DnD
/// @param x	x position 
/// @param y	y position 
/// @param speed	speed
/// @param checkall	true if checking all
function action_potential_step(argument0, argument1, argument2, argument3) {

	var xx = argument0;
	var yy = argument1;
	if (global.__argument_relative) {
		xx += x;
		yy += y;
	}  // end if
	mp_potential_step( xx, yy, argument2, argument3 );



}


/// @description  @description (Old DnD) - previous room
/// @param Old DnD
function action_previous_room() {
	room_goto_previous();



}


/// @description (Old DnD) - replace background
/// @param index sprite index
/// @param filename filename to replace
function action_replace_background(argument0, argument1) {
	sprite_replace( argument0, argument1, 0, false, false, 0, 0 );



}


/// @description  @description (Old DnD) - replace sound (deprecated)
/// @param Old DnD
/// @param index sound index
/// @param filename filename to replace
function action_replace_sound() {
	pprint( "action_replace_sound is deprecated")



}


/// @description (Old DnD) - replace sprite
/// @param index sprite index
/// @param filename filename to replace
function action_replace_sprite(argument0, argument1) {
	sprite_replace( argument0, argument1, 0, false, false, 0, 0 );



}


/// @description  @description (Old DnD) - restart game
/// @param Old DnD
function action_restart_game() {
	game_restart();



}


/// @description  @description (Old DnD) - reverse x direction
/// @param Old DnD
function action_reverse_xdir() {
	hspeed = -hspeed;



}


/// @description  @description (Old DnD) - reverse y direction
/// @param Old DnD
function action_reverse_ydir() {
	vspeed = -vspeed;



}


/// @description  @description (Old DnD) - save game
/// @param Old DnD
/// @param filename filename to save to
function action_save_game(argument0) {
	game_save( argument0 );



}


/// @description  @description (Old DnD) - set alarm
/// @param Old DnD
/// @param index alarm index
/// @param val value to set to
function action_set_alarm(argument0, argument1) {
	alarm_set( argument1, argument0 );



}


/// @description  @description (Old DnD) - set caption
/// @param Old DnD
/// @param enableScoreCaption	true if score caption enabled
/// @param ScoreCaption	message of score caption
/// @param enableLivesCaption	true if lives caption enabled
/// @param LivesCaption	message of lives caption
/// @param enableHealthCaption	true if health caption enabled
/// @param HealthCaption	message of health caption
function action_set_caption(argument0, argument1, argument2, argument3, argument4, argument5) {
	show_score = argument0;
	caption_score = argument1;
	show_lives = argument2;
	caption_lives = argument3;
	show_health = argument4;
	caption_health = argument5;



}


/// @description  @description (Old DnD) - set cursor
/// @param Old DnD
/// @param sprIndex sprite index to use for cursor
/// @param showCursor true if cursor to be showin
function action_set_cursor(argument0, argument1) {
	cursor_sprite = argument0;
	if (argument1) {
		window_set_cursor( 0 );
	} else {
		window_set_cursor( -1 );
	} // end if



}


/// @description  @description (Old DnD) - set friction
/// @param Old DnD
/// @param val value to set friction
function action_set_friction(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += friction;
	}  // end if
	friction = val;



}


/// @description  @description (Old DnD) - set gravity
/// @param Old DnD
/// @param dir direction for gravity
/// @param val value to set gravity
function action_set_gravity(argument0, argument1) {
	var dir = argument0;
	var val = argument1;
	if (global.__argument_relative) {
		dir += gravity_direction;
		val += gravity;
	}  // end if
	gravity = val;
	gravity_direction = dir;



}


/// @description  @description (Old DnD) - set health
/// @param Old DnD
/// @param val value to set health
function action_set_health(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += health;
	}  // end if
	health = val;



}


/// @description  @description (Old DnD) - set hspeed
/// @param Old DnD
/// @param val value to set hspeed
function action_set_hspeed(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += hspeed;
	}  // end if
	hspeed = val;



}


/// @description  @description (Old DnD) - set lives
/// @param Old DnD
/// @param val value to set lives
function action_set_life(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += lives;
	}  // end if
	lives = val;



}


/// @description  @description (Old DnD) - set motion
/// @param Old DnD
/// @param dir direction
/// @param spd speed
function action_set_motion(argument0, argument1) {
	var dir = argument0;
	var spd = argument1;
	if (global.__argument_relative) {
		dir += direction;
		spd += speed;
	}  // end if
	direction = dir;
	speed = spd;



}


/// @description  @description (Old DnD) - set argument relative
/// @param Old DnD
/// @param val value to set argument relative variable
function action_set_relative(argument0) {
	global.__argument_relative = argument0;




}


/// @description  @description (Old DnD) - set score
/// @param Old DnD
/// @param val value to set score
function action_set_score(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += score;
	}  // end if
	score = val;



}


/// @description  @description (Old DnD) - set sprite
/// @param Old DnD
/// @param index sprite index
/// @param scale scale
function action_set_sprite(argument0, argument1) {
	image_index = argument0;
	if (argument1 > 0) {
		image_xscale = argument1;	
		image_yscale = argument1;	
	} // end if



}


/// @description  @description (Old DnD) - set timeline
/// @param Old DnD
/// @param index sprite index
/// @param pos  timeline position
function action_set_timeline(argument0, argument1) {
	timeline_index = argument0;
	timeline_position = argument1;
	timeline_running = true;



}


/// @description  @description (Old DnD) - set timeline position
/// @param Old DnD
/// @param pos  timeline position
function action_set_timeline_position(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += timeline_position;
	}  // end if
	timeline_position = val;



}


/// @description  @description (Old DnD) - set timeline speed
/// @param Old DnD
/// @param val timeline speed
function action_set_timeline_speed(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += timeline_speed;
	}  // end if
	timeline_speed = val;



}


/// @description  @description (Old DnD) - set vspeed
/// @param Old DnD
/// @param val value to set vspeed
function action_set_vspeed(argument0) {
	var val = argument0;
	if (global.__argument_relative) {
		val += vspeed;
	}  // end if
	vspeed = val;



}


/// @description  @description (Old DnD) - show info (deprecated)
/// @param Old DnD
function action_show_info() {
	io_clear();



}


/// @description  @description (Old DnD) - show video (deprecated)
/// @param Old DnD
function action_show_video() {
	io_clear();



}


/// @description  @description (Old DnD) - sleep (deprecated)
/// @param Old DnD
function action_sleep(argument0) {
	sleep( argument0 );



}


/// @description  @description (Old DnD) - move snap
/// @param Old DnD
/// @param hsnap horizontal snap value
/// @param vsnap vertical snap value
function action_snap(argument0, argument1) {
	move_snap( argument0, argument1 );



}


/// @description  @description (Old DnD) - snapshot
/// @param Old DnD
/// @param filename filename for save file
function action_snapshot(argument0) {
	surface_save( application_surface, argument0 );



}


/// @description  @description (Old DnD) - play sound
/// @param Old DnD
/// @param index sound index
/// @param loop true if playing a loop
function action_sound(argument0, argument1) {
	audio_play_sound( argument0, 1, argument1 );



}


/// @description  @description (Old DnD) - action splash web (deprecated)
/// @param Old DnD
function action_splash_web() {
	pprint( "action_splash_web is deprecated");



}


/// @description  @description (Old DnD) - set sprite color (and alpha)
/// @param Old DnD
/// @param color color
/// @param alpha alpha
function action_sprite_color(argument0, argument1) {
	image_blend = argument0;
	image_alpha = argument1;




}


/// @description  @description (Old DnD) - set sprite colour (and alpha)
/// @param Old DnD
/// @param colour colour
/// @param alpha alpha
function action_sprite_colour(argument0, argument1) {
	image_blend = argument0;
	image_alpha = argument1;



}


/// @description  @description (Old DnD) - set sprite set
/// @param Old DnD
/// @param index sprite index
/// @param image image number
/// @param speed image speed
function action_sprite_set(argument0, argument1, argument2) {
	sprite_index = argument0;
	if (argument1 >= 0) image_index = argument1;
	image_speed = argument2;



}


/// @description  @description (Old DnD) - set sprite transform
/// @param Old DnD
/// @param scaleX x scale of sprite
/// @param scaleY y scale of sprite
/// @param angle angle of sprite
/// @param third ???? quadrant ????
function action_sprite_transform(argument0, argument1, argument2, argument3) {
	image_xscale = argument0;
	image_yscale = argument1;
	image_angle = argument2;
	if ((argument3 == 1) || (argument3 == 3)) image_xscale=-image_xscale;
	if ((argument3 == 2) || (argument3 == 3)) image_yscale=-image_yscale;



}


/// @description  @description (Old DnD) - set timeline pause
/// @param Old DnD
function action_timeline_pause() {
	timeline_running = false;



}


/// @description  @description (Old DnD) - set timeline
/// @param Old DnD
/// @param index timeline index
/// @param pos timeline position
/// @param running timeline running (0/false = yes)
/// @param loop timeline looping (true = yes)
function action_timeline_set(argument0, argument1, argument2, argument3) {
	timeline_index = argument0;
	timeline_position = argument1;
	timeline_running = !argument2;
	timeline_loop = argument3;



}


/// @description  @description (Old DnD) - set timeline start
/// @param Old DnD
function action_timeline_start() {
	timeline_running = true;



}


/// @description  @description (Old DnD) - set timeline stop
/// @param Old DnD
function action_timeline_stop() {
	timeline_position = 0;
	timeline_running = false;



}


/// @description  @description (Old DnD) - show webpage
/// @param Old DnD
/// @param cmd page to show
function action_webpage(argument0) {
	execute_shell( argument0, "" );



}


/// @description  @description (Old DnD) - motion wrap
/// @param Old DnD
/// @param index  (0 || 2 ) horizontal wrap (1 || 2 ) vertical wrap
function action_wrap(argument0) {

	var w = sprite_width;
	var h = sprite_height;

	if ((argument0 == 0) || (argument0 == 2)) {

		if (hspeed < 0) && (x < 0)
			x += room_width + w;
		if (hspeed > 0) && (x >= room_width)
			x -= room_width + w;
	} // end if

	if ((argument0 == 1) || (argument0 == 2)) {

		if (vspeed < 0) && (y < 0)
			y += room_height + h;
		if (vspeed > 0) && (y >= room_height)
			y -= room_height + h;
	} // end if



}
#endregion

#region Draw
/// @description  @description Draw a background without colour blending or transparency
/// @param back The index of the background to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @returns 
function draw_background(argument0, argument1, argument2) {

	draw_sprite(argument0, 0, argument1, argument2);



}


/// @description  @description Draws a background at a given position, with customizable scaling, rotation, blend and alpha.
/// @param back The index of the background to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @param xscale The horizontal scaling of the background.
/// @param yscale The vertical scaling of the background.
/// @param rot The rotation of the background.
/// @param colour The colour with which to blend the background (use -1 or c_white to display it normally).
/// @param alpha  The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque). 
/// @returns 
function draw_background_ext(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	draw_sprite_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6, argument7);



}


/// @description  @description Draws part of a background at a given position with scaling, rotating, four-corner blending and alpha options.
/// @param back The index of the background to draw.
/// @param left The x position on the background of the top left corner of the area to draw.
/// @param top  The y position on the background of the top left corner of the area to draw.
/// @param width  The width of the area to draw.
/// @param height  The height of the area to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @param xscale The horizontal scaling of the background.
/// @param yscale The vertical scaling of the background.
/// @param rot The rotation of the background.
/// @param c1 The colour with which to blend the top left area of the background. 
/// @param c2 The colour with which to blend the top right area of the background.
/// @param c3 The colour with which to blend the bottom right area of the background.
/// @param c4  The colour with which to blend the bottom left area of the background. 
/// @param alpha  The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque). 
/// @returns 
function draw_background_general(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11, argument12, argument13, argument14) {

	draw_sprite_general(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11, argument12, argument13, argument14);



}


/// @description  @description Draws part of a background at a given position.
/// @param back The index of the background to draw.
/// @param left The x position on the background of the top left corner of the area to draw.
/// @param top  The y position on the background of the top left corner of the area to draw.
/// @param width  The width of the area to draw.
/// @param height  The height of the area to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @returns 
function draw_background_part(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	draw_sprite_part(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6);



}


/// @description  @description Draws part of a background at a given position with scaling, blending and alpha options.
/// @param back The index of the background to draw.
/// @param left The x position on the background of the top left corner of the area to draw.
/// @param top  The y position on the background of the top left corner of the area to draw.
/// @param width  The width of the area to draw.
/// @param height  The height of the area to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @param xscale  The horizontal scaling of the background.
/// @param yscale  The vertical scaling of the background.
/// @param colour   The colour with which to blend the background (use -1 or c_white to display it normally). 
/// @param alpha  The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque).
/// @returns 
function draw_background_part_ext(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10) {

	draw_sprite_part_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10);



}


/// @description  @description Draws a background at a given position, stretched.
/// @param back The index of the background to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @param w The width of the area the stretched background will occupy.
/// @param h The height of the area the stretched background will occupy.
/// @returns 
function draw_background_stretched(argument0, argument1, argument2, argument3, argument4) {

	draw_sprite_stretched(argument0, 0, argument1, argument2, argument3, argument4);



}


/// @description  @description Draws a background at a given position, stretched, and allows for a custom blend and alpha.
/// @param back The index of the background to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @param w The width of the area the stretched background will occupy.
/// @param h The height of the area the stretched background will occupy.
/// @param colour The colour with which to blend the background (use -1 or c_white to display it normally).
/// @param alpha The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque).
/// @returns 
function draw_background_stretched_ext(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	draw_sprite_stretched_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6);



}


/// @description  @description Draws a background at a given position, and tiles it to fill the entire view.
/// @param back The index of the background to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @returns 
function draw_background_tiled(argument0, argument1, argument2) {

	draw_sprite_tiled(argument0, 0, argument1, argument2);



}


/// @description  @description Draws a background at a given position with scaling, blending and alpha, and tiles it to fill the entire view.
/// @param back The index of the background to draw.
/// @param x The x coordinate of where to draw the background.
/// @param y The y coordinate of where to draw the background.
/// @param xscale The horizontal scaling of the background.
/// @param yscale The vertical scaling of the background.
/// @param colour The colour with which to blend the background (use -1 or c_white to display it normally).
/// @param alpha The alpha of the background (from 0 to 1 where 0 is transparent and 1 opaque).
/// @returns 
function draw_background_tiled_ext(argument0, argument1, argument2, argument3, argument4, argument5, argument6) {

	draw_sprite_tiled_ext(argument0, 0, argument1, argument2, argument3, argument4, argument5, argument6);



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_enable_alphablend(argument0) {
	gpu_set_blendenable( argument0 );



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_get_alpha_test() {
	return gpu_get_alphatestenable();



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_get_alpha_test_ref_value() {
	return gpu_get_alphatestref();



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_set_alpha_test(argument0) {
	gpu_set_alphatestenable( argument0 );



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_set_alpha_test_ref_value(argument0) {
	gpu_set_alphatestref( argument0 );



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_set_blend_mode(argument0) {
	gpu_set_blendmode( argument0 );



}


/// @description  @description Sets an extended blend mode for drawing.
/// @param src Source blend mode
/// @param dest Destination blend mode
function draw_set_blend_mode_ext(argument0, argument1) {
	gpu_set_blendmode_ext( argument0, argument1 );



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_set_color_write_enable(argument0, argument1, argument2, argument3) {
	gpu_set_colorwriteenable( argument0, argument1, argument2, argument3 );



}


/// @description  @description Sets the blend mode for drawing.
/// @param mode The blend mode constant to set to 
function draw_set_colour_write_enable(argument0, argument1, argument2, argument3) {
	gpu_set_colorwriteenable( argument0, argument1, argument2, argument3 );



}
#endregion

#region Room
/// @description  @description Sets a background and its related attributes of a given room.
/// @param ind The index of the room to set the background of.
/// @param bind The index of the background slot to set (between 0 and 7).
/// @param vis Whether the new background is visible (true) or not (false).
/// @param fore Whether the background is actually a foreground (true) or a background (false).
/// @param back The index of the new background.
/// @param x The x position of the background (if htiled is true, the x of one of the backgrounds).
/// @param y The y position of the background (if vtiled is true, the y of one of the backgrounds).
/// @param htiled Whether the background is tiled horizontally (true) or not (false).
/// @param vtiled Whether the background is tiled vertically (true) or not (false).
/// @param hspeed The horizontal speed of the background in pixels per step.
/// @param vspeed The vertical speed of the background in pixels per step.
/// @param alpha The alpha (transparency) of the background. 1=opaque, 0=invisible, 0.5=translucent etc
/// @returns 
function room_set_background(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11) {

	// NOTE: this script will only work properly if youre using the standard depth range (-16000 to 16000)

	var __ind = argument0;
	var __bind = argument1;
	var __vis = argument2;
	var __fore = argument3;
	var __back = argument4;
	var __x = argument5;
	var __y = argument6;
	var __htiled = argument7;
	var __vtiled = argument8;
	var __hspeed = argument9;
	var __vspeed = argument10;
	var __alpha = argument11;

	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}

	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);

	__background_set_element(__bind, __vis, __fore, __back, __x, __y, __htiled, __vtiled, 1,1,false, __hspeed, __vspeed, $ffffff, __alpha);

	// Finally, restore our original room target
	layer_set_target_room(__currroom);



}


/// @description  @description Sets a view and its related attributes of a given room.
/// @param ind The index of the room to set the view of.
/// @param vind The view slot to set, between 0 and 7.
/// @param vis Whether the view is visible (true) or not (false).
/// @param xview The x position of the left of the area the view captures.
/// @param yview The y position of the top of the area the view captures.
/// @param wview The width of the area the view captures.
/// @param hview The height of the area the view captures.
/// @param xport The x position of the left of the area the view occupies on-screen.
/// @param yport The y position of the top of the area the view occupies on-screen.
/// @param wport The width of the area the view occupies on-screen.
/// @param hport The height of the area the view occupies on-screen.
/// @param hborder The minimum horizontal space between the edge of the view and the object it is set to follow (before the view begins moving and if it is set to follow an object).
/// @param vborder The minimum vertical space between the edge of the view and the object it is set to follow (before the view begins moving and if it is set to follow an object).
/// @param hspeed The maximum horizontal speed the view can move at.
/// @param vspeed The maximum vertical speed the view can move at.
/// @param obj The object or instance to follow. -1 to disable object following.
function room_set_view(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11, argument12, argument13, argument14, argument15) {

	var __ind = argument0;
	var __vind = argument1;
	var __vis = argument2;
	var __xview = argument3;
	var __yview = argument4;
	var __wview = argument5;
	var __hview = argument6;
	var __xport = argument7;
	var __yport = argument8;
	var __wport = argument9;
	var __hport = argument10;
	var __hborder = argument11;
	var __vborder = argument12;
	var __hspeed = argument13;
	var __vspeed = argument14;
	var __obj = argument15;

	if (!room_exists(__ind))
	{
		pprint("room_set_view: room " + string(__ind) + " does not exist");
		return -1;
	}

	if ((__vind < 0) || (__vind > 7))
	{
		pprint("room_set_view: view index out of range");
		return -1;
	}

	// Create new camera with specified params
	var __newcam = camera_create_view(__xview, __yview, __wview, __hview, 0, __obj, __hspeed, __vspeed, __hborder, __vborder);

	// Get existing camera in room
	var __currcam = room_get_camera(__ind, __vind);
	if (__currcam != -1)
	{
		// destroy it so we dont leave it in limbo
		camera_destroy(__currcam);
	}

	room_set_camera(__ind, __vind, __newcam);

	room_set_viewport(__ind, __vind, __vis, __xport, __yport, __wport, __hport);

	return -1;



}


/// @description  @description Add a new tile to a room and return its index.
/// @param ind The index of the room to set the background of.
/// @param back The background from which the tile is taken.
/// @param left The x coordinate of the left side of the tile relative to the background.
/// @param top The y coordinate of the top side of the tile relative to the background.
/// @param width The width of the tile.
/// @param height The height of the tile.
/// @param x The x coordinate of where to place the tile. 
/// @param y The y coordinate of where to place the tile.
/// @param depth The depth of the tile in the room.
/// @returns {number} resource name for the new tile
function room_tile_add(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8) {

	var __ind = argument0;
	var __back = argument1;
	var __left = argument2;
	var __top = argument3;
	var __width = argument4;
	var __height = argument5;
	var __x = argument6;
	var __y = argument7;
	var __depth = argument8;

	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}

	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);

	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Dont bother checking names - well just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}

	if (__layertouse == -1)
	{
		// didnt find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}

	// Now create a new tile element and add it to the layer
	var __tile = layer_tile_create(__layertouse, __x, __y, __back, __left, __top, __width, __height);

	// Finally, restore our original room target
	layer_set_target_room(__currroom);

	return __tile;



}


/// @description  @description Adds a new tile to a given room and sets its properties.
/// @param ind The index of the room to set the background of.
/// @param back The background from which the tile is taken.
/// @param left The x coordinate of the left side of the tile relative to the background.
/// @param top The y coordinate of the top side of the tile relative to the background.
/// @param width The width of the tile.
/// @param height The height of the tile.
/// @param x The x coordinate of where to place the tile. 
/// @param y The y coordinate of where to place the tile.
/// @param depth The depth of the tile in the room.
/// @param xscale The horizontal scale of the tile. 1=normal size, 0.5=half, 2=double, etc.
/// @param yscale The vertical scale of the tile. 1=normal size, 0.5=half, 2=double, etc.
/// @param alpha The alpha (transparency) of the tile. 0=invisible, 1=opaque, 0.5=translucent etc.
/// @returns {number} resource name for the new tile
function room_tile_add_ext(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7, argument8, argument9, argument10, argument11) {

	var __ind = argument0;
	var __back = argument1;
	var __left = argument2;
	var __top = argument3;
	var __width = argument4;
	var __height = argument5;
	var __x = argument6;
	var __y = argument7;
	var __depth = argument8;
	var __xscale = argument9;
	var __yscale = argument10;
	var __alpha = argument11;

	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}

	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);

	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Dont bother checking names - well just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}

	if (__layertouse == -1)
	{
		// didnt find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}

	// Now create a new tile element and add it to the layer
	var __tile = layer_tile_create(__layertouse, __x, __y, __back, __left, __top, __width, __height);
	layer_tile_xscale(__tile, __xscale);
	layer_tile_yscale(__tile, __yscale);
	layer_tile_alpha(__tile, __alpha);

	// Finally, restore our original room target
	layer_set_target_room(__currroom);

	return __tile;



}


/// @description  @description Clears all tiles from a given room.
/// @param ind The index of the room to clear all tiles from.
/// @returns 
function room_tile_clear(argument0) {

	var __ind = argument0;

	// First check to see if the target room actually exists
	if (room_exists(__ind) == false)
	{
		return -1;
	}

	// Save the current target room and switch to the new one
	var __currroom = layer_get_target_room();
	layer_set_target_room(__ind);

	// Scan all layers for tile elements and destroy any that we find
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_destroy(__els[__j]);
			}
		}	
	}


	// Finally, restore our original room target
	layer_set_target_room(__currroom);



}
#endregion

#region Sound
/// @description  @description (Deprecated) add a sound resource
/// @param Deprecated
/// @param fname	The filename of the sound to add.
/// @param kind		The kind of sound it should be added as (legacy Feature) 0=normal, 1=background, 2=3D, 3=multimedia player, for things like MP3s).
/// @param preload	Whether the sound should preload into memory immediately (true) or not (false) (legacy Feature) .
function sound_add() {
	pprint( "sound_add is not supported");
	return -1;



}


/// @description  @description Deletes the indicated sound to free it from game memory. 
/// @param index	sound index
function sound_delete(argument0) {
	audio_delete(argument0);




}


/// @description  @description sound_discard - deprecated function
/// @param index	sound index
function sound_discard() {
	pprint( "sound_discard is a deprecated function" );
	return 0;



}


/// @description  @description Checks whether the given sound exists. 
/// @param index	sound index
/// @returns {boolean} true if sound exists, false otherwise
function sound_exists(argument0) {
	return audio_exists(argument0);




}


/// @description  @description Fade a sound in or out over a given time.
/// @param index	sound index
/// @param volume	The final volume from 0 to 1.
/// @param time		The length for the change in gain in milliseconds. 
function sound_fade(argument0, argument1, argument2) {
	audio_sound_gain( argument0, argument1, argument2 );



}


/// @description  @description sound_get_kind - deprecated function
/// @param index	sound index
function sound_get_kind() {
	pprint( "sound_get_kind - deprecated function");
	return 0;



}


/// @description  @description Returns the resource name of the given sound.
/// @param index	sound index
/// @returns {string} resource name for the given sound
function sound_get_name(argument0) {
	return audio_get_name( argument0 );



}


/// @description  @description sound_get_preload - deprecated function
/// @param index	sound index
function sound_get_preload() {
	pprint( "sound_get_preload - deprecated function");
	return 0;



}


/// @description  @description Sets the volume of all sounds
/// @param value	The new global volume from 0 to 1.
function sound_global_volume(argument0) {
	audio_master_gain(argument0)




}


/// @description  @description Checks to see if a given sound is playing.
/// @param index	sound index
/// @return {boolean} 
function sound_isplaying(argument0) {
	return audio_is_playing( argument0 );



}


function sound_loop(argument0) {
	// ------------------------------------------------------------
	/// @description Loops the indicated sound
	/// @param index The index of the sound to loop

	audio_play_sound( argument0, 10, true );



}


/// @description  @description sound_name - deprecated function
/// @param index	sound index
function sound_name(argument0) {
	return audio_get_name( argument0 );



}


function sound_play(argument0) {
	// ------------------------------------------------------------
	/// @description Plays the indicated sound once.
	/// @param index The index of the sound to play

	audio_play_sound( argument0, 10, false );



}


/// @description  @description (Deprecated) Replaces an existing sound with one from a given filename
/// @param Deprecated
/// @param index 	The index of the sound to be replace.
/// @param fname	The filename of the sound to add.
/// @param kind		The kind of sound it should be added as (legacy Feature) 0=normal, 1=background, 2=3D, 3=multimedia player, for things like MP3s).
/// @param preload	Whether the sound should preload into memory immediately (true) or not (false) (legacy Feature) .
function sound_replace() {
	pprint( "sound_replace is not supported");
	return false;



}


/// @description  @description sound_restore - deprecated function
/// @param index	sound index
function sound_restore() {
	pprint( "sound_restore is a deprecated function" );
	return 0;



}


function sound_stop(argument0) {
	// ------------------------------------------------------------
	/// @description Stops a given sound.
	/// @param index The index of the sound to stop

	audio_stop_sound( argument0 );



}


function sound_stop_all() {
	// ------------------------------------------------------------
	/// @description Stops a given sound.
	audio_stop_all();




}


/// @description  @description Sets the volume of a given sound.
/// @param index 	The index of the sound to change the volume of.
/// @param value	The new global volume from 0 to 1.
function sound_volume(argument0, argument1) {
	audio_sound_gain( argument0, argument1, 0);



}
#endregion

#region Texture
function texture_set_blending(argument0) {
	var __dummy = argument0;

	pprint("texture_set_blending() currently not supported");



}


function texture_set_interpolation(argument0) {
	gpu_set_texfilter(argument0);



}


function texture_set_interpolation_ext(argument0, argument1) {
	gpu_set_texfilter_ext(argument0, argument1);



}


function texture_set_repeat(argument0) {
	gpu_set_texrepeat( argument0 );



}


function texture_set_repeat_ext(argument0, argument1) {
	gpu_set_texrepeat_ext( argument0, argument1 );



}
#endregion

#region Tile
/// @description  @description Adds a new tile to the room, allowing customisation of its attributes, and returning its index.
/// @param background The background asset from which the new tile will be extracted.
/// @param left The x coordinate of the left of the new tile, relative to the background assets top left corner.
/// @param top The y coordinate of the top of the new tile, relative to the background assets top left corner.
/// @param width The width of the tile.
/// @param height The height of the tile.
/// @param x The x position in the room to place the tile.
/// @param y The y position in the room to place the tile.
/// @param depth The depth at which to place the tile.
/// @returns {number} resource name for the new tile
function tile_add(argument0, argument1, argument2, argument3, argument4, argument5, argument6, argument7) {

	var __back = argument0;
	var __left = argument1;
	var __top = argument2;
	var __width = argument3;
	var __height = argument4;
	var __x = argument5;
	var __y = argument6;
	var __depth = argument7;

	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Dont bother checking names - well just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}

	if (__layertouse == -1)
	{
		// didnt find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}

	// Now create a new tile element and add it to the layer
	var __tile = layer_tile_create(__layertouse, __x, __y, __back, __left, __top, __width, __height);

	return __tile;



}


/// @description  @description Deletes a given tile in the room.
/// @param index The index of the tile to delete.
/// @returns
function tile_delete(argument0) {

	var __index = argument0;

	layer_tile_destroy(__index);



}


/// @description  @description Checks if a given tile exists in the room.
/// @param index The index of the tile to check for.
/// @returns {boolean} whether the tile exists
function tile_exists(argument0) {

	var __index = argument0;

	return layer_tile_exists(__index);



}


/// @description  @description Returns the alpha value of a given tile.
/// @param index The index of the tile.
/// @returns {number} The alpha of the tile
function tile_get_alpha(argument0) {

	var __index = argument0;

	return layer_tile_get_alpha(__index);



}


/// @description  @description Returns the background index a given tile is drawn from.
/// @param index The index of the tile.
/// @returns {number} The background index
function tile_get_background(argument0) {

	var __index = argument0;

	return layer_tile_get_sprite(__index);



}


/// @description  @description Returns the blending colour of a given tile.
/// @param index The index of the tile.
/// @returns {number} The background index
function tile_get_blend(argument0) {

	var __index = argument0;

	return layer_tile_get_blend(__index);



}


/// @description  @description Returns the total number of tiles in a room.
/// @returns {number} total number of tiles in room
function tile_get_count() {

	var __totaltiles = 0;

	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				__totaltiles++;
			}
		}	
	}

	return __totaltiles;



}


/// @description  @description Returns the depth of a given tile.
/// @param index The index of the tile to check.
/// @returns {number} the depth of the tile
function tile_get_depth(argument0) {

	var __index = argument0;

	// Should really check if the element ID points to a tile (and not a different sort of element)
	var __layerid = layer_get_element_layer(__index);
	return layer_get_depth(__layerid);



}


/// @description  @description Returns the height of a given tile.
/// @param index The index of the tile.
/// @returns {number} The height of the tile
function tile_get_height(argument0) {

	var __index = argument0;

	var __reg = layer_tile_get_region(__index);
	if (array_length_1d(__reg) == 0)
		return 0;

	return __reg[3];
	



}


/// @description  @description Returns the unique id for the given tile index.
/// @param index The index of the tile.
/// @returns {number} total number of tiles in room
function tile_get_id(argument0) {

	var __index = argument0;

	var __currtile = 0;

	// Scan through all layers looking for the specified tile (slow!)
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				if (__currtile == __index)
				{
					return __els[__j];
				}
			
				__currtile++;
			}
		}	
	}

	return -1;



}


/// @description  @description Returns an array containing the unique ID values for all tiles in a room.
/// @returns {array} IDs of all tiles in the room
function tile_get_ids() {

	var __tiles;
	__tiles[0] = -1;
	var __currtile = 0;

	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				__tiles[__currtile] = __els[__j];						
				__currtile++;
			}
		}	
	}

	return __tiles;



}


/// @description  @description Returns an array containing the unique ID values for all tiles at a given depth.
/// @param depth The depth of the tile layer to get the IDs of.
/// @returns {array} IDs of all tiles of the specified depth in the room
function tile_get_ids_at_depth(argument0) {

	var __depth = argument0;

	var __tiles;
	__tiles[0] = -1;
	var __currtile = 0;

	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
	
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				__tiles[__currtile] = __els[__j];						
				__currtile++;
			}
		}	
	}

	return __tiles;



}


/// @description  @description Returns the left coordinate of a given tile from its background.
/// @param index The index of the tile.
/// @returns {number} The width of the tile
function tile_get_left(argument0) {

	var __index = argument0;

	var __reg = layer_tile_get_region(__index);
	if (array_length_1d(__reg) == 0)
		return 0;
	
	return __reg[0];



}


/// @description  @description Returns the top coordinate of a given tile from its background.
/// @param index The index of the tile.
/// @returns {number} The top of the tile
function tile_get_top(argument0) {

	var __index = argument0;

	var __reg = layer_tile_get_region(__index);
	if (array_length_1d(__reg) == 0)
		return 0;
	
	return __reg[1];



}


/// @description  @description Returns whether a tile is visible or not.
/// @param index The index of the tile.
/// @returns {boolean} The visibility of the tile
function tile_get_visible(argument0) {

	var __index = argument0;

	return layer_tile_get_visible(__index);



}


/// @description  @description Returns the width of a given tile.
/// @param index The index of the tile.
/// @returns {number} The width of the tile
function tile_get_width(argument0) {

	var __index = argument0;

	var __reg = layer_tile_get_region(__index);
	if (array_length_1d(__reg) == 0)
		return 0;
	
	return __reg[2];



}


/// @description  @description Returns the x coordinate of a given tile.
/// @param index The index of the tile.
/// @returns {number} The x position of the tile
function tile_get_x(argument0) {

	var __index = argument0;

	return layer_tile_get_x(__index);



}


/// @description  @description Returns the horizontal scaling of a given tile.
/// @param index The index of the tile.
/// @returns {number} The horizontal scaling of the tile
function tile_get_xscale(argument0) {

	var __index = argument0;

	return layer_tile_get_xscale(__index);



}


/// @description  @description Returns the y coordinate of a given tile.
/// @param index The index of the tile.
/// @returns {number} The y position of the tile
function tile_get_y(argument0) {

	var __index = argument0;

	return layer_tile_get_y(__index);



}


/// @description  @description Returns the vertical scaling of a given tile.
/// @param index The index of the tile.
/// @returns {number} The vertical scaling of the tile
function tile_get_yscale(argument0) {

	var __index = argument0;

	return layer_tile_get_yscale(__index);



}


/// @description  @description Deletes all tiles at the indicated depth layer.
/// @param depth The depth of tiles which is to be deleted.
/// @returns 
function tile_layer_delete(argument0) {

	var __depth = argument0;

	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
	
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_destroy(__els[__j]);			
			}
		}	
	}



}


/// @description  @description Deletes the tile(s) at a given depth and position.
/// @param s
/// @param depth The depth of a tile to be deleted.
/// @param x The x position at which to delete a tile.
/// @param y The y position at which to delete a tile.
/// @returns 
function tile_layer_delete_at(argument0, argument1, argument2) {

	var __depth = argument0;
	var __x = argument1;
	var __y = argument2;

	var __tile_el = tile_layer_find(__depth, __x, __y);
	if (__tile_el != -1)
	{
		layer_tile_destroy(__tile_el);			
	}



}


/// @description  @description Moves all tiles at a given depth to a new depth.
/// @param depth The current depth of the tile layer.
/// @param newdepth The depth to change the layer to.
/// @returns 
function tile_layer_depth(argument0, argument1) {

	var __depth = argument0;
	var __newdepth = argument1;

	// Scan for a layer with the depth
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);
	var __layerstomove;
	__layerstomove[0] = -1;
	var __numlayerstomove = 0;

	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		var __layerdepth = layer_get_depth(__layers[__i]);
	
		if (__layerdepth == __depth)
		{
			__layerstomove[__numlayerstomove] = __layers[__i];
			__numlayerstomove++;
		}	
		else if (layer_get_depth(__layers[__i]) == __newdepth)
		{
			// Dont bother checking names - well just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}

	if (__layertouse == -1)
	{
		// didnt find a layer of the correct depth, so create one
		__layertouse = layer_create(__newdepth);
	}

	// Now go through again and move all those tiles of the original depth to the new layer
	// (should we delete layers that become empty?)
	for(__i = 0; __i < __numlayerstomove; __i++)
	{
		var __els = layer_get_all_elements(__layerstomove[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			if (layer_get_element_type(__els[__j]) == layerelementtype_tile)
			{
				layer_element_move(__els[__j], __layertouse);
			}
		}
	}



}


/// @description  @description Returns the id of a tile at a given depth and position.
/// @param depth The depth of the tile to be found.
/// @param x The x position to check.
/// @param y The y position to check.
/// @returns 
function tile_layer_find(argument0, argument1, argument2) {

	var __depth = argument0;
	var __x = argument1;
	var __y = argument2;

	// Scan through all layers looking for tiles
	// This is going to be slow
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
	
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				var __tileXscale = layer_tile_get_xscale(__els[__j]);
				var __tileYscale = layer_tile_get_yscale(__els[__j]);
			
				// Fast(ish) path with more early-outs
				if ((__tileXscale >= 0) && (__tileYscale >= 0))
				{			
					var __tileX = layer_tile_get_x(__els[__j]);						
					if (__x < __tileX)
						continue;
					
					var __tileY = layer_tile_get_y(__els[__j]);
					if (__y < __tileY)
						continue;
							
					var __tileReg = layer_tile_get_region(__els[__j]);			
					var __tileRight = __tileX + (__tileXscale * __tileReg[2]);
					if (__x >= __tileRight)
						continue;
					
				
					var __tileBottom = __tileY + (__tileYscale * __tileReg[3]);
					if (__y >= __tileBottom)
						continue;
				
					// Passed all the tests so return this tile
					return __els[__j];
				}
				else
				{
					var __tileReg = layer_tile_get_region(__els[__j]);
					var __minx = layer_tile_get_x(__els[__j]);
					var __maxx = __minx + (__tileXscale * __tileReg[2]);
					if (__minx > __maxx)
					{
						var __temp = __minx;
						__minx = __maxx;
						__maxx = __temp;
					}
				
					if (__x < __minx)
						continue;
					
					if (__x >= __maxx)
						continue;
					
					var __miny = layer_tile_get_y(__els[__j]);
					var __maxy = __miny + (__tileYscale * __tileReg[3]);
					if (__miny > __maxy)
					{
						var __temp = __miny;
						__miny = __maxy;
						__maxy = __temp;
					}
				
					if (__y < __miny)
						continue;
					
					if (__y >= __maxy)
						continue;
					
					// Passed all the tests so return this tile
					return __els[__j];
				
				}
			}
		}	
	}

	return -1;



}


/// @description  @description Hides all tiles at the indicated depth layer.
/// @param depth The depth of tiles which is to be hidden.
/// @returns 
function tile_layer_hide(argument0) {

	var __depth = argument0;

	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
	
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_visible(__els[__j],false);			
			}
		}	
	}



}


/// @description  @description Shifts all tiles at the indicated depth layer by a given amount.
/// @param depth The depth of tiles which is to be shifted.
/// @param x The amount to shift over the x-axis.
/// @param y The amount to shift over the y-axis.
/// @returns 
function tile_layer_shift(argument0, argument1, argument2) {

	var __depth = argument0;
	var __x = argument1;
	var __y = argument2;

	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
	
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_x(__els[__j], layer_tile_get_x(__els[__j]) + __x);
				layer_tile_y(__els[__j], layer_tile_get_y(__els[__j]) + __y);			
			}
		}	
	}



}


/// @description  @description Shows all tiles at the indicated depth layer.
/// @param depth The depth of tiles which is to be shown.
/// @returns 
function tile_layer_show(argument0) {

	var __depth = argument0;

	// Scan through all layers looking for tiles
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) != __depth)
			continue;
	
		var __els = layer_get_all_elements(__layers[__i]);
		var __numels = array_length_1d(__els);
	
		var __j;
		for(__j = 0; __j < __numels; __j++)
		{
			var __eltype = layer_get_element_type(__els[__j]);
			if (__eltype == layerelementtype_tile)
			{
				layer_tile_visible(__els[__j],true);			
			}
		}	
	}



}


/// @description  @description Sets a tiles alpha (transparency).
/// @param transparency
/// @param index The index of the tile.
/// @param alpha The transparency of the tile.
/// @returns 
function tile_set_alpha(argument0, argument1) {

	var __index = argument0;
	var __alpha = argument1;

	return layer_tile_alpha(__index, __alpha);



}


/// @description  @description Sets the background for a tile to be drawn from.
/// @param index The index of the tile.
/// @param background The index of the background to take the tile from.
/// @returns 
function tile_set_background(argument0, argument1) {

	var __index = argument0;
	var __background = argument1;

	return layer_tile_change(__index, __background);



}


/// @description  @description Sets a tiles blending.
/// @param index The index of the tile.
/// @param colour The colour to blend the tile with.
/// @returns 
function tile_set_blend(argument0, argument1) {

	var __index = argument0;
	var __colour = argument1;

	return layer_tile_blend(__index, __colour);



}


/// @description  @description Sets a tiles depth.
/// @param index The index of the tile to set.
/// @param depth The depth of the tile.
/// @returns
function tile_set_depth(argument0, argument1) {

	var __index = argument0;
	var __depth = argument1;

	// Should really check if the element ID points to a tile (and not a different sort of element)
	var __layerid = layer_get_element_layer(__index);
	if (__layerid == -1)
		return -1;	// not found
	
	var __currdepth = layer_get_depth(__layerid);
	if (__currdepth == __depth)
		return -1;	// depth already correct
	
	// Scan for a layer with the correct depth
	var __layers = layer_get_all();
	var __numlayers = array_length_1d(__layers);

	var __layertouse = -1;
	var __i;
	for(__i = 0; __i < __numlayers; __i++)
	{
		if (layer_get_depth(__layers[__i]) == __depth)
		{
			// Dont bother checking names - well just add tiles to whatever layer is handy
			__layertouse = __layers[__i];
			break;		
		}
	}

	if (__layertouse == -1)
	{
		// didnt find a layer of the correct depth, so create one
		__layertouse = layer_create(__depth);
	}

	// Now move the tile from its old layer to the new one
	layer_element_move(__index, __layertouse);

	return layer_get_depth(__layerid);



}


/// @description  @description Sets the position of a given tile.
/// @param index The index of the tile.
/// @param x The tiles new x position.
/// @param y The tiles new y position.
/// @returns 
function tile_set_position(argument0, argument1, argument2) {

	var __index = argument0;
	var __x = argument1;
	var __y = argument2;

	layer_tile_x(__index, __x);
	layer_tile_y(__index, __y);



}


/// @description  @description Sets the region of its background a tile is taken from.
/// @param index The index of the tile.
/// @param left The tiles left position relative to the backgrounds top left corner.
/// @param top The tiles top position relative to the backgrounds top left corner.
/// @param width The tiles width.
/// @param height The tiles height.
/// @returns 
function tile_set_region(argument0, argument1, argument2, argument3, argument4) {

	var __index = argument0;
	var __left = argument1;
	var __top = argument2;
	var __width = argument3;
	var __height = argument4;

	layer_tile_region(__index, __left, __top, __width, __height);



}


/// @description  @description Sets a tiles horizontal and vertical scaling.
/// @param index The index of the tile.
/// @param xscale The tiles horizontal scale.
/// @param yscale The tiles vertical scale.
/// @returns 
function tile_set_scale(argument0, argument1, argument2) {

	var __index = argument0;
	var __xscale = argument1;
	var __yscale = argument2;

	layer_tile_xscale(__index, __xscale);
	layer_tile_yscale(__index, __yscale);



}


/// @description  @description Sets a tiles visibility.
/// @param index The index of the tile.
/// @param visible The visibility of the tile. true=visible, false=invisible.
/// @returns 
function tile_set_visible(argument0, argument1) {

	var __index = argument0;
	var __visible = argument1;

	layer_tile_visible(__index, __visible);



}
#endregion

#region View
function __view_get(argument0, argument1) {
	var __prop = argument0;
	var __index = argument1;

	var __res = -1;

	switch(__prop)
	{
	case e__VW.XView: var __cam = view_get_camera(__index); __res = camera_get_view_x(__cam); break;
	case e__VW.YView: var __cam = view_get_camera(__index); __res = camera_get_view_y(__cam); break;
	case e__VW.WView: var __cam = view_get_camera(__index); __res = camera_get_view_width(__cam); break;
	case e__VW.HView: var __cam = view_get_camera(__index); __res = camera_get_view_height(__cam); break;
	case e__VW.Angle: var __cam = view_get_camera(__index); __res = camera_get_view_angle(__cam); break;
	case e__VW.HBorder: var __cam = view_get_camera(__index); __res = camera_get_view_border_x(__cam); break;
	case e__VW.VBorder: var __cam = view_get_camera(__index); __res = camera_get_view_border_y(__cam); break;
	case e__VW.HSpeed: var __cam = view_get_camera(__index); __res = camera_get_view_speed_x(__cam); break;
	case e__VW.VSpeed: var __cam = view_get_camera(__index); __res = camera_get_view_speed_y(__cam); break;
	case e__VW.Object: var __cam = view_get_camera(__index); __res = camera_get_view_target(__cam); break;
	case e__VW.Visible: __res = view_get_visible(__index); break;
	case e__VW.XPort: __res = view_get_xport(__index); break;
	case e__VW.YPort: __res = view_get_yport(__index); break;
	case e__VW.WPort: __res = view_get_wport(__index); break;
	case e__VW.HPort: __res = view_get_hport(__index); break;
	case e__VW.Camera: __res = view_get_camera(__index); break;
	case e__VW.SurfaceID: __res = view_get_surface_id(__index); break;
	default: break;
	};

	return __res;



}


function __view_set(argument0, argument1, argument2) {
	var __prop = argument0;
	var __index = argument1;
	var __val = argument2;

	__view_set_internal(__prop, __index, __val);

	var __res = __view_get(__prop, __index);

	return __res;



}


function __view_set_internal(argument0, argument1, argument2) {
	var __prop = argument0;
	var __index = argument1;
	var __val = argument2;

	switch(__prop)
	{
	case e__VW.XView: var __cam = view_get_camera(__index); camera_set_view_pos(__cam, __val, camera_get_view_y(__cam)); break;
	case e__VW.YView: var __cam = view_get_camera(__index); camera_set_view_pos(__cam, camera_get_view_x(__cam), __val); break;
	case e__VW.WView: var __cam = view_get_camera(__index); camera_set_view_size(__cam, __val, camera_get_view_height(__cam)); break;
	case e__VW.HView: var __cam = view_get_camera(__index); camera_set_view_size(__cam, camera_get_view_width(__cam), __val); break;
	case e__VW.Angle: var __cam = view_get_camera(__index); camera_set_view_angle(__cam, __val); break;
	case e__VW.HBorder: var __cam = view_get_camera(__index); camera_set_view_border(__cam, __val, camera_get_view_border_y(__cam)); break;
	case e__VW.VBorder: var __cam = view_get_camera(__index); camera_set_view_border(__cam, camera_get_view_border_x(__cam), __val); break;
	case e__VW.HSpeed: var __cam = view_get_camera(__index); camera_set_view_speed(__cam, __val, camera_get_view_speed_y(__cam)); break;
	case e__VW.VSpeed: var __cam = view_get_camera(__index); camera_set_view_speed(__cam, camera_get_view_speed_x(__cam), __val); break;
	case e__VW.Object: var __cam = view_get_camera(__index); camera_set_view_target(__cam, __val); break;
	case e__VW.Visible: __res = view_set_visible(__index, __val); break;
	case e__VW.XPort: __res = view_set_xport(__index, __val); break;
	case e__VW.YPort: __res = view_set_yport(__index, __val); break;
	case e__VW.WPort: __res = view_set_wport(__index, __val); break;
	case e__VW.HPort: __res = view_set_hport(__index, __val); break;
	case e__VW.Camera: __res = view_set_camera(__index, __val); break;
	case e__VW.SurfaceID: __res = view_set_surface_id(__index, __val); break;
	default: break;
	};

	return 0;



}


function __view_set_pp(argument0, argument1, argument2) {
	var __prop = argument0;
	var __index = argument1;
	var __val = argument2;

	var __res = __view_get(__prop, __index);

	__view_set_internal(__prop, __index, __val);

	return __res;



}
#endregion

#region Instance/Object
/// @description  @description Creates an instance of a given object at a given position.
/// @param x The x position the object will be created at.
/// @param y The y position the object will be created at.
/// @param obj The object to create an instance of.
function instance_create(argument0, argument1, argument2) {
	var myDepth = object_get_depth( argument2 );
	return instance_create_depth( argument0, argument1, myDepth, argument2 );



}


/// @description  @description Returns the depth of the specified object.
/// @param {Number} obj The index of the object to check
/// @return {Number} depth of the object
function object_get_depth(argument0) {

	var objID = argument0;
	var ret = 0;
	if (objID >= 0) && (objID < array_length(global.__objectID2Depth)) {
		ret = global.__objectID2Depth[objID];
	} // end if
	return ret;



}


/// @description  @description Sets the depth of the given object.
/// @param {Number} index The index of the object to change
/// @param {Number} depth The new depth of the object
function object_set_depth(argument0, argument1) {
	var objID = argument0;
	if (object_exists(objID)) {
		with( objID ) {
			global.__objectID2Depth[id] = argument1;
		} // end with
	} // end if



}
#endregion


