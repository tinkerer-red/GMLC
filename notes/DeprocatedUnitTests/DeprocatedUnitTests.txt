
#region Tokenizer Tests
function run_tokenize_test(description, input, expected) {
	log($"Attempting Tokenizer Test :: {description}")
	
	var tokenizer = new GML_Tokenizer();
	tokenizer.initialize(input);
	var program = tokenizer.parseAll();
	
	__compare_results(description, program, expected);
}
function run_all_tokenize_test() {
log("~~~~~ Tokenizer Unit Tests ~~~~~\n")

#region Whitespace handling remains unchanged as there are no tokens expected
run_tokenize_test("Test whitespace handling", "    ",
{
  tokens:[
  ],
});
run_tokenize_test("Test whitespace varients", "   \t\n", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:1.0,
      column:5.0,
      value:"\n"
    }
  ],
});
#endregion
#region Test cases for number tokenization
run_tokenize_test("Test number tokenization", "123 456.789 01234", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"123",
      line:1.0,
      column:1.0,
      value:123.0
    },
    {
      type: __GMLC_TokenType.Number,
      name:"456.789",
      line:1.0,
      column:5.0,
      value:456.78899999999999
    },
    {
      type: __GMLC_TokenType.Number,
      name:"01234",
      line:1.0,
      column:13.0,
      value:1234.0
    }
  ],
});

// Test case for floating point edge cases
run_tokenize_test("Test floating point edge cases", ".5 5.", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:".5",
      line:1.0,
      column:1.0,
      value:0.5
    },
    {
      type: __GMLC_TokenType.Number,
      name:"5.",
      line:1.0,
      column:4.0,
      value:5.0
    }
  ],
});

run_tokenize_test("Test tokenize_number", "123 4.56 7_890", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"123",
      line:1.0,
      column:1.0,
      value:123.0
    },
    {
      type: __GMLC_TokenType.Number,
      name:"4.56",
      line:1.0,
      column:5.0,
      value:4.56
    },
    {
      type: __GMLC_TokenType.Number,
      name:"7_890",
      line:1.0,
      column:10.0,
      value:7890.0
    }
  ],
});

#endregion
#region Test cases for identifiers and keywords
run_tokenize_test("Test identifiers and keywords", "function varName if else", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Keyword,
      name:"function",
      line:1.0,
      column:1.0,
      value:"function"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"varName",
      line:1.0,
      column:10.0,
      value:"varName"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"if",
      line:1.0,
      column:18.0,
      value:"if"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"else",
      line:1.0,
      column:21.0,
      value:"else"
    }
  ],
});

run_tokenize_test("Test tokenize_identifier", "variableName _with_underscore CamelCase123 function globalvar region if(){}else{}", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"variableName",
      line:1.0,
      column:1.0,
      value:"variableName"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"_with_underscore",
      line:1.0,
      column:14.0,
      value:"_with_underscore"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"CamelCase123",
      line:1.0,
      column:31.0,
      value:"CamelCase123"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"function",
      line:1.0,
      column:44.0,
      value:"function"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"globalvar",
      line:1.0,
      column:53.0,
      value:"globalvar"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"region",
      line:1.0,
      column:63.0,
      value:"region"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"if",
      line:1.0,
      column:70.0,
      value:"if"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"(",
      line:1.0,
      column:72.0,
      value:"("
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:")",
      line:1.0,
      column:73.0,
      value:")"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"{",
      line:1.0,
      column:74.0,
      value:"{"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"}",
      line:1.0,
      column:75.0,
      value:"}"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"else",
      line:1.0,
      column:76.0,
      value:"else"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"{",
      line:1.0,
      column:80.0,
      value:"{"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"}",
      line:1.0,
      column:81.0,
      value:"}"
    }
  ],
});

#endregion
#region Test cases for operator tokenization
run_tokenize_test("Test operator tokenization", "+ - * / == != < <= > >= && ||",
{
  tokens:[
    {
      type: __GMLC_TokenType.Operator,
      name:"+",
      line:1.0,
      column:1.0,
      value:"+"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"-",
      line:1.0,
      column:3.0,
      value:"-"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"*",
      line:1.0,
      column:5.0,
      value:"*"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"\/",
      line:1.0,
      column:7.0,
      value:"\/"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"==",
      line:1.0,
      column:9.0,
      value:"=="
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"!=",
      line:1.0,
      column:12.0,
      value:"!="
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"<",
      line:1.0,
      column:15.0,
      value:"<"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"<=",
      line:1.0,
      column:17.0,
      value:"<="
    },
    {
      type: __GMLC_TokenType.Operator,
      name:">",
      line:1.0,
      column:20.0,
      value:">"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:">=",
      line:1.0,
      column:22.0,
      value:">="
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"&&",
      line:1.0,
      column:25.0,
      value:"&&"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"||",
      line:1.0,
      column:28.0,
      value:"||"
    }
  ],
});

run_tokenize_test("Test tokenize_operator", "+ - * / % ??=",
{
  tokens:[
    {
      type: __GMLC_TokenType.Operator,
      name:"+",
      line:1.0,
      column:1.0,
      value:"+"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"-",
      line:1.0,
      column:3.0,
      value:"-"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"*",
      line:1.0,
      column:5.0,
      value:"*"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"\/",
      line:1.0,
      column:7.0,
      value:"\/"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"%",
      line:1.0,
      column:9.0,
      value:"mod"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"??=",
      line:1.0,
      column:11.0,
      value:"??="
    }
  ],
});
// Test case for chained operators
run_tokenize_test("Test chained operators", "+++", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Operator,
      name:"++",
      line:1.0,
      column:1.0,
      value:"++"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"+",
      line:1.0,
      column:3.0,
      value:"+"
    }
  ],
});

#endregion
#region Test cases for string literal tokenization
run_tokenize_test("Test string literal tokenization", @'"Hello, World!" "Another\"String"', 
{
  tokens:[
    {
      type: __GMLC_TokenType.String,
      name:"\"Hello, World!\"",
      line:1.0,
      column:1.0,
      value:"Hello, World!"
    },
    {
      type: __GMLC_TokenType.String,
      name:"\"Another\"String\"",
      line:1.0,
      column:17.0,
      value:"Another\"String"
    }
  ],
});
run_tokenize_test("Test empty string literal tokenization", "\"\"", 
{
  tokens:[
    {
      type: __GMLC_TokenType.String,
      name:"\"\"",
      line:1.0,
      column:1.0,
      value:""
    }
  ],
});
// Test case for escape characters in strings
run_tokenize_test("Test escape sequences in strings", "\"Line\\nBreak\"", 
{
  tokens:[
    {
      type: __GMLC_TokenType.String,
      name:"\"Line\nBreak\"",
      line:1.0,
      column:1.0,
      value:"Line\nBreak"
    }
  ],
});
run_tokenize_test("Test tokenize_string_literal", "\"This is a stringLiteral\" \"\\tThis is a stringLiteral\\nWith line breaks\"", 
{
  tokens:[
    {
      type: __GMLC_TokenType.String,
      name:"\"This is a stringLiteral\"",
      line:1.0,
      column:1.0,
      value:"This is a stringLiteral"
    },
    {
      type: __GMLC_TokenType.String,
      name:"\"\tThis is a stringLiteral\nWith line breaks\"",
      line:1.0,
      column:27.0,
      value:"\tThis is a stringLiteral\nWith line breaks"
    }
  ],
});

#endregion
#region Test cases for raw string literal tokenization
run_tokenize_test("Test Raw string literal tokenization", "This is a test of the system", 
{
  tokens:[
    {
      type: __GMLC_TokenType.String,
      name:"This is a test of the system",
      line:1.0,
      column:1.0,
      value:"This is a test of the system"
    }
  ],
});

run_tokenize_test("Test tokenize_raw_string_literals", "\"This is a stringBlock\nwith a line break\" @'This is a second stringBlock\nwith a line break", 
{
  tokens:[
    {
      type: __GMLC_TokenType.String,
      name:"\"This is a stringBlock\nwith a line break\"",
      line:1.0,
      column:1.0,
      value:"This is a stringBlock\nwith a line break"
    },
    {
      type: __GMLC_TokenType.String,
      name:"This is a second stringBlock\nwith a line break",
      line:2.0,
      column:20.0,
      value:"This is a second stringBlock\nwith a line break"
    }
  ],
});

#endregion
#region Test cases for line comment tokenization
run_tokenize_test("Test line comment tokenization", "// This is a comment\n// Another line", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Comment,
      name:"\/\/ This is a comment",
      line:1.0,
      column:1.0,
      value:"\/\/ This is a comment"
    },
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:1.0,
      column:21.0,
      value:"\n"
    },
    {
      type: __GMLC_TokenType.Comment,
      name:"\/\/ Another line",
      line:2.0,
      column:1.0,
      value:"\/\/ Another line"
    }
  ],
});
#endregion
#region Test cases for block comment tokenization
run_tokenize_test("Test block comment tokenization", "/* Block comment */ int x = 5;", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Comment,
      name:"\/* Block comment *\/",
      line:1.0,
      column:1.0,
      value:"\/* Block comment *\/"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"int",
      line:1.0,
      column:21.0,
      value:"int"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"x",
      line:1.0,
      column:25.0,
      value:"x"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"=",
      line:1.0,
      column:27.0,
      value:"="
    },
    {
      type: __GMLC_TokenType.Number,
      name:"5",
      line:1.0,
      column:29.0,
      value:5.0
    }
  ],
});
// Test case for nested block comments
run_tokenize_test("Test nested block comments", "/* Comment */ Nested /* End */", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Comment,
      name:"\/* Comment *\/",
      line:1.0,
      column:1.0,
      value:"\/* Comment *\/"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"Nested",
      line:1.0,
      column:15.0,
      value:"Nested"
    },
    {
      type: __GMLC_TokenType.Comment,
      name:"\/* End *\/",
      line:1.0,
      column:22.0,
      value:"\/* End *\/"
    }
  ],
});
run_tokenize_test("Test tokenize_comment_line and block", @'// This is the comment
/*This is the comment
on
multiple lines*/
var b = 2;',
{
  tokens:[
    {
      type: __GMLC_TokenType.Comment,
      name:"\/\/ This is the comment",
      line:1.0,
      column:1.0,
      value:"\/\/ This is the comment"
    },
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:1.0,
      column:24.0,
      value:"\n"
    },
    {
      type: __GMLC_TokenType.Comment,
      name:"\/*This is the comment\r\non\r\nmultiple lines*\/",
      line:2.0,
      column:1.0,
      value:"\/*This is the comment\r\non\r\nmultiple lines*\/"
    },
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:4.0,
      column:18.0,
      value:"\n"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"var",
      line:5.0,
      column:1.0,
      value:"var"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"b",
      line:5.0,
      column:5.0,
      value:"b"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"=",
      line:5.0,
      column:7.0,
      value:"="
    },
    {
      type: __GMLC_TokenType.Number,
      name:"2",
      line:5.0,
      column:9.0,
      value:2.0
    }
  ],
});

#endregion
#region Test cases for mixed content
run_tokenize_test("Test mixed content", @'var x = 100; // variable declaration
function test() { return x; }',
{
  tokens:[
    {
      type: __GMLC_TokenType.Keyword,
      name:"var",
      line:1.0,
      column:1.0,
      value:"var"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"x",
      line:1.0,
      column:5.0,
      value:"x"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"=",
      line:1.0,
      column:7.0,
      value:"="
    },
    {
      type: __GMLC_TokenType.Number,
      name:"100",
      line:1.0,
      column:9.0,
      value:100.0
    },
    {
      type: __GMLC_TokenType.Comment,
      name:"\/\/ variable declaration",
      line:1.0,
      column:14.0,
      value:"\/\/ variable declaration"
    },
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:1.0,
      column:38.0,
      value:"\n"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"function",
      line:2.0,
      column:1.0,
      value:"function"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"test",
      line:2.0,
      column:10.0,
      value:"test"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"(",
      line:2.0,
      column:14.0,
      value:"("
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:")",
      line:2.0,
      column:15.0,
      value:")"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"{",
      line:2.0,
      column:17.0,
      value:"{"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"return",
      line:2.0,
      column:19.0,
      value:"return"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"x",
      line:2.0,
      column:26.0,
      value:"x"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"}",
      line:2.0,
      column:29.0,
      value:"}"
    }
  ],
});
#endregion
#region Test case for simple hexadecimal number tokenization
run_tokenize_test("Test hexadecimal number tokenization", "$FFFFFFFF", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"$FFFFFFFF",
      line:1.0,
      column:1.0,
      value:4294967295.0
    }
  ],
});
#endregion
#region Test case for mixed tokens involving a hexadecimal number
run_tokenize_test("Test hexadecimal number mixed tokens", "$Fg=1", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"$F",
      line:1.0,
      column:1.0,
      value:15.0
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"g",
      line:1.0,
      column:3.0,
      value:"g"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"=",
      line:1.0,
      column:4.0,
      value:"="
    },
    {
      type: __GMLC_TokenType.Number,
      name:"1",
      line:1.0,
      column:5.0,
      value:1.0
    }
  ],
});
#endregion
#region Test case for a long hexadecimal number tokenization
run_tokenize_test("Test hexadecimal number <number> tokenization", "0xF", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0xF",
      line:1.0,
      column:1.0,
      value:15.0
    }
  ],
});
run_tokenize_test("Test hexadecimal number <number> tokenization", "0xFFFFFFF", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0xFFFFFFF",
      line:1.0,
      column:1.0,
      value:268435455.0
    }
  ],
});
run_tokenize_test("Test hexadecimal number <int64> tokenization", "$FFFFFFFF",
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"$FFFFFFFF",
      line:1.0,
      column:1.0,
      value:$FFFFFFFF
    }
  ],
});
run_tokenize_test("Test hexadecimal number <int64> tokenization", "0xFFFFFFFFFFFFFFF", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0xFFFFFFFFFFFFFFF",
      line:1.0,
      column:1.0,
      value:0xFFFFFFFFFFFFFFF
    }
  ],
});
#endregion
#region Test case for simple binary number tokenization
run_tokenize_test("Test binary number <number> tokenization", "0b1",
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0b1",
      line:1.0,
      column:1.0,
      value:1.0
    }
  ],
});
run_tokenize_test("Test binary number <number> tokenization", "0b1111111111111111111111111111111", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0b1111111111111111111111111111111",
      line:1.0,
      column:1.0,
      value:2147483647.0
    }
  ],
});
run_tokenize_test("Test binary number <int64> tokenization", "0b11111111111111111111111111111111", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0b11111111111111111111111111111111",
      line:1.0,
      column:1.0,
      value:0b11111111111111111111111111111111
    }
  ],
});
run_tokenize_test("Test binary number <int64> tokenization", "0b11111111111111111111111111111111111111111111111111111111111111", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0b11111111111111111111111111111111111111111111111111111111111111",
      line:1.0,
      column:1.0,
      value:0b11111111111111111111111111111111111111111111111111111111111111
    }
  ],
});
#endregion
#region Test case for binary number tokenization with mixed tokens
run_tokenize_test("Test binary number tokenization", "0b1111a=2", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"0b1111",
      line:1.0,
      column:1.0,
      value:15.0
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"a",
      line:1.0,
      column:7.0,
      value:"a"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"=",
      line:1.0,
      column:8.0,
      value:"="
    },
    {
      type: __GMLC_TokenType.Number,
      name:"2",
      line:1.0,
      column:9.0,
      value:2.0
    }
  ],
});
#endregion
#region Test case for recognizing a function identifier token
run_tokenize_test("Test Function Identifier tokenization", "animcurve_get_channel", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Function,
      name:"animcurve_get_channel",
      line:1.0,
      column:1.0,
      value:845.0
    }
  ],
});
#endregion
#region Test case for recognizing a constant identifier token
run_tokenize_test("Test Constant Identifier tokenization", "c_red", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Number,
      name:"c_red",
      line:1.0,
      column:1.0,
      value:255.0
    }
  ],
});
#endregion
#region Test case for simple macro definition
run_tokenize_test("Test simple macro tokenization", "#macro TOTAL_WEAPONS 10", 
{
  tokens:[
    {
      type: __GMLC_TokenType.Operator,
      name:"#",
      line:1.0,
      column:1.0,
      value:"#"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"macro",
      line:1.0,
      column:2.0,
      value:"macro"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"TOTAL_WEAPONS",
      line:1.0,
      column:8.0,
      value:"TOTAL_WEAPONS"
    },
    {
      type: __GMLC_TokenType.Number,
      name:"10",
      line:1.0,
      column:22.0,
      value:10.0
    }
  ],
});
#endregion
#region Test case for macro with a complex expression
run_tokenize_test("Test macro with expression tokenization", "#macro COL make_colour_hsv(irandom(255), 255, 255)",{
  tokens:[
    {
      type: __GMLC_TokenType.Operator,
      name:"#",
      line:1.0,
      column:1.0,
      value:"#"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"macro",
      line:1.0,
      column:2.0,
      value:"macro"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"COL",
      line:1.0,
      column:8.0,
      value:"COL"
    },
    {
      type: __GMLC_TokenType.Function,
      name:"make_colour_hsv",
      line:1.0,
      column:12.0,
      value:402.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"(",
      line:1.0,
      column:27.0,
      value:"("
    },
    {
      type: __GMLC_TokenType.Function,
      name:"irandom",
      line:1.0,
      column:28.0,
      value:219.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"(",
      line:1.0,
      column:35.0,
      value:"("
    },
    {
      type: __GMLC_TokenType.Number,
      name:"255",
      line:1.0,
      column:36.0,
      value:255.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:")",
      line:1.0,
      column:39.0,
      value:")"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:",",
      line:1.0,
      column:40.0,
      value:","
    },
    {
      type: __GMLC_TokenType.Number,
      name:"255",
      line:1.0,
      column:42.0,
      value:255.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:",",
      line:1.0,
      column:45.0,
      value:","
    },
    {
      type: __GMLC_TokenType.Number,
      name:"255",
      line:1.0,
      column:47.0,
      value:255.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:")",
      line:1.0,
      column:50.0,
      value:")"
    }
  ],
});
#endregion
#region Test case for multi-line macro definition
run_tokenize_test("Test multi-line macro tokenization", @'#macro HELLO log("Hello" + \
string(player_name) + \
", how are you today?")',
{
  tokens:[
    {
      type: __GMLC_TokenType.Operator,
      name:"#",
      line:1.0,
      column:1.0,
      value:"#"
    },
    {
      type: __GMLC_TokenType.Keyword,
      name:"macro",
      line:1.0,
      column:2.0,
      value:"macro"
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"HELLO",
      line:1.0,
      column:8.0,
      value:"HELLO"
    },
    {
      type: __GMLC_TokenType.Function,
      name:"show_debug_message",
      line:1.0,
      column:14.0,
      value:1146.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"(",
      line:1.0,
      column:32.0,
      value:"("
    },
    {
      type: __GMLC_TokenType.String,
      name:"\"Hello\"",
      line:1.0,
      column:33.0,
      value:"Hello"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"+",
      line:1.0,
      column:41.0,
      value:"+"
    },
    {
      type: __GMLC_TokenType.EscapeOperator,
      name:"\\",
      line:1.0,
      column:43.0,
      value:"\\"
    },
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:1.0,
      column:45.0,
      value:"\n"
    },
    {
      type: __GMLC_TokenType.Function,
      name:"string",
      line:2.0,
      column:1.0,
      value:264.0
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:"(",
      line:2.0,
      column:7.0,
      value:"("
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"player_name",
      line:2.0,
      column:8.0,
      value:"player_name"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:")",
      line:2.0,
      column:19.0,
      value:")"
    },
    {
      type: __GMLC_TokenType.Operator,
      name:"+",
      line:2.0,
      column:21.0,
      value:"+"
    },
    {
      type: __GMLC_TokenType.EscapeOperator,
      name:"\\",
      line:2.0,
      column:23.0,
      value:"\\"
    },
    {
      type: __GMLC_TokenType.Whitespace,
      name:"\n",
      line:2.0,
      column:25.0,
      value:"\n"
    },
    {
      type: __GMLC_TokenType.String,
      name:"\", how are you today?\"",
      line:3.0,
      column:1.0,
      value:", how are you today?"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:")",
      line:3.0,
      column:23.0,
      value:")"
    }
  ],
});
#endregion
#region Test case for using an enum identifier
run_tokenize_test("Test Enum Identifier tokenization", "AudioLFOType.Triangle",
{
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"AudioLFOType",
      line:1.0,
      column:1.0,
      value:"AudioLFOType"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:".",
      line:1.0,
      column:13.0,
      value:"."
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"Triangle",
      line:1.0,
      column:14.0,
      value:"Triangle"
    }
  ],
});
#endregion
#region Test case for a complex template string with expressions embedded
//run_tokenize_test("Test String Template tokenization", "$\"This is a {variable} with an expression {funcCall()} included\"", [
//	{type: "TemplateString", name:"$\"This is a {variable} with an expression {funcCall()} included\"", value: [
//		{type: "TemplateLiteral", value: "This is a ", line: 1, column: 3},
//		{type: "TemplateExpression", value: "variable", line: 1, column: 15},
//		{type: "TemplateLiteral", value: " with an expression ", line: 1, column: 25},
//		{type: "TemplateExpression", value: "funcCall()", line: 1, column: 45},
//		{type: "TemplateLiteral", value: " included", line: 1, column: 57}
//	], line: 1, column: 1}
//]);
#endregion
#region Test case for Illegal
// Test case for Unicode characters in identifiers
run_tokenize_test("Test Unicode identifiers", "变量",
{
  tokens:[
    {
      type: __GMLC_TokenType.Illegal,
      name:"变",
      line:1.0,
      column:1.0,
      value:"Object: {<OBJ>} Event: {<EVENT>} at line 1 : invalid token 变"
    },
    {
      type: __GMLC_TokenType.Illegal,
      name:"量",
      line:1.0,
      column:2.0,
      value:"Object: {<OBJ>} Event: {<EVENT>} at line 1 : invalid token 量"
    }
  ],
});
// Test case for incomplete tokens
run_tokenize_test("Test incomplete tokens", "\"Hello 0x /*",
{
  tokens:[
    {
      type: __GMLC_TokenType.Illegal,
      name:"\"Hello 0x \/*",
      line:1.0,
      column:1.0,
      value:"Object: {<OBJ>} Event: {<EVENT>} at line 1 : Error parsing string literal - found newline within string"
    }
  ],
});
#endregion

log("\n\n\n")
}
//run_all_tokenize_test();
#endregion

#region PreProcessor Tests
function run_preprocessor_test(description, input, expected) {
	log($"Attempting Pre Processor Test :: {description}")
	
	var tokenizer = new GML_Tokenizer();
	tokenizer.initialize(input);
	var program = tokenizer.parseAll();
	
	var preprocessor = new GML_PreProcessor();
	preprocessor.initialize(program);
	var program = preprocessor.parseAll();
	
	__compare_results(description, program, expected);
}
function run_all_preprocessor_test() {
log("~~~~~ PreProcessor Unit Tests ~~~~~\n")
#region Test 1: Single Value Macro
run_preprocessor_test("Single Value Macro",
@'#macro TOTAL_WEAPONS 10

TOTAL_WEAPONS',
{
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"TOTAL_WEAPONS",
      line:3.0,
      column:1.0,
      value:"TOTAL_WEAPONS"
    }
  ],
  MacroVar:{
    TOTAL_WEAPONS:[
      {
        type: __GMLC_TokenType.Number,
        name:"10",
        line:1.0,
        column:22.0,
        value:10.0
      }
    ]
  },
  MacroVarNames:[
    "TOTAL_WEAPONS"
  ]
});
#endregion
#region Test 2: Statement Macro
run_preprocessor_test("Statement Macro",
@'#macro INIT_LOGIC log("Starting")

INIT_LOGIC',
{
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"INIT_LOGIC",
      line:3.0,
      column:1.0,
      value:"INIT_LOGIC"
    }
  ],
  MacroVar:{
    INIT_LOGIC:[
      {
        type: __GMLC_TokenType.Function,
        name:"log",
        line:1.0,
        column:19.0,
        value: log
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:"(",
        line:1.0,
        column:22.0,
        value:"("
      },
      {
        type: __GMLC_TokenType.String,
        name:"\"Starting\"",
        line:1.0,
        column:23.0,
        value:"Starting"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:")",
        line:1.0,
        column:33.0,
        value:")"
      }
    ]
  },
  MacroVarNames:[
    "INIT_LOGIC"
  ]
});
#endregion
#region Test 3: Multiline Macro
run_preprocessor_test("Multiline Macro",
@'#macro HELLO log("Hello" + \
string(player_name) + \
", how are you today?");

HELLO',
{
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"HELLO",
      line:5.0,
      column:1.0,
      value:"HELLO"
    }
  ],
  MacroVar:{
    HELLO:[
      {
        type: __GMLC_TokenType.Function,
        name:"show_debug_message",
        line:1.0,
        column:14.0,
        value:1146.0
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:"(",
        line:1.0,
        column:32.0,
        value:"("
      },
      {
        type: __GMLC_TokenType.String,
        name:"\"Hello\"",
        line:1.0,
        column:33.0,
        value:"Hello"
      },
      {
        type: __GMLC_TokenType.Operator,
        name:"+",
        line:1.0,
        column:41.0,
        value:"+"
      },
      {
        type: __GMLC_TokenType.Function,
        name:"string",
        line:2.0,
        column:1.0,
        value:264.0
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:"(",
        line:2.0,
        column:7.0,
        value:"("
      },
      {
        type: __GMLC_TokenType.Identifier,
        name:"player_name",
        line:2.0,
        column:8.0,
        value:"player_name"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:")",
        line:2.0,
        column:19.0,
        value:")"
      },
      {
        type: __GMLC_TokenType.Operator,
        name:"+",
        line:2.0,
        column:21.0,
        value:"+"
      },
      {
        type: __GMLC_TokenType.String,
        name:"\", how are you today?\"",
        line:3.0,
        column:1.0,
        value:", how are you today?"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:")",
        line:3.0,
        column:23.0,
        value:")"
      }
    ]
  },
  MacroVarNames:[
    "HELLO"
  ]
});
#endregion
#region Test 4: Basic Enum
run_preprocessor_test("Basic Enum",
@'enum RAINBOW {
    RED,
    ORANGE,
    YELLOW,
    GREEN,
    BLUE,
    INDIGO,
    VIOLET
}

RAINBOW.GREEN',
{
  EnumVar:{
    RAINBOW:{
      RED:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:2.0,
          column:8.0,
          value:0.0
        }
      ],
      ORANGE:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:3.0,
          column:11.0,
          value:1.0
        }
      ],
      YELLOW:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:4.0,
          column:11.0,
          value:2.0
        }
      ],
      GREEN:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:5.0,
          column:10.0,
          value:3.0
        }
      ],
      BLUE:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:6.0,
          column:9.0,
          value:4.0
        }
      ],
      INDIGO:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:7.0,
          column:11.0,
          value:5.0
        }
      ],
      VIOLET:[
        {
          type: __GMLC_TokenType.Number,
          name:"\n",
          line:8.0,
          column:12.0,
          value:6.0
        }
      ]
    }
  },
  EnumVarNames:{
    RAINBOW:[
      "RED",
      "ORANGE",
      "YELLOW",
      "GREEN",
      "BLUE",
      "INDIGO",
      "VIOLET"
    ]
  },
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"RAINBOW",
      line:11.0,
      column:1.0,
      value:"RAINBOW"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:".",
      line:11.0,
      column:8.0,
      value:"."
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"GREEN",
      line:11.0,
      column:9.0,
      value:"GREEN"
    }
  ],
});
#endregion
#region Test 5: Enums Built with Other Enums
run_preprocessor_test("Enums Built with Other Enums",
@'enum BASE {
    FIRST = 1,
    SECOND
}

enum DERIVED {
    NEXT = BASE.FIRST + 3
}

DERIVED.NEXT',
{
  EnumVar:{
    BASE:{
      FIRST:[
        {
          type: __GMLC_TokenType.Number,
          name:"1",
          line:2.0,
          column:13.0,
          value:1.0
        }
      ],
      SECOND:[
        {
          type: __GMLC_TokenType.Number,
          name:"\n",
          line:3.0,
          column:12.0,
          value:1.0
        }
      ]
    },
    DERIVED:{
      NEXT:[
        {
          type: __GMLC_TokenType.Identifier,
          name:"BASE",
          line:7.0,
          column:12.0,
          value:"BASE"
        },
        {
          type: __GMLC_TokenType.Punctuation,
          name:".",
          line:7.0,
          column:16.0,
          value:"."
        },
        {
          type: __GMLC_TokenType.Identifier,
          name:"FIRST",
          line:7.0,
          column:17.0,
          value:"FIRST"
        },
        {
          type: __GMLC_TokenType.Operator,
          name:"+",
          line:7.0,
          column:23.0,
          value:"+"
        },
        {
          type: __GMLC_TokenType.Number,
          name:"3",
          line:7.0,
          column:25.0,
          value:3.0
        }
      ]
    }
  },
  EnumVarNames:{
    BASE:[
      "FIRST",
      "SECOND"
    ],
    DERIVED:[
      "NEXT"
    ]
  },
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"DERIVED",
      line:10.0,
      column:1.0,
      value:"DERIVED"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:".",
      line:10.0,
      column:8.0,
      value:"."
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"NEXT",
      line:10.0,
      column:9.0,
      value:"NEXT"
    }
  ],
});
#endregion
#region Test 6: Enum Using a Macro Value
run_preprocessor_test("Enum Using a Macro Value",
@'#macro BASE_VALUE 10

enum VALUES {
    ONE = BASE_VALUE
}

VALUES.ONE',
{
  EnumVar:{
    VALUES:{
      ONE:[
        {
          type: __GMLC_TokenType.Identifier,
          name:"BASE_VALUE",
          line:4.0,
          column:11.0,
          value:"BASE_VALUE"
        }
      ]
    }
  },
  EnumVarNames:{
    VALUES:[
      "ONE"
    ]
  },
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"VALUES",
      line:7.0,
      column:1.0,
      value:"VALUES"
    },
    {
      type: __GMLC_TokenType.Punctuation,
      name:".",
      line:7.0,
      column:7.0,
      value:"."
    },
    {
      type: __GMLC_TokenType.Identifier,
      name:"ONE",
      line:7.0,
      column:8.0,
      value:"ONE"
    }
  ],
  MacroVar:{
    BASE_VALUE:[
      {
        type: __GMLC_TokenType.Number,
        name:"10",
        line:1.0,
        column:19.0,
        value:10.0
      }
    ]
  },
  MacroVarNames:[
    "BASE_VALUE"
  ]
});
#endregion
#region Test 7: Macro Containing Enum
run_preprocessor_test("Macro Containing Enum",
@'#macro TEST foo.bar
enum foo {
    bar
}

TEST',
{
  EnumVar:{
    foo:{
      bar:[
        {
          type: __GMLC_TokenType.Number,
          name:"\n",
          line:3.0,
          column:9.0,
          value:0.0
        }
      ]
    }
  },
  EnumVarNames:{
    foo:[
      "bar"
    ]
  },
  tokens:[
    {
      type: __GMLC_TokenType.Identifier,
      name:"TEST",
      line:6.0,
      column:1.0,
      value:"TEST"
    }
  ],
  MacroVar:{
    TEST:[
      {
        type: __GMLC_TokenType.Identifier,
        name:"foo",
        line:1.0,
        column:13.0,
        value:"foo"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:".",
        line:1.0,
        column:16.0,
        value:"."
      },
      {
        type: __GMLC_TokenType.Identifier,
        name:"bar",
        line:1.0,
        column:17.0,
        value:"bar"
      }
    ]
  },
  MacroVarNames:[
    "TEST"
  ]
});
#endregion

// Additional tests for Multiline Macro, Basic Enum, Enums Built with Other Enums,
// and Enum Using a Macro Value would follow a similar structure.

log("\n\n\n")
}
//run_all_preprocessor_test();
#endregion

#region Parse unit tests
function run_parse_test(description, input, expected) {
	log($"Attempting Parser Test :: {description}")
	
	var tokenizer = new GML_Tokenizer();
	tokenizer.initialize(input);
	var tokens = tokenizer.parseAll();
	
	var preprocessor = new GML_PreProcessor();
	preprocessor.initialize(tokens);
	var tokens = preprocessor.parseAll();
	
	var parser = new GML_Parser();
	parser.initialize(tokens);
	var ast = parser.parseAll();
	
	__compare_results(description, ast, expected);
}
function run_all_parser_tests() {
log("~~~~~ Parser Unit Tests ~~~~~\n")
#region Macros and Enums
#region Test 1: Single Value Macro
run_parse_test("Single Value Macro",
@'#macro TOTAL_WEAPONS 10

TOTAL_WEAPONS',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.Literal",
      value:10.0,
      line:1.0,
      scope:"ScopeType.CONST"
    }
  ],
  MacroVar:{
    TOTAL_WEAPONS:[
      {
        type: __GMLC_TokenType.Number,
        name:"10",
        line:1.0,
        lineString:"#macro TOTAL_WEAPONS 10",
        column:22.0,
        value:10.0
      }
    ]
  },
  MacroVarNames:[
    "TOTAL_WEAPONS"
  ],
});
#endregion
#region Test 2: Statement Macro
run_parse_test("Statement Macro",
@'#macro INIT_LOGIC log("Starting")

INIT_LOGIC',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.CallExpression",
      line:1.0,
      callee:{
        type:"__GMLC_NodeType.Function",
        value: log,
        name:"log",
        line:1.0
      },
      arguments:[
        {
          type:"__GMLC_NodeType.Literal",
          value:"Starting",
          line:1.0,
          scope:"ScopeType.CONST"
        }
      ]
    }
  ],
  MacroVar:{
    INIT_LOGIC:[
      {
        type: __GMLC_TokenType.Function,
        name:"log",
        line:1.0,
        lineString:"#macro INIT_LOGIC log(\"Starting\")",
        column:19.0,
        value: log
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:"(",
        line:1.0,
        lineString:"#macro INIT_LOGIC log(\"Starting\")",
        column:22.0,
        value:"("
      },
      {
        type: __GMLC_TokenType.String,
        name:"\"Starting\"",
        line:1.0,
        lineString:"#macro INIT_LOGIC log(\"Starting\")",
        column:23.0,
        value:"Starting"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:")",
        line:1.0,
        lineString:"#macro INIT_LOGIC log(\"Starting\")",
        column:33.0,
        value:")"
      }
    ]
  },
  MacroVarNames:[
    "INIT_LOGIC"
  ],
});
#endregion
#region Test 3: Multiline Macro
run_parse_test("Multiline Macro",
@'#macro HELLO log("Hello" + \
string(player_name) + \
", how are you today?");

HELLO',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.CallExpression",
      line:1.0,
      callee:{
        type:"__GMLC_NodeType.Function",
        value:1146.0,
        name:"show_debug_message",
        line:1.0
      },
      arguments:[
        {
          type:"__GMLC_NodeType.BinaryExpression",
          line:2.0,
          operator:"+",
          left:{
            type:"__GMLC_NodeType.BinaryExpression",
            line:1.0,
            operator:"+",
            left:{
              type:"__GMLC_NodeType.Literal",
              value:"Hello",
              line:1.0,
              scope:"ScopeType.CONST"
            },
            right:{
              type:"__GMLC_NodeType.CallExpression",
              line:2.0,
              callee:{
                type:"__GMLC_NodeType.Function",
                value:264.0,
                name:"string",
                line:2.0
              },
              arguments:[
                {
                  type:"__GMLC_NodeType.Identifier",
                  value:"player_name",
                  line:2.0,
                }
              ]
            }
          },
          right:{
            type:"__GMLC_NodeType.Literal",
            value:", how are you today?",
            line:3.0,
            scope:"ScopeType.CONST"
          }
        }
      ]
    }
  ],
  MacroVar:{
    HELLO:[
      {
        type: __GMLC_TokenType.Function,
        name:"show_debug_message",
        line:1.0,
        lineString:"#macro HELLO log(\"Hello\" + \\",
        column:14.0,
        value:1146.0
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:"(",
        line:1.0,
        lineString:"#macro HELLO log(\"Hello\" + \\",
        column:32.0,
        value:"("
      },
      {
        type: __GMLC_TokenType.String,
        name:"\"Hello\"",
        line:1.0,
        lineString:"#macro HELLO log(\"Hello\" + \\",
        column:33.0,
        value:"Hello"
      },
      {
        type: __GMLC_TokenType.Operator,
        name:"+",
        line:1.0,
        lineString:"#macro HELLO log(\"Hello\" + \\",
        column:41.0,
        value:"+"
      },
      {
        type: __GMLC_TokenType.Function,
        name:"string",
        line:2.0,
        lineString:"string(player_name) + \\",
        column:1.0,
        value:264.0
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:"(",
        line:2.0,
        lineString:"string(player_name) + \\",
        column:7.0,
        value:"("
      },
      {
        type: __GMLC_TokenType.Identifier,
        name:"player_name",
        line:2.0,
        lineString:"string(player_name) + \\",
        column:8.0,
        value:"player_name"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:")",
        line:2.0,
        lineString:"string(player_name) + \\",
        column:19.0,
        value:")"
      },
      {
        type: __GMLC_TokenType.Operator,
        name:"+",
        line:2.0,
        lineString:"string(player_name) + \\",
        column:21.0,
        value:"+"
      },
      {
        type: __GMLC_TokenType.String,
        name:"\", how are you today?\"",
        line:3.0,
        lineString:"\", how are you today?\");",
        column:1.0,
        value:", how are you today?"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:")",
        line:3.0,
        lineString:"\", how are you today?\");",
        column:23.0,
        value:")"
      }
    ]
  },
  MacroVarNames:[
    "HELLO"
  ],
});
#endregion
#region Test 4: Basic Enum
run_parse_test("Basic Enum",
@'enum RAINBOW {
    RED,
    ORANGE,
    YELLOW,
    GREEN,
    BLUE,
    INDIGO,
    VIOLET
}

RAINBOW.GREEN',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.Literal",
      value:3.0,
      line:5.0,
      scope:"ScopeType.CONST"
    }
  ],
  EnumVar:{
    RAINBOW:{
      YELLOW:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:4.0,
          lineString:"    YELLOW,",
          column:11.0,
          value:2.0
        }
      ],
      GREEN:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:5.0,
          lineString:"    GREEN,",
          column:10.0,
          value:3.0
        }
      ],
      BLUE:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:6.0,
          lineString:"    BLUE,",
          column:9.0,
          value:4.0
        }
      ],
      INDIGO:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:7.0,
          lineString:"    INDIGO,",
          column:11.0,
          value:5.0
        }
      ],
      VIOLET:[
        {
          type: __GMLC_TokenType.Number,
          name:"\n",
          line:8.0,
          lineString:"    VIOLET",
          column:12.0,
          value:6.0
        }
      ],
      RED:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:2.0,
          lineString:"    RED,",
          column:8.0,
          value:0.0
        }
      ],
      ORANGE:[
        {
          type: __GMLC_TokenType.Number,
          name:",",
          line:3.0,
          lineString:"    ORANGE,",
          column:11.0,
          value:1.0
        }
      ]
    }
  },
  EnumVarNames:{
    RAINBOW:[
      "RED",
      "ORANGE",
      "YELLOW",
      "GREEN",
      "BLUE",
      "INDIGO",
      "VIOLET"
    ]
  },
});
#endregion
#region Test 5: Enums Built with Other Enums
run_parse_test("Enums Built with Other Enums",
@'enum BASE {
    FIRST = 1,
    SECOND
}

enum DERIVED {
    NEXT = BASE.FIRST + 3
}

DERIVED.NEXT',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.BinaryExpression",
      line:7.0,
      operator:"+",
      left:{
        type:"__GMLC_NodeType.Literal",
        value:1.0,
        line:2.0,
        scope:"ScopeType.CONST"
      },
      right:{
        type:"__GMLC_NodeType.Literal",
        value:3.0,
        line:7.0,
        scope:"ScopeType.CONST"
      }
    }
  ],
  EnumVar:{
    DERIVED:{
      NEXT:[
        {
          type: __GMLC_TokenType.Identifier,
          name:"BASE",
          line:7.0,
          lineString:"    NEXT = BASE.FIRST + 3",
          column:12.0,
          value:"BASE"
        },
        {
          type: __GMLC_TokenType.Punctuation,
          name:".",
          line:7.0,
          lineString:"    NEXT = BASE.FIRST + 3",
          column:16.0,
          value:"."
        },
        {
          type: __GMLC_TokenType.Identifier,
          name:"FIRST",
          line:7.0,
          lineString:"    NEXT = BASE.FIRST + 3",
          column:17.0,
          value:"FIRST"
        },
        {
          type: __GMLC_TokenType.Operator,
          name:"+",
          line:7.0,
          lineString:"    NEXT = BASE.FIRST + 3",
          column:23.0,
          value:"+"
        },
        {
          type: __GMLC_TokenType.Number,
          name:"3",
          line:7.0,
          lineString:"    NEXT = BASE.FIRST + 3",
          column:25.0,
          value:3.0
        }
      ]
    },
    BASE:{
      FIRST:[
        {
          type: __GMLC_TokenType.Number,
          name:"1",
          line:2.0,
          lineString:"    FIRST = 1,",
          column:13.0,
          value:1.0
        }
      ],
      SECOND:[
        {
          type: __GMLC_TokenType.Number,
          name:"\n",
          line:3.0,
          lineString:"    SECOND",
          column:12.0,
          value:1.0
        }
      ]
    }
  },
  EnumVarNames:{
    DERIVED:[
      "NEXT"
    ],
    BASE:[
      "FIRST",
      "SECOND"
    ]
  },
});
#endregion
#region Test 6: Enum Using a Macro Value
run_parse_test("Enum Using a Macro Value",
@'#macro BASE_VALUE 10

enum VALUES {
    ONE = BASE_VALUE
}

VALUES.ONE',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.Literal",
      value:10.0,
      line:1.0,
      scope:"ScopeType.CONST"
    }
  ],
  MacroVar:{
    BASE_VALUE:[
      {
        type: __GMLC_TokenType.Number,
        name:"10",
        line:1.0,
        lineString:"#macro BASE_VALUE 10",
        column:19.0,
        value:10.0
      }
    ]
  },
  MacroVarNames:[
    "BASE_VALUE"
  ],
  EnumVar:{
    VALUES:{
      ONE:[
        {
          type: __GMLC_TokenType.Identifier,
          name:"BASE_VALUE",
          line:4.0,
          lineString:"    ONE = BASE_VALUE",
          column:11.0,
          value:"BASE_VALUE"
        }
      ]
    }
  },
  EnumVarNames:{
    VALUES:[
      "ONE"
    ]
  },
});
#endregion
#region Test 7: Macro Containing Enum
run_parse_test("Macro Containing Enum",
@'#macro TEST foo.bar
enum foo {
    bar
}

TEST',
{
  type:"__GMLC_NodeType.Script",
  statements:[
    {
      type:"__GMLC_NodeType.Literal",
      value:0.0,
      line:3.0,
      scope:"ScopeType.CONST"
    }
  ],
  MacroVar:{
    TEST:[
      {
        type: __GMLC_TokenType.Identifier,
        name:"foo",
        line:1.0,
        lineString:"#macro TEST foo.bar",
        column:13.0,
        value:"foo"
      },
      {
        type: __GMLC_TokenType.Punctuation,
        name:".",
        line:1.0,
        lineString:"#macro TEST foo.bar",
        column:16.0,
        value:"."
      },
      {
        type: __GMLC_TokenType.Identifier,
        name:"bar",
        line:1.0,
        lineString:"#macro TEST foo.bar",
        column:17.0,
        value:"bar"
      }
    ]
  },
  MacroVarNames:[
    "TEST"
  ],
  EnumVar:{
    foo:{
      bar:[
        {
          type: __GMLC_TokenType.Number,
          name:"\n",
          line:3.0,
          lineString:"    bar",
          column:9.0,
          value:0.0
        }
      ]
    }
  },
  EnumVarNames:{
    foo:[
      "bar"
    ]
  },
});
#endregion
#endregion
#region Keyword Statements
#region Expression statement
run_parse_test("1 + 1;",
@'1+1',
{
	type: __GMLC_NodeType.Script,
	statements:[
	{
		operator:"+",
		type: __GMLC_NodeType.BinaryExpression,
		left:{
			type: __GMLC_NodeType.Literal,
			value:1.0
		},
		right:{
			type: __GMLC_NodeType.Literal,
			value:1.0
		}
	}]
}
);
#endregion
#region Postfix Addition
run_parse_test("x++",
@'x++',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.UpdateExpression,
      line:1.0,
      prefix:false,
      operator:"++",
      expr:{
        type: __GMLC_NodeType.Identifier,
        value:"x",
        line:1.0,
        scope: undefined
      }
    }
  ],
});
#endregion
#region Expression statement
run_parse_test("y = 1;",
@'y = 1;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.AssignmentExpression,
      line:1.0,
      operator:"=",
      left:{
        type: __GMLC_NodeType.Identifier,
        value:"y",
        line:1.0,
        scope: undefined
      },
      right:{
        type: __GMLC_NodeType.Literal,
        value:1.0,
        line:1.0,
        scope: ScopeType.CONST
      }
    }
  ],
});
#endregion
#region Expression statement
run_parse_test("h = a + b * c - (d & e % f div g)",
@'h = a + b * c - (d & e % f div g)',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.AssignmentExpression,
      line:1.0,
      operator:"=",
      left:{
        type: __GMLC_NodeType.Identifier,
        value:"h",
        line:1.0,
        scope: undefined
      },
      right:{
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:"-",
        left:{
          type: __GMLC_NodeType.BinaryExpression,
          line:1.0,
          operator:"+",
          left:{
            type: __GMLC_NodeType.Identifier,
            value:"a",
            line:1.0,
            scope: undefined
          },
          right:{
            type: __GMLC_NodeType.BinaryExpression,
            line:1.0,
            operator:"*",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"b",
              line:1.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Identifier,
              value:"c",
              line:1.0,
              scope: undefined
            }
          }
        },
        right:{
          type: __GMLC_NodeType.BinaryExpression,
          line:1.0,
          operator:"&",
          left:{
            type: __GMLC_NodeType.Identifier,
            value:"d",
            line:1.0,
            scope: undefined
          },
          right:{
            type: __GMLC_NodeType.BinaryExpression,
            line:1.0,
            operator:"div",
            left:{
              type: __GMLC_NodeType.BinaryExpression,
              line:1.0,
              operator:"mod",
              left:{
                type: __GMLC_NodeType.Identifier,
                value:"e",
                line:1.0,
                scope: undefined
              },
              right:{
                type: __GMLC_NodeType.Identifier,
                value:"f",
                line:1.0,
                scope: undefined
              }
            },
            right:{
              type: __GMLC_NodeType.Identifier,
              value:"g",
              line:1.0,
              scope: undefined
            }
          }
        }
      }
    }
  ],
});
#endregion
#region If Statement Test
run_parse_test("if statement",
@'if (x > 0) {
	y = 1;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.IfStatement,
      condition:{
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:">",
        left:{
          type: __GMLC_NodeType.Identifier,
          value:"x",
          line:1.0,
          scope: undefined
        },
        right:{
          type: __GMLC_NodeType.Literal,
          value:0.0,
          line:1.0,
          scope: ScopeType.CONST
        }
      },
      line:1.0,
      consequent:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.AssignmentExpression,
            line:2.0,
            operator:"=",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"y",
              line:2.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Literal,
              value:1.0,
              line:2.0,
              scope: ScopeType.CONST
            }
          }
        ]
      },
      alternate: undefined
    }
  ],
});
#endregion
#region If/Else Statement Test
run_parse_test("if/else statement",
@'if (x > 0) {
	y = 1;
} else {
	y = 2;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.IfStatement,
      condition:{
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:">",
        left:{
          type: __GMLC_NodeType.Identifier,
          value:"x",
          line:1.0,
          scope: undefined
        },
        right:{
          type: __GMLC_NodeType.Literal,
          value:0.0,
          line:1.0,
          scope: ScopeType.CONST
        }
      },
      line:1.0,
      consequent:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.AssignmentExpression,
            line:2.0,
            operator:"=",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"y",
              line:2.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Literal,
              value:1.0,
              line:2.0,
              scope: ScopeType.CONST
            }
          }
        ]
      },
      alternate:{
        type: __GMLC_NodeType.BlockStatement,
        line:3.0,
        statements:[
          {
            type: __GMLC_NodeType.AssignmentExpression,
            line:4.0,
            operator:"=",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"y",
              line:4.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Literal,
              value:2.0,
              line:4.0,
              scope: ScopeType.CONST
            }
          }
        ]
      }
    }
  ],
});
#endregion
#region For Statement Test
run_parse_test("for statement",
@'for (var i = 0; i < 10; i++) {
	print(i);
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.ForStatement,
      condition:{
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:10.0,
          scope: ScopeType.CONST
        },
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:"<",
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"i",
          scope: ScopeType.LOCAL
        }
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:2.0,
            arguments:[
              {
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"i",
                scope: ScopeType.LOCAL
              }
            ],
            callee:{
              type: __GMLC_NodeType.Identifier,
              line:2.0,
              value:"print",
            }
          }
        ]
      },
      line:1.0,
      initialization:{
        type: __GMLC_NodeType.VariableDeclarationList,
        line:1.0,
        statements:{
          type: __GMLC_NodeType.BlockStatement,
          line:1.0,
          statements:[
            {
              expr:{
                type: __GMLC_NodeType.Literal,
                line:1.0,
                value:0.0,
                scope: ScopeType.CONST
              },
              type: __GMLC_NodeType.VariableDeclaration,
              line:1.0,
              identifier:"i",
              scope: ScopeType.LOCAL
            }
          ]
        }
      },
      increment:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"i",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.UpdateExpression,
        line:1.0,
        prefix:false,
        operator:"++"
      }
    }
  ],
  LocalVarNames:[
    "i"
  ]
}
);
#endregion
#region While Statement Test
run_parse_test("while statement",
@'while (x < 10) {
	x += 1;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.WhileStatement,
      condition:{
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:"<",
        left:{
          type: __GMLC_NodeType.Identifier,
          value:"x",
          line:1.0,
          scope: undefined
        },
        right:{
          type: __GMLC_NodeType.Literal,
          value:10.0,
          line:1.0,
          scope: ScopeType.CONST
        }
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.AssignmentExpression,
            line:2.0,
            operator:"+=",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"x",
              line:2.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Literal,
              value:1.0,
              line:2.0,
              scope: ScopeType.CONST
            }
          }
        ]
      },
      line:1.0
    }
  ],
}
);
#endregion
#region Try-Catch-Finally Test
run_parse_test("try-catch-finally statement",
@'try {
	riskyOperation();
}
catch (e) {
	handleError(e);
}
finally {
	cleanup();
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.TryStatement,
      tryBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:2.0,
            callee:{
              type: __GMLC_NodeType.Identifier,
              value:"riskyOperation",
              line:2.0,
              scope: undefined
            },
            arguments:[
            ]
          }
        ]
      },
      exceptionVar:"e",
      line:1.0,
      catchBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:4.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:5.0,
            callee:{
              type: __GMLC_NodeType.Identifier,
              value:"handleError",
              line:5.0,
              scope: undefined
            },
            arguments:[
              {
                type: __GMLC_NodeType.Identifier,
                value:"e",
                line:5.0,
                scope: ScopeType.LOCAL
              }
            ]
          }
        ]
      },
      finallyBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:7.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:8.0,
            callee:{
              type: __GMLC_NodeType.Identifier,
              value:"cleanup",
              line:8.0,
              scope: undefined
            },
            arguments:[
            ]
          }
        ]
      }
    }
  ],
  LocalVarNames:[
    "e"
  ]
}
);
#endregion
#region Repeat Statement Test
run_parse_test("repeat statement",
@'repeat (10) {
	x += 1;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.RepeatStatement,
      condition:{
        type: __GMLC_NodeType.Literal,
        value:10.0,
        line:1.0,
        scope: ScopeType.CONST
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.AssignmentExpression,
            line:2.0,
            operator:"+=",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"x",
              line:2.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Literal,
              value:1.0,
              line:2.0,
              scope: ScopeType.CONST
            }
          }
        ]
      },
      line:1.0
    }
  ],
});
#endregion
#region Do/Until Statement Test
run_parse_test("do/until statement",
@'do {
	x += 1;
}
until (x >= 10);',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.DoUntilStatement,
      condition:{
        type: __GMLC_NodeType.BinaryExpression,
        line:4.0,
        operator:">=",
        left:{
          type: __GMLC_NodeType.Identifier,
          value:"x",
          line:4.0,
          scope: undefined
        },
        right:{
          type: __GMLC_NodeType.Literal,
          value:10.0,
          line:4.0,
          scope: ScopeType.CONST
        }
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.AssignmentExpression,
            line:2.0,
            operator:"+=",
            left:{
              type: __GMLC_NodeType.Identifier,
              value:"x",
              line:2.0,
              scope: undefined
            },
            right:{
              type: __GMLC_NodeType.Literal,
              value:1.0,
              line:2.0,
              scope: ScopeType.CONST
            }
          }
        ]
      },
      line:1.0
    }
  ],
});
#endregion
#region Switch Statement Test
run_parse_test("switch statement",
@'switch (x) {
	case 1:
		print("one");
	break;
	case 2:
		print("two");
	break;
	default:
		print("other");
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.SwitchStatement,
      line:1.0,
      switchExpression:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      cases:[
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:2.0,
            value:1.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:2.0
        },
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:5.0,
            value:2.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:5.0
        },
        {
          type: __GMLC_NodeType.CaseDefault,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:1.0
        }
      ]
    }
  ],
}
);
run_parse_test("switch statement : stacked cases",
@'switch (expr) {
	case 1:
	case 2:
		foo=12
	break
	default:
		bar=3;
	break;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.SwitchStatement,
      line:1.0,
      switchExpression:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"expr",
      },
      cases:[
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:2.0,
            value:1.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:2.0
        },
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:3.0,
            value:2.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:3.0
        },
        {
          type: __GMLC_NodeType.CaseDefault,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:1.0
        }
      ]
    }
  ],
}
);

run_parse_test("switch statement : arbitrary (unneeded) brackets",
@'switch (expr) {
	case 1:{
		_one=1;
	break}
	case 2:{
		_two=2;
	}break;
	default:
		_default=3;
	break;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.SwitchStatement,
      line:1.0,
      switchExpression:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"expr",
      },
      cases:[
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:2.0,
            value:1.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:2.0
        },
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:5.0,
            value:2.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:5.0
        },
        {
          type: __GMLC_NodeType.CaseDefault,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:1.0
        }
      ]
    }
  ],
}
);

run_parse_test("switch statement : default stacked",
@'switch (expr) {
	case 1:
	case 2:
	default:
		should = execute;
	break;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.SwitchStatement,
      line:1.0,
      switchExpression:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"expr",
      },
      cases:[
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:2.0,
            value:1.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:2.0
        },
        {
          label:{
            type: __GMLC_NodeType.Literal,
            line:3.0,
            value:2.0,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.CaseExpression,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:3.0
        },
        {
          type: __GMLC_NodeType.CaseDefault,
          codeBlock:{
            type: __GMLC_NodeType.Base,
            line:"BlockStatement"
          },
          line:1.0
        }
      ]
    }
  ],
}
);
#endregion
#region With Statement Test
run_parse_test("with statement",
@'with (obj_Player) {
	x = 100;
	y = 200;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.WithStatement,
      condition:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"obj_Player",
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            left:{
              type: __GMLC_NodeType.Identifier,
              line:2.0,
              value:"x",
            },
            type: __GMLC_NodeType.AssignmentExpression,
            right:{
              type: __GMLC_NodeType.Literal,
              line:2.0,
              value:100.0,
              scope: ScopeType.CONST
            },
            line:2.0,
            operator:"="
          },
          {
            left:{
              type: __GMLC_NodeType.Identifier,
              line:3.0,
              value:"y",
            },
            type: __GMLC_NodeType.AssignmentExpression,
            right:{
              type: __GMLC_NodeType.Literal,
              line:3.0,
              value:200.0,
              scope: ScopeType.CONST
            },
            line:3.0,
            operator:"="
          }
        ]
      },
      line:1.0
    }
  ],
}
);
#endregion
#region Mixed Test 1: If-Else with Nested For Loop
run_parse_test("if-else with nested for loop",
@'if (x > 0) {
	for (var i = 0; i < x; i++) {
		print(i);
	}
}
else {
	print("x is non-positive");
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.IfStatement,
      condition:{
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:">",
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"x",
          scope: undefined
        }
      },
      line:1.0,
      consequent:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.ForStatement,
            condition:{
              right:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"x",
                scope: undefined
              },
              type: __GMLC_NodeType.BinaryExpression,
              line:2.0,
              operator:"<",
              left:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"i",
                scope: ScopeType.LOCAL
              }
            },
            codeBlock:{
              type: __GMLC_NodeType.BlockStatement,
              line:2.0,
              statements:[
                {
                  type: __GMLC_NodeType.CallExpression,
                  line:3.0,
                  arguments:[
                    {
                      type: __GMLC_NodeType.Identifier,
                      line:3.0,
                      value:"i",
                      scope: ScopeType.LOCAL
                    }
                  ],
                  callee:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"print",
                    scope: undefined
                  }
                }
              ]
            },
            line:2.0,
            initialization:{
              type: __GMLC_NodeType.VariableDeclarationList,
              line:2.0,
              statements:{
                type: __GMLC_NodeType.BlockStatement,
                line:2.0,
                statements:[
                  {
                    expr:{
                      type: __GMLC_NodeType.Literal,
                      line:2.0,
                      value:0.0,
                      scope: ScopeType.CONST
                    },
                    type: __GMLC_NodeType.VariableDeclaration,
                    line:2.0,
                    identifier:"i",
                    scope: ScopeType.LOCAL
                  }
                ]
              }
            },
            increment:{
              expr:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"i",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.UpdateExpression,
              line:2.0,
              prefix:false,
              operator:"++"
            }
          }
        ]
      },
      alternate:{
        type: __GMLC_NodeType.BlockStatement,
        line:6.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:7.0,
            arguments:[
              {
                type: __GMLC_NodeType.Literal,
                line:7.0,
                value:"x is non-positive",
                scope: ScopeType.CONST
              }
            ],
            callee:{
              type: __GMLC_NodeType.Identifier,
              line:7.0,
              value:"print",
              scope: undefined
            }
          }
        ]
      }
    }
  ],
  LocalVarNames:[
    "i"
  ]
}
);
#endregion
#region Mixed Test 2: Switch Inside a While Loop
run_parse_test("switch inside while loop",
@'while (x < 10) {
	switch (x) {
		case 1:
			x += 2;
		break;
		default:
			x += 1;
	}
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.WhileStatement,
      condition:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"x",
        },
        type: __GMLC_NodeType.BinaryExpression,
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:10.0,
          scope: ScopeType.CONST
        },
        line:1.0,
        operator:"<"
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.SwitchStatement,
            line:2.0,
            switchExpression:{
              type: __GMLC_NodeType.Identifier,
              line:2.0,
              value:"x",
            },
            cases:[
              {
                label:{
                  type: __GMLC_NodeType.Literal,
                  line:3.0,
                  value:1.0,
                  scope: ScopeType.CONST
                },
                type: __GMLC_NodeType.CaseExpression,
                codeBlock:{
                  type: __GMLC_NodeType.Base,
                  line:"BlockStatement"
                },
                line:3.0
              },
              {
                type: __GMLC_NodeType.CaseDefault,
                codeBlock:{
                  type: __GMLC_NodeType.Base,
                  line:"BlockStatement"
                },
                line:2.0
              }
            ]
          }
        ]
      },
      line:1.0
    }
  ],
}
);
#endregion
#region Mixed Test 3: Nested If with Do-Until Loop
run_parse_test("nested if with do-until loop",
@'if (x > 0) {
	do {
		x -= 1; print(x);
	}
	until (x == 0);
}
else {
	print("x was not positive");
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.IfStatement,
      condition:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"x",
        },
        type: __GMLC_NodeType.BinaryExpression,
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        line:1.0,
        operator:">"
      },
      line:1.0,
      consequent:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.DoUntilStatement,
            condition:{
              left:{
                type: __GMLC_NodeType.Identifier,
                line:5.0,
                value:"x",
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Literal,
                line:5.0,
                value:0.0,
                scope: ScopeType.CONST
              },
              line:5.0,
              operator:"=="
            },
            codeBlock:{
              type: __GMLC_NodeType.BlockStatement,
              line:2.0,
              statements:[
                {
                  left:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"x",
                  },
                  type: __GMLC_NodeType.AssignmentExpression,
                  right:{
                    type: __GMLC_NodeType.Literal,
                    line:3.0,
                    value:1.0,
                    scope: ScopeType.CONST
                  },
                  line:3.0,
                  operator:"-="
                },
                {
                  type: __GMLC_NodeType.CallExpression,
                  line:3.0,
                  arguments:[
                    {
                      type: __GMLC_NodeType.Identifier,
                      line:3.0,
                      value:"x",
                    }
                  ],
                  callee:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"print",
                  }
                }
              ]
            },
            line:2.0
          }
        ]
      },
      alternate:{
        type: __GMLC_NodeType.BlockStatement,
        line:7.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:8.0,
            arguments:[
              {
                type: __GMLC_NodeType.Literal,
                line:8.0,
                value:"x was not positive",
                scope: ScopeType.CONST
              }
            ],
            callee:{
              type: __GMLC_NodeType.Identifier,
              line:8.0,
              value:"print",
            }
          }
        ]
      }
    }
  ],
}
);
#endregion
#region Double For Loop Test
run_parse_test("double for loop",
@'for (var i = 0; i < 5; i++) {
	for (var j = 0; j < 5; j++) {
		print(i * j);
	}
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.ForStatement,
      condition:{
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:5.0,
          scope: ScopeType.CONST
        },
        type: __GMLC_NodeType.BinaryExpression,
        line:1.0,
        operator:"<",
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"i",
          scope: ScopeType.LOCAL
        }
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.ForStatement,
            condition:{
              right:{
                type: __GMLC_NodeType.Literal,
                line:2.0,
                value:5.0,
                scope: ScopeType.CONST
              },
              type: __GMLC_NodeType.BinaryExpression,
              line:2.0,
              operator:"<",
              left:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"j",
                scope: ScopeType.LOCAL
              }
            },
            codeBlock:{
              type: __GMLC_NodeType.BlockStatement,
              line:2.0,
              statements:[
                {
                  type: __GMLC_NodeType.CallExpression,
                  line:3.0,
                  arguments:[
                    {
                      right:{
                        type: __GMLC_NodeType.Identifier,
                        line:3.0,
                        value:"j",
                        scope: ScopeType.LOCAL
                      },
                      type: __GMLC_NodeType.BinaryExpression,
                      line:3.0,
                      operator:"*",
                      left:{
                        type: __GMLC_NodeType.Identifier,
                        line:3.0,
                        value:"i",
                        scope: ScopeType.LOCAL
                      }
                    }
                  ],
                  callee:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"print",
                    scope: undefined
                  }
                }
              ]
            },
            line:2.0,
            initialization:{
              type: __GMLC_NodeType.VariableDeclarationList,
              line:2.0,
              statements:{
                type: __GMLC_NodeType.BlockStatement,
                line:2.0,
                statements:[
                  {
                    expr:{
                      type: __GMLC_NodeType.Literal,
                      line:2.0,
                      value:0.0,
                      scope: ScopeType.CONST
                    },
                    type: __GMLC_NodeType.VariableDeclaration,
                    line:2.0,
                    identifier:"j",
                    scope: ScopeType.LOCAL
                  }
                ]
              }
            },
            increment:{
              expr:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"j",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.UpdateExpression,
              line:2.0,
              prefix:false,
              operator:"++"
            }
          }
        ]
      },
      line:1.0,
      initialization:{
        type: __GMLC_NodeType.VariableDeclarationList,
        line:1.0,
        statements:{
          type: __GMLC_NodeType.BlockStatement,
          line:1.0,
          statements:[
            {
              expr:{
                type: __GMLC_NodeType.Literal,
                line:1.0,
                value:0.0,
                scope: ScopeType.CONST
              },
              type: __GMLC_NodeType.VariableDeclaration,
              line:1.0,
              identifier:"i",
              scope: ScopeType.LOCAL
            }
          ]
        }
      },
      increment:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"i",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.UpdateExpression,
        line:1.0,
        prefix:false,
        operator:"++"
      }
    }
  ],
  LocalVarNames:[
    "i",
    "j"
  ]
}
);
#endregion
#region Double Repeat Loop Test
run_parse_test("double repeat loop",
@'repeat (5) {
	repeat (5) {
		print("nested repeat");
	}
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.RepeatStatement,
      condition:{
        type: __GMLC_NodeType.Literal,
        line:1.0,
        value:5.0,
        scope: ScopeType.CONST
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.RepeatStatement,
            condition:{
              type: __GMLC_NodeType.Literal,
              line:2.0,
              value:5.0,
              scope: ScopeType.CONST
            },
            codeBlock:{
              type: __GMLC_NodeType.BlockStatement,
              line:2.0,
              statements:[
                {
                  type: __GMLC_NodeType.CallExpression,
                  line:3.0,
                  arguments:[
                    {
                      type: __GMLC_NodeType.Literal,
                      line:3.0,
                      value:"nested repeat",
                      scope: ScopeType.CONST
                    }
                  ],
                  callee:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"print",
                  }
                }
              ]
            },
            line:2.0
          }
        ]
      },
      line:1.0
    }
  ],
}
);
#endregion
#region Try-Catch-Finally with Nested Switch
run_parse_test("try-catch-finally with nested switch",
@'try {
	switch(x) {
		case 1:
			print("one");
		break;
	}
}
catch (e) {
	print(e);
}
finally {
	print("done");
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.TryStatement,
      line:1.0,
      tryBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.SwitchStatement,
            line:2.0,
            switchExpression:{
              type: __GMLC_NodeType.Identifier,
              line:2.0,
              value:"x",
            },
            cases:[
              {
                label:{
                  type: __GMLC_NodeType.Literal,
                  line:3.0,
                  value:1.0,
                  scope: ScopeType.CONST
                },
                type: __GMLC_NodeType.CaseExpression,
                codeBlock:{
                  type: __GMLC_NodeType.Base,
                  line:"BlockStatement"
                },
                line:3.0
              }
            ]
          }
        ]
      },
      exceptionVar:"e",
      catchBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:8.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:9.0,
            arguments:[
              {
                type: __GMLC_NodeType.Identifier,
                line:9.0,
                value:"e",
                scope: ScopeType.LOCAL
              }
            ],
            callee:{
              type: __GMLC_NodeType.Identifier,
              line:9.0,
              value:"print",
            }
          }
        ]
      },
      finallyBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:11.0,
        statements:[
          {
            type: __GMLC_NodeType.CallExpression,
            line:12.0,
            arguments:[
              {
                type: __GMLC_NodeType.Literal,
                line:12.0,
                value:"done",
                scope: ScopeType.CONST
              }
            ],
            callee:{
              type: __GMLC_NodeType.Identifier,
              line:12.0,
              value:"print",
            }
          }
        ]
      }
    }
  ],
  LocalVarNames:[
    "e"
  ]
}
);
#endregion
#region Function Declaration with Nested Loops and Conditional
run_parse_test("function declaration with nested loops and conditional",
@'function calculate(x) {
	for (var i = 0; i < x; i++) {
		if (i % 2 == 0) {
			print(i);
		}
	}
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
  ],
  GlobalVar:{
    "GMLC@'calculate":{
      type: __GMLC_NodeType.FunctionDeclaration,
      name:"GMLC@'calculate",
      line:1.0,
      parameters:[
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"x",
          scope: ScopeType.LOCAL
        }
      ],
      body:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.ForStatement,
            condition:{
              right:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"x",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.BinaryExpression,
              line:2.0,
              operator:"<",
              left:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"i",
                scope: ScopeType.LOCAL
              }
            },
            codeBlock:{
              type: __GMLC_NodeType.BlockStatement,
              line:2.0,
              statements:[
                {
                  type: __GMLC_NodeType.IfStatement,
                  condition:{
                    right:{
                      type: __GMLC_NodeType.Literal,
                      line:3.0,
                      value:0.0,
                      scope: ScopeType.CONST
                    },
                    type: __GMLC_NodeType.BinaryExpression,
                    line:3.0,
                    operator:"==",
                    left:{
                      right:{
                        type: __GMLC_NodeType.Literal,
                        line:3.0,
                        value:2.0,
                        scope: ScopeType.CONST
                      },
                      type: __GMLC_NodeType.BinaryExpression,
                      line:3.0,
                      operator:"mod",
                      left:{
                        type: __GMLC_NodeType.Identifier,
                        line:3.0,
                        value:"i",
                        scope: ScopeType.LOCAL
                      }
                    }
                  },
                  line:3.0,
                  consequent:{
                    type: __GMLC_NodeType.BlockStatement,
                    line:3.0,
                    statements:[
                      {
                        type: __GMLC_NodeType.CallExpression,
                        line:4.0,
                        arguments:[
                          {
                            type: __GMLC_NodeType.Identifier,
                            line:4.0,
                            value:"i",
                            scope: ScopeType.LOCAL
                          }
                        ],
                        callee:{
                          type: __GMLC_NodeType.Identifier,
                          line:4.0,
                          value:"print",
                          scope: undefined
                        }
                      }
                    ]
                  },
                  alternate: undefined
                }
              ]
            },
            line:2.0,
            initialization:{
              type: __GMLC_NodeType.VariableDeclarationList,
              line:2.0,
              statements:{
                type: __GMLC_NodeType.BlockStatement,
                line:2.0,
                statements:[
                  {
                    expr:{
                      type: __GMLC_NodeType.Literal,
                      line:2.0,
                      value:0.0,
                      scope: ScopeType.CONST
                    },
                    type: __GMLC_NodeType.VariableDeclaration,
                    line:2.0,
                    identifier:"i",
                    scope: ScopeType.LOCAL
                  }
                ]
              }
            },
            increment:{
              expr:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"i",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.UpdateExpression,
              line:2.0,
              prefix:false,
              operator:"++"
            }
          }
        ]
      },
      LocalVarNames:[
        "x",
        "i"
      ],
    }
  },
  GlobalVarNames:[
    "GMLC@'calculate"
  ],
}
);
#endregion
#region Complex Expression Evaluation
run_parse_test("complex expression evaluation",
@'var result = ((x + y) * (x - y)) / 2;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              right:{
                type: __GMLC_NodeType.Literal,
                line:1.0,
                value:2.0,
                scope: ScopeType.CONST
              },
              type: __GMLC_NodeType.BinaryExpression,
              line:1.0,
              operator:"\/",
              left:{
                right:{
                  right:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"y",
                    scope: undefined
                  },
                  type: __GMLC_NodeType.BinaryExpression,
                  line:1.0,
                  operator:"-",
                  left:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"x",
                    scope: undefined
                  }
                },
                type: __GMLC_NodeType.BinaryExpression,
                line:1.0,
                operator:"*",
                left:{
                  right:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"y",
                    scope: undefined
                  },
                  type: __GMLC_NodeType.BinaryExpression,
                  line:1.0,
                  operator:"+",
                  left:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"x",
                    scope: undefined
                  }
                }
              }
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"result",
            scope: ScopeType.LOCAL
          }
        ]
      }
    }
  ],
  LocalVarNames:[
    "result"
  ]
}
);
#endregion
#region Complex Control Flow with Function Calls
run_parse_test("complex control flow with function calls",
@'var x = 0;
while (x < 10) {
	x++;
	print(x);
	if (x == 5) {
		break;
	}
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Literal,
              line:1.0,
              value:0.0,
              scope: ScopeType.CONST
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"x",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.WhileStatement,
      condition:{
        right:{
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:10.0,
          scope: ScopeType.CONST
        },
        type: __GMLC_NodeType.BinaryExpression,
        line:2.0,
        operator:"<",
        left:{
          type: __GMLC_NodeType.Identifier,
          line:2.0,
          value:"x",
          scope: ScopeType.LOCAL
        }
      },
      codeBlock:{
        type: __GMLC_NodeType.BlockStatement,
        line:2.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Identifier,
              line:3.0,
              value:"x",
              scope: ScopeType.LOCAL
            },
            type: __GMLC_NodeType.UpdateExpression,
            line:3.0,
            prefix:false,
            operator:"++"
          },
          {
            type: __GMLC_NodeType.CallExpression,
            line:4.0,
            arguments:[
              {
                type: __GMLC_NodeType.Identifier,
                line:4.0,
                value:"x",
                scope: ScopeType.LOCAL
              }
            ],
            callee:{
              type: __GMLC_NodeType.Identifier,
              line:4.0,
              value:"print",
              scope: undefined
            }
          },
          {
            type: __GMLC_NodeType.IfStatement,
            condition:{
              right:{
                type: __GMLC_NodeType.Literal,
                line:5.0,
                value:5.0,
                scope: ScopeType.CONST
              },
              type: __GMLC_NodeType.BinaryExpression,
              line:5.0,
              operator:"==",
              left:{
                type: __GMLC_NodeType.Identifier,
                line:5.0,
                value:"x",
                scope: ScopeType.LOCAL
              }
            },
            line:5.0,
            consequent:{
              type: __GMLC_NodeType.BlockStatement,
              line:5.0,
              statements:[
                {
                  type: __GMLC_NodeType.BreakStatement,
                  line:6.0
                }
              ]
            },
            alternate: undefined
          }
        ]
      },
      line:2.0
    }
  ],
  LocalVarNames:[
    "x"
  ]
}
);
#endregion
#endregion
#region Expressions and Operators
#region 1. Test for parseAssignmentExpression
run_parse_test("parseAssignmentExpression",
@'x = y + 1;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"y",
        },
        type: __GMLC_NodeType.BinaryExpression,
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:1.0,
          scope: ScopeType.CONST
        },
        line:1.0,
        operator:"+"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 2. Test for parseLogicalOrExpression
run_parse_test("parseLogicalOrExpression",
@'a || b;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"a",
      },
      type: __GMLC_NodeType.LogicalExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"b",
      },
      line:1.0,
      operator:"||"
    }
  ],
}
);
#endregion
#region 3. Test for parseLogicalAndExpression
run_parse_test("parseLogicalAndExpression",
@'x && y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.LogicalExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"&&"
    }
  ],
}
);
#endregion
#region 4. Test for parseBitwiseOrExpression
run_parse_test("parseBitwiseOrExpression",
@'x | y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"|"
    }
  ],
}
);
#endregion
#region 5. Test for parseBitwiseXorExpression
run_parse_test("parseBitwiseXorExpression",
@'x ^ y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"^"
    }
  ],
}
);
#endregion
#region 6. Test for parseBitwiseAndExpression
run_parse_test("parseBitwiseAndExpression",
@'x & y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"&"
    }
  ],
}
);
#endregion
#region 7. Test for parseEqualityExpression
run_parse_test("parseEqualityExpression",
@'x == y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"=="
    }
  ],
}
);
#endregion
#region 8. Test for parseRelationalExpression
run_parse_test("parseRelationalExpression",
@'x < y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"<"
    }
  ],
}
);
#endregion
#region 9. Test for parseShiftExpression
run_parse_test("parseShiftExpression",
@'x >> y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:">>"
    }
  ],
}
);
#endregion
#region 10. Test for parseAdditiveExpression
run_parse_test("parseAdditiveExpression",
@'x + y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"+"
    }
  ],
}
);
#endregion
#region 11. Test for parseMultiplicativeExpression
run_parse_test("parseMultiplicativeExpression",
@'x * y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"y",
      },
      line:1.0,
      operator:"*"
    }
  ],
}
);
#endregion
#region 12. Test for parseUnaryExpression
run_parse_test("parseUnaryExpression",
@'!x;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      expr:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.UnaryExpression,
      line:1.0,
      operator:"!"
    }
  ],
}
);
#endregion
#region 13. Test for parsePostfixExpression
run_parse_test("parsePostfixExpression",
@'x++;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      expr:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.UpdateExpression,
      line:1.0,
      prefix:false,
      operator:"++"
    }
  ],
}
);
#endregion
#region 1. Mixed Logical and Arithmetic Expressions
run_parse_test("Mixed Logical and Arithmetic Expressions",
@'x = (y + 2) * 3 && z || w;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          left:{
            left:{
              left:{
                type: __GMLC_NodeType.Identifier,
                line:1.0,
                value:"y",
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Literal,
                line:1.0,
                value:2.0,
                scope: ScopeType.CONST
              },
              line:1.0,
              operator:"+"
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              type: __GMLC_NodeType.Literal,
              line:1.0,
              value:3.0,
              scope: ScopeType.CONST
            },
            line:1.0,
            operator:"*"
          },
          type: __GMLC_NodeType.LogicalExpression,
          right:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"z",
          },
          line:1.0,
          operator:"&&"
        },
        type: __GMLC_NodeType.LogicalExpression,
        right:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"w",
        },
        line:1.0,
        operator:"||"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 2. Nested Parentheses and Mixed Operators
run_parse_test("Nested Parentheses and Mixed Operators",
@'result = ((a + b) / (c - d)) << 2;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"result",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          left:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"a",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"b",
            },
            line:1.0,
            operator:"+"
          },
          type: __GMLC_NodeType.BinaryExpression,
          right:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"c",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"d",
            },
            line:1.0,
            operator:"-"
          },
          line:1.0,
          operator:"\/"
        },
        type: __GMLC_NodeType.BinaryExpression,
        right:{
          type: __GMLC_NodeType.Literal,
          line:1.0,
          value:2.0,
          scope: ScopeType.CONST
        },
        line:1.0,
        operator:"<<"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 3. Complex Logical Expressions
run_parse_test("Complex Logical Expressions",
@'(x && y) || (z && (a || b));',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"x",
        },
        type: __GMLC_NodeType.LogicalExpression,
        right:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"y",
        },
        line:1.0,
        operator:"&&"
      },
      type: __GMLC_NodeType.LogicalExpression,
      right:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"z",
        },
        type: __GMLC_NodeType.LogicalExpression,
        right:{
          left:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"a",
          },
          type: __GMLC_NodeType.LogicalExpression,
          right:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"b",
          },
          line:1.0,
          operator:"||"
        },
        line:1.0,
        operator:"&&"
      },
      line:1.0,
      operator:"||"
    }
  ],
}
);
#endregion
#region 4. Assignment Chaining with Logical Operations
/// NOTE: Technically this isnt valid GML, however it cost minimal extra to continue to include this.
run_parse_test("Assignment Chaining with Logical Operations",
@'x = y = (a && b);',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"y",
        },
        type: __GMLC_NodeType.AssignmentExpression,
        right:{
          left:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"a",
          },
          type: __GMLC_NodeType.LogicalExpression,
          right:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"b",
          },
          line:1.0,
          operator:"&&"
        },
        line:1.0,
        operator:"="
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 5. Complex Arithmetic with Precedence
run_parse_test("Complex Arithmetic with Precedence",
@'x = a + b * (c - d) / e;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"a",
        },
        type: __GMLC_NodeType.BinaryExpression,
        right:{
          left:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"b",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              left:{
                type: __GMLC_NodeType.Identifier,
                line:1.0,
                value:"c",
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Identifier,
                line:1.0,
                value:"d",
              },
              line:1.0,
              operator:"-"
            },
            line:1.0,
            operator:"*"
          },
          type: __GMLC_NodeType.BinaryExpression,
          right:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"e",
          },
          line:1.0,
          operator:"\/"
        },
        line:1.0,
        operator:"+"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 6. Unary and Postfix Mix
run_parse_test("Unary and Postfix Mix",
@'++x * !y;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"x",
        },
        type: __GMLC_NodeType.UnaryExpression,
        line:1.0,
        operator:"++"
      },
      type: __GMLC_NodeType.BinaryExpression,
      right:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:1.0,
          value:"y",
        },
        type: __GMLC_NodeType.UnaryExpression,
        line:1.0,
        operator:"!"
      },
      line:1.0,
      operator:"*"
    }
  ],
}
);
#endregion
#region 1. Deeply Nested Expressions with Logical, Relational, and Arithmetic Operators
run_parse_test("Deeply Nested Complex Expression",
@'x = ((a + b * (c ? d : e) / f) << 2) || (g && h || i);',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"x",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          left:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"a",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              left:{
                left:{
                  type: __GMLC_NodeType.Identifier,
                  line:1.0,
                  value:"b",
                },
                type: __GMLC_NodeType.BinaryExpression,
                right:{
                  type: __GMLC_NodeType.ConditionalExpression,
                  condition:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"c",
                  },
                  line:1.0,
                  trueExpr:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"d",
                  },
                  falseExpr:{
                    type: __GMLC_NodeType.Identifier,
                    line:1.0,
                    value:"e",
                  }
                },
                line:1.0,
                operator:"*"
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Identifier,
                line:1.0,
                value:"f",
              },
              line:1.0,
              operator:"\/"
            },
            line:1.0,
            operator:"+"
          },
          type: __GMLC_NodeType.BinaryExpression,
          right:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value:2.0,
            scope: ScopeType.CONST
          },
          line:1.0,
          operator:"<<"
        },
        type: __GMLC_NodeType.LogicalExpression,
        right:{
          left:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"g",
            },
            type: __GMLC_NodeType.LogicalExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"h",
            },
            line:1.0,
            operator:"&&"
          },
          type: __GMLC_NodeType.LogicalExpression,
          right:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"i",
          },
          line:1.0,
          operator:"||"
        },
        line:1.0,
        operator:"||"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 2. Expression Combining Unary, Multiplicative, Additive, and Assignment Operators
run_parse_test("Complex Unary, Multiplicative, and Additive Expression",
@'result = -a * b + c / !d - (e += f) * g;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"result",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          left:{
            left:{
              expr:{
                type: __GMLC_NodeType.Identifier,
                line:1.0,
                value:"a",
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:1.0,
              operator:"-"
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"b",
            },
            line:1.0,
            operator:"*"
          },
          type: __GMLC_NodeType.BinaryExpression,
          right:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"c",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              expr:{
                type: __GMLC_NodeType.Identifier,
                line:1.0,
                value:"d",
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:1.0,
              operator:"!"
            },
            line:1.0,
            operator:"\/"
          },
          line:1.0,
          operator:"+"
        },
        type: __GMLC_NodeType.BinaryExpression,
        right:{
          left:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"e",
            },
            type: __GMLC_NodeType.AssignmentExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"f",
            },
            line:1.0,
            operator:"+="
          },
          type: __GMLC_NodeType.BinaryExpression,
          right:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"g",
          },
          line:1.0,
          operator:"*"
        },
        line:1.0,
        operator:"-"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region 3. Complex Expression Using Bitwise, Logical, and Conditional Operators
run_parse_test("Complex Bitwise, Logical, and Conditional Expression",
@'final = ((x & y) | (z ^ w)) && (a ? b : (c && d));',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"final",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        left:{
          left:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"x",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"y",
            },
            line:1.0,
            operator:"&"
          },
          type: __GMLC_NodeType.BinaryExpression,
          right:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"z",
            },
            type: __GMLC_NodeType.BinaryExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"w",
            },
            line:1.0,
            operator:"^"
          },
          line:1.0,
          operator:"|"
        },
        type: __GMLC_NodeType.LogicalExpression,
        right:{
          type: __GMLC_NodeType.ConditionalExpression,
          condition:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"a",
          },
          line:1.0,
          trueExpr:{
            type: __GMLC_NodeType.Identifier,
            line:1.0,
            value:"b",
          },
          falseExpr:{
            left:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"c",
            },
            type: __GMLC_NodeType.LogicalExpression,
            right:{
              type: __GMLC_NodeType.Identifier,
              line:1.0,
              value:"d",
            },
            line:1.0,
            operator:"&&"
          }
        },
        line:1.0,
        operator:"&&"
      },
      line:1.0,
      operator:"="
    }
  ],
}
);
#endregion
#region If Statement Test
run_parse_test("= Equal inside conditional expression",
@'if (x = 0) {
	break;
}',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.IfStatement,
	  condition:{
		right:{
		  type: __GMLC_NodeType.Literal,
		  value:0.0
		},
		type: __GMLC_NodeType.AssignmentExpression,
		left:{
		  type: __GMLC_NodeType.Identifier,
		  value:"x"
		},
		operator:"="
	  },
	  consequent:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.BreakStatement
		  }
		]
	  },
	  alternate: undefined
	}
  ]
}
);
#endregion
#endregion
#region Function Declaration Test
run_parse_test("function declaration",
@'function sum(a, b) {
	return a + b;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
  ],
  GlobalVar:{
    "GMLC@'sum":{
      type: __GMLC_NodeType.FunctionDeclaration,
      name:"GMLC@'sum",
      line:1.0,
      parameters:[
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"a",
          scope: ScopeType.LOCAL
        },
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"b",
          scope: ScopeType.LOCAL
        }
      ],
      body:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              left:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"a",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"b",
                scope: ScopeType.LOCAL
              },
              line:2.0,
              operator:"+"
            },
            type: __GMLC_NodeType.ReturnStatement,
            line:2.0
          }
        ]
      },
      LocalVarNames:[
        "a",
        "b"
      ],
    }
  },
  GlobalVarNames:[
    "GMLC@'sum"
  ],
}
);
#endregion
#region Function Declaration Test anon
run_parse_test("function declaration <anon>",
@'add = function(a, b) {
	return a + b;
}
sub = function(a, b) {
	return a - b;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"add",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"GMLC@'anon@'0",
        scope: ScopeType.GLOBAL
      },
      line:1.0,
      operator:"="
    },
    {
      left:{
        type: __GMLC_NodeType.Identifier,
        line:4.0,
        value:"sub",
      },
      type: __GMLC_NodeType.AssignmentExpression,
      right:{
        type: __GMLC_NodeType.Identifier,
        line:4.0,
        value:"GMLC@'anon@'1",
        scope: ScopeType.GLOBAL
      },
      line:4.0,
      operator:"="
    }
  ],
  GlobalVar:{
    "GMLC@'anon@'0":{
      type: __GMLC_NodeType.FunctionDeclaration,
      name:"GMLC@'anon@'0",
      line:1.0,
      parameters:[
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"a",
          scope: ScopeType.LOCAL
        },
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"b",
          scope: ScopeType.LOCAL
        }
      ],
      body:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              left:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"a",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Identifier,
                line:2.0,
                value:"b",
                scope: ScopeType.LOCAL
              },
              line:2.0,
              operator:"+"
            },
            type: __GMLC_NodeType.ReturnStatement,
            line:2.0
          }
        ]
      },
      LocalVarNames:[
        "a",
        "b"
      ],
    },
    "GMLC@'anon@'1":{
      type: __GMLC_NodeType.FunctionDeclaration,
      name:"GMLC@'anon@'1",
      line:4.0,
      parameters:[
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:4.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:4.0,
          identifier:"a",
          scope: ScopeType.LOCAL
        },
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:4.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:4.0,
          identifier:"b",
          scope: ScopeType.LOCAL
        }
      ],
      body:{
        type: __GMLC_NodeType.BlockStatement,
        line:4.0,
        statements:[
          {
            expr:{
              left:{
                type: __GMLC_NodeType.Identifier,
                line:5.0,
                value:"a",
                scope: ScopeType.LOCAL
              },
              type: __GMLC_NodeType.BinaryExpression,
              right:{
                type: __GMLC_NodeType.Identifier,
                line:5.0,
                value:"b",
                scope: ScopeType.LOCAL
              },
              line:5.0,
              operator:"-"
            },
            type: __GMLC_NodeType.ReturnStatement,
            line:5.0
          }
        ]
      },
      LocalVarNames:[
        "a",
        "b"
      ],
    }
  },
  GlobalVarNames:[
    "GMLC@'anon@'0",
    "GMLC@'anon@'1"
  ],
}
);
#endregion
#region Function Declaration Test anon
run_parse_test("function declaration with statics, globals, and var",
@'foo = function(a, b) {
	static __bar = function(){};
	globalvar BAR = 1;
	var _bar = 2;
}',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      right:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"GMLC@'anon@'2",
        scope: ScopeType.GLOBAL
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:1.0,
      operator:"=",
      left:{
        type: __GMLC_NodeType.Identifier,
        line:1.0,
        value:"foo",
        scope: undefined
      }
    }
  ],
  GlobalVar:{
    "GMLC@'anon@'3":{
      type: __GMLC_NodeType.FunctionDeclaration,
      name:"GMLC@'anon@'3",
      line:2.0,
      parameters:[
      ],
      body:{
        type: __GMLC_NodeType.BlockStatement,
        line:2.0,
        statements:[
        ]
      },
    },
    "GMLC@'anon@'2":{
      type: __GMLC_NodeType.FunctionDeclaration,
      name:"GMLC@'anon@'2",
      line:1.0,
      parameters:[
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"a",
          scope: ScopeType.LOCAL
        },
        {
          expr:{
            type: __GMLC_NodeType.Literal,
            line:1.0,
            value: undefined,
            scope: ScopeType.CONST
          },
          type: __GMLC_NodeType.VariableDeclaration,
          line:1.0,
          identifier:"b",
          scope: ScopeType.LOCAL
        }
      ],
      body:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            type: __GMLC_NodeType.VariableDeclarationList,
            line:2.0,
            statements:{
              type: __GMLC_NodeType.BlockStatement,
              line:2.0,
              statements:[
                {
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:2.0,
                    value:"GMLC@'anon@'3",
                    scope: ScopeType.GLOBAL
                  },
                  type: __GMLC_NodeType.VariableDeclaration,
                  line:2.0,
                  identifier:"__bar",
                  scope: ScopeType.STATIC
                }
              ]
            }
          },
          {
            type: __GMLC_NodeType.VariableDeclarationList,
            line:3.0,
            statements:{
              type: __GMLC_NodeType.BlockStatement,
              line:3.0,
              statements:[
                {
                  expr:{
                    type: __GMLC_NodeType.Literal,
                    line:3.0,
                    value:1.0,
                    scope: ScopeType.CONST
                  },
                  type: __GMLC_NodeType.VariableDeclaration,
                  line:3.0,
                  identifier:"BAR",
                  scope: ScopeType.GLOBAL
                }
              ]
            }
          },
          {
            type: __GMLC_NodeType.VariableDeclarationList,
            line:4.0,
            statements:{
              type: __GMLC_NodeType.BlockStatement,
              line:4.0,
              statements:[
                {
                  expr:{
                    type: __GMLC_NodeType.Literal,
                    line:4.0,
                    value:2.0,
                    scope: ScopeType.CONST
                  },
                  type: __GMLC_NodeType.VariableDeclaration,
                  line:4.0,
                  identifier:"_bar",
                  scope: ScopeType.LOCAL
                }
              ]
            }
          }
        ]
      },
      LocalVarNames:[
        "a",
        "b",
        "_bar"
      ],
      StaticVar:{
      },
      StaticVarNames:[
        "__bar"
      ]
    }
  },
  GlobalVarNames:[
    "GMLC@'anon@'3",
    "BAR",
    "GMLC@'anon@'2"
  ],
}
);
#endregion
#region Multiple Variable Declarations
run_parse_test("multiple variable declarations with and without initialization",
@'var _tile = 5, _src;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Literal,
              line:1.0,
              value:5.0,
              scope: ScopeType.CONST
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"_tile",
            scope: ScopeType.LOCAL
          },
          {
            expr: undefined,
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"_src",
            scope: ScopeType.LOCAL
          }
        ]
      }
    }
  ],
  LocalVarNames:[
    "_tile",
    "_src"
  ]
}
);

run_parse_test("multiple variable declarations without initialization",
@'var _tile, _src;',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			expr: undefined,
			identifier:"_tile",
			type: __GMLC_NodeType.VariableDeclaration,
		  },
		  {
			expr: undefined,
			identifier:"_src",
			type: __GMLC_NodeType.VariableDeclaration,
		  }
		]
	  }
	}
  ]
}
);

#endregion
#region Accessors <Array, Grid, List, Map, Struct>
run_parse_test("Array access and modification",
@'var arr = [0, 1, 2];
arr[0] = 1;
var test = ++arr[2]--;
return arr;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.ArrayPattern,
              line:1.0,
              elements:[
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:0.0,
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:1.0,
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:2.0,
                  scope: ScopeType.CONST
                }
              ]
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"arr",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:2.0,
        value:1.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:2.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:2.0,
          value:"arr",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:2.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.Array"
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:3.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:3.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"arr",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:3.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:3.0,
                    value:2.0,
                    scope: ScopeType.CONST
                  },
                  val2: undefined,
                  accessorType:"__GMLC_AccessorType.Array"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:3.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:3.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:3.0,
            identifier:"test",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      expr:{
        type: __GMLC_NodeType.Identifier,
        line:4.0,
        value:"arr",
        scope: ScopeType.LOCAL
      },
      type: __GMLC_NodeType.ReturnStatement,
      line:4.0
    }
  ],
  LocalVarNames:[
    "arr",
    "test"
  ]
}
);

run_parse_test("List access and modification",
@'var list = ds_list_create();
list[| 0] = 1;
list[| 1] = 2;
ds_list_set(list, 2, 3);
var test = ++list[| 2]--;
var _return = test;
ds_list_destroy(list);
return _return;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.CallExpression,
              line:1.0,
              arguments:[
              ],
              callee:{
                type: __GMLC_NodeType.Function,
                name:"ds_list_create",
                value:1294.0,
                line:1.0
              }
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"list",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:2.0,
        value:1.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:2.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:2.0,
          value:"list",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:2.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.List"
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:3.0,
        value:2.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:3.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:3.0,
          value:"list",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:3.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:3.0,
          value:1.0,
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.List"
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:4.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:4.0,
          value:"list",
          scope: ScopeType.LOCAL
        },
        {
          type: __GMLC_NodeType.Literal,
          line:4.0,
          value:2.0,
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:4.0,
          value:3.0,
          scope: ScopeType.CONST
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"ds_list_set",
        value:1314.0,
        line:4.0
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:5.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:5.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:5.0,
                    value:"list",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:5.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:5.0,
                    value:2.0,
                    scope: ScopeType.CONST
                  },
                  val2: undefined,
                  accessorType:"__GMLC_AccessorType.List"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:5.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:5.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:5.0,
            identifier:"test",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:6.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:6.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Identifier,
              line:6.0,
              value:"test",
              scope: ScopeType.LOCAL
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:6.0,
            identifier:"_return",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:7.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:7.0,
          value:"list",
          scope: ScopeType.LOCAL
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"ds_list_destroy",
        value:1295.0,
        line:7.0
      }
    },
    {
      expr:{
        type: __GMLC_NodeType.Identifier,
        line:8.0,
        value:"_return",
        scope: ScopeType.LOCAL
      },
      type: __GMLC_NodeType.ReturnStatement,
      line:8.0
    }
  ],
  LocalVarNames:[
    "list",
    "test",
    "_return"
  ]
}
);

run_parse_test("Grid access and modification",
@'var grid = ds_grid_create(5, 5);
ds_grid_set_region(grid, 0,0, 4, 4, "example");
grid[# 0, 1] = 2;
var test = ++grid[# 3, 4]--;
var _return = test;
ds_grid_destroy(grid);
return _return;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.CallExpression,
              line:1.0,
              arguments:[
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:5.0,
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:5.0,
                  scope: ScopeType.CONST
                }
              ],
              callee:{
                type: __GMLC_NodeType.Function,
                name:"ds_grid_create",
                value:1365.0,
                line:1.0
              }
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"grid",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:2.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:2.0,
          value:"grid",
          scope: ScopeType.LOCAL
        },
        {
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:4.0,
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:4.0,
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:"example",
          scope: ScopeType.CONST
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"ds_grid_set_region",
        value:1377.0,
        line:2.0
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:3.0,
        value:2.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:3.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:3.0,
          value:"grid",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:3.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:3.0,
          value:0.0,
          scope: ScopeType.CONST
        },
        val2:{
          type: __GMLC_NodeType.Literal,
          line:3.0,
          value:1.0,
          scope: ScopeType.CONST
        },
        accessorType:"__GMLC_AccessorType.Grid"
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:4.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:4.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:4.0,
                    value:"grid",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:4.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:4.0,
                    value:3.0,
                    scope: ScopeType.CONST
                  },
                  val2:{
                    type: __GMLC_NodeType.Literal,
                    line:4.0,
                    value:4.0,
                    scope: ScopeType.CONST
                  },
                  accessorType:"__GMLC_AccessorType.Grid"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:4.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:4.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:4.0,
            identifier:"test",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:5.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:5.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Identifier,
              line:5.0,
              value:"test",
              scope: ScopeType.LOCAL
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:5.0,
            identifier:"_return",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:6.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:6.0,
          value:"grid",
          scope: ScopeType.LOCAL
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"ds_grid_destroy",
        value:1366.0,
        line:6.0
      }
    },
    {
      expr:{
        type: __GMLC_NodeType.Identifier,
        line:7.0,
        value:"_return",
        scope: ScopeType.LOCAL
      },
      type: __GMLC_NodeType.ReturnStatement,
      line:7.0
    }
  ],
  LocalVarNames:[
    "grid",
    "test",
    "_return"
  ]
}
);

run_parse_test("Map access and modification",
@'var map = ds_map_create();
map[? "zero"] = 1;
ds_map_set(map, "zero", 2);
map[? "two"] = 3;
var test = ++map[? "two"]--;
var _return = test;
ds_map_destroy(map);
return _return;',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.CallExpression,
              line:1.0,
              arguments:[
              ],
              callee:{
                type: __GMLC_NodeType.Function,
                name:"ds_map_create",
                value:1317.0,
                line:1.0
              }
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"map",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:2.0,
        value:1.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:2.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:2.0,
          value:"map",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:2.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:"zero",
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.Map"
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:3.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:3.0,
          value:"map",
          scope: ScopeType.LOCAL
        },
        {
          type: __GMLC_NodeType.Literal,
          line:3.0,
          value:"zero",
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:3.0,
          value:2.0,
          scope: ScopeType.CONST
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"ds_map_set",
        value:1324.0,
        line:3.0
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:4.0,
        value:3.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:4.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:4.0,
          value:"map",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:4.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:4.0,
          value:"two",
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.Map"
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:5.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:5.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:5.0,
                    value:"map",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:5.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:5.0,
                    value:"two",
                    scope: ScopeType.CONST
                  },
                  val2: undefined,
                  accessorType:"__GMLC_AccessorType.Map"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:5.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:5.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:5.0,
            identifier:"test",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:6.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:6.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Identifier,
              line:6.0,
              value:"test",
              scope: ScopeType.LOCAL
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:6.0,
            identifier:"_return",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:7.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:7.0,
          value:"map",
          scope: ScopeType.LOCAL
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"ds_map_destroy",
        value:1318.0,
        line:7.0
      }
    },
    {
      expr:{
        type: __GMLC_NodeType.Identifier,
        line:8.0,
        value:"_return",
        scope: ScopeType.LOCAL
      },
      type: __GMLC_NodeType.ReturnStatement,
      line:8.0
    }
  ],
  LocalVarNames:[
    "map",
    "test",
    "_return"
  ]
}
);

run_parse_test("Struct access and modification with error handling",
@'var struct = {zero: 0, one: 1, two: 2 };
struct[$ "zero"] = 1;
var test = ++struct[$ "two"]--;
return string(struct)',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.StructPattern,
              keys:[
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:"zero",
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:"one",
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:"two",
                  scope: ScopeType.CONST
                }
              ],
              exprs:[
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:0.0,
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:1.0,
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:1.0,
                  value:2.0,
                  scope: ScopeType.CONST
                }
              ],
              line:1.0
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"struct",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:2.0,
        value:1.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:2.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:2.0,
          value:"struct",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:2.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:2.0,
          value:"zero",
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.Struct"
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:3.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:3.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:3.0,
                    value:"struct",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:3.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:3.0,
                    value:"two",
                    scope: ScopeType.CONST
                  },
                  val2: undefined,
                  accessorType:"__GMLC_AccessorType.Struct"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:3.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:3.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:3.0,
            identifier:"test",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      expr:{
        type: __GMLC_NodeType.CallExpression,
        line:4.0,
        arguments:[
          {
            type: __GMLC_NodeType.Identifier,
            line:4.0,
            value:"struct",
            scope: ScopeType.LOCAL
          }
        ],
        callee:{
          type: __GMLC_NodeType.Function,
          name:"string",
          value:264.0,
          line:4.0
        }
      },
      type: __GMLC_NodeType.ReturnStatement,
      line:4.0
    }
  ],
  LocalVarNames:[
    "struct",
    "test"
  ]
}
);

run_parse_test("Struct Advance accessing and modification with error handling",
@'var two = 2
var struct = {one: 1, two};
struct.zero = 0;
struct[$ "zero"] = "ZERO";
struct_set(struct, "one", "ONE")
struct_set_from_hash(struct, variable_get_hash("one"), "oneAgain");
var _test1 = ++struct.two--;
var _test2 = ++struct[$ "two"]--;
var _test3 = struct_get(struct, "two");
var _test4 = struct_get_from_hash(struct, variable_get_hash("two"));
return string(struct)',
{
  type: __GMLC_NodeType.Script,
  line: undefined,
  statements:[
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:1.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:1.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.Literal,
              line:1.0,
              value:2.0,
              scope: ScopeType.CONST
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:1.0,
            identifier:"two",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:2.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:2.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.StructPattern,
              keys:[
                {
                  type: __GMLC_NodeType.Literal,
                  line:2.0,
                  value:"one",
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:2.0,
                  value:"two",
                  scope: ScopeType.CONST
                }
              ],
              exprs:[
                {
                  type: __GMLC_NodeType.Literal,
                  line:2.0,
                  value:1.0,
                  scope: ScopeType.CONST
                },
                {
                  type: __GMLC_NodeType.Identifier,
                  line:2.0,
                  value:"two",
                  scope: undefined
                }
              ],
              line:2.0
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:2.0,
            identifier:"struct",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:3.0,
        value:0.0,
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:3.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:3.0,
          value:"struct",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:3.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:3.0,
          value:"zero",
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.Dot"
      }
    },
    {
      right:{
        type: __GMLC_NodeType.Literal,
        line:4.0,
        value:"ZERO",
        scope: ScopeType.CONST
      },
      type: __GMLC_NodeType.AssignmentExpression,
      line:4.0,
      operator:"=",
      left:{
        expr:{
          type: __GMLC_NodeType.Identifier,
          line:4.0,
          value:"struct",
          scope: ScopeType.LOCAL
        },
        type: __GMLC_NodeType.AccessorExpression,
        line:4.0,
        val1:{
          type: __GMLC_NodeType.Literal,
          line:4.0,
          value:"zero",
          scope: ScopeType.CONST
        },
        val2: undefined,
        accessorType:"__GMLC_AccessorType.Struct"
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:5.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:5.0,
          value:"struct",
          scope: ScopeType.LOCAL
        },
        {
          type: __GMLC_NodeType.Literal,
          line:5.0,
          value:"one",
          scope: ScopeType.CONST
        },
        {
          type: __GMLC_NodeType.Literal,
          line:5.0,
          value:"ONE",
          scope: ScopeType.CONST
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"struct_set",
        value:1180.0,
        line:5.0
      }
    },
    {
      type: __GMLC_NodeType.CallExpression,
      line:6.0,
      arguments:[
        {
          type: __GMLC_NodeType.Identifier,
          line:6.0,
          value:"struct",
          scope: ScopeType.LOCAL
        },
        {
          type: __GMLC_NodeType.CallExpression,
          line:6.0,
          arguments:[
            {
              type: __GMLC_NodeType.Literal,
              line:6.0,
              value:"one",
              scope: ScopeType.CONST
            }
          ],
          callee:{
            type: __GMLC_NodeType.Function,
            name:"variable_get_hash",
            value:1176.0,
            line:6.0
          }
        },
        {
          type: __GMLC_NodeType.Literal,
          line:6.0,
          value:"oneAgain",
          scope: ScopeType.CONST
        }
      ],
      callee:{
        type: __GMLC_NodeType.Function,
        name:"struct_set_from_hash",
        value:1181.0,
        line:6.0
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:7.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:7.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:7.0,
                    value:"struct",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:7.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:7.0,
                    value:"two",
                    scope: ScopeType.CONST
                  },
                  val2: undefined,
                  accessorType:"__GMLC_AccessorType.Dot"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:7.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:7.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:7.0,
            identifier:"_test1",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:8.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:8.0,
        statements:[
          {
            expr:{
              expr:{
                expr:{
                  expr:{
                    type: __GMLC_NodeType.Identifier,
                    line:8.0,
                    value:"struct",
                    scope: ScopeType.LOCAL
                  },
                  type: __GMLC_NodeType.AccessorExpression,
                  line:8.0,
                  val1:{
                    type: __GMLC_NodeType.Literal,
                    line:8.0,
                    value:"two",
                    scope: ScopeType.CONST
                  },
                  val2: undefined,
                  accessorType:"__GMLC_AccessorType.Struct"
                },
                type: __GMLC_NodeType.UpdateExpression,
                line:8.0,
                prefix:false,
                operator:"--"
              },
              type: __GMLC_NodeType.UnaryExpression,
              line:8.0,
              operator:"++"
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:8.0,
            identifier:"_test2",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:9.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:9.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.CallExpression,
              line:9.0,
              arguments:[
                {
                  type: __GMLC_NodeType.Identifier,
                  line:9.0,
                  value:"struct",
                  scope: ScopeType.LOCAL
                },
                {
                  type: __GMLC_NodeType.Literal,
                  line:9.0,
                  value:"two",
                  scope: ScopeType.CONST
                }
              ],
              callee:{
                type: __GMLC_NodeType.Function,
                name:"struct_get",
                value:1178.0,
                line:9.0
              }
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:9.0,
            identifier:"_test3",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      type: __GMLC_NodeType.VariableDeclarationList,
      line:10.0,
      statements:{
        type: __GMLC_NodeType.BlockStatement,
        line:10.0,
        statements:[
          {
            expr:{
              type: __GMLC_NodeType.CallExpression,
              line:10.0,
              arguments:[
                {
                  type: __GMLC_NodeType.Identifier,
                  line:10.0,
                  value:"struct",
                  scope: ScopeType.LOCAL
                },
                {
                  type: __GMLC_NodeType.CallExpression,
                  line:10.0,
                  arguments:[
                    {
                      type: __GMLC_NodeType.Literal,
                      line:10.0,
                      value:"two",
                      scope: ScopeType.CONST
                    }
                  ],
                  callee:{
                    type: __GMLC_NodeType.Function,
                    name:"variable_get_hash",
                    value:1176.0,
                    line:10.0
                  }
                }
              ],
              callee:{
                type: __GMLC_NodeType.Function,
                name:"struct_get_from_hash",
                value:1179.0,
                line:10.0
              }
            },
            type: __GMLC_NodeType.VariableDeclaration,
            line:10.0,
            identifier:"_test4",
            scope: ScopeType.LOCAL
          }
        ]
      }
    },
    {
      expr:{
        type: __GMLC_NodeType.CallExpression,
        line:11.0,
        arguments:[
          {
            type: __GMLC_NodeType.Identifier,
            line:11.0,
            value:"struct",
            scope: ScopeType.LOCAL
          }
        ],
        callee:{
          type: __GMLC_NodeType.Function,
          name:"string",
          value:264.0,
          line:11.0
        }
      },
      type: __GMLC_NodeType.ReturnStatement,
      line:11.0
    }
  ],
  LocalVarNames:[
    "two",
    "struct",
    "_test1",
    "_test2",
    "_test3",
    "_test4"
  ]
}
);
#endregion
}
//run_all_parser_tests()
#endregion

#region PostProcessor Unit Tests
function run_post_processor_test(description, input, expectedAST) {
	log($"Attempting Post Processer Test :: {description}")
	
	var tokenizer = new GML_Tokenizer();
	tokenizer.initialize(input);
	var tokens = tokenizer.parseAll();
	
	var preprocessor = new GML_PreProcessor();
	preprocessor.initialize(tokens);
	var preprocessedTokens = preprocessor.parseAll();
	
	var parser = new GML_Parser();
	parser.initialize(preprocessedTokens);
	var ast = parser.parseAll();
	
	var postprocessor = new GML_PostProcessor();
	postprocessor.initialize(ast);
	var optimizedAST = postprocessor.parseAll();
	
	__compare_results(description, ast, expectedAST);
}
function run_all_post_processor_tests() {
log("~~~~~ Post Processor Unit Tests ~~~~~\n");

#region Optimize simple constant expressions
// Example test case
run_post_processor_test("Optimize simple constant expressions",
@'var x = 5 + 3;',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value:8.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"x",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Optimize simple arithmetic constant expressions
run_post_processor_test("Optimize simple arithmetic constant expressions",
@'var result = 2 + 3 * 4;',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value:14.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"result",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Eliminate unreachable code after unconditional branch
run_post_processor_test("Eliminate unreachable code after unconditional branch",
@'if (true) { var x = 1; } else { var x = 2; }',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.BlockStatement,
	  statements:[
		{
		  type: __GMLC_NodeType.VariableDeclarationList,
		  statements:{
			type: __GMLC_NodeType.BlockStatement,
			statements:[
			  {
				scope:"LocalVar",
				expr:{
				  value:1.0,
				  type: __GMLC_NodeType.Literal,
				  scope:"Const"
				},
				type: __GMLC_NodeType.VariableDeclaration,
				identifier:"x",
			  }
			],
		  },
		}
	  ]
	}
  ],
}
);
#endregion
#region Simplify logical expressions with constant values
run_post_processor_test("Simplify logical expressions with constant values",
@'var isValid = false && anything;',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value: false,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"isValid",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Optimization of Struct Get with Literal to Hashed Access
run_post_processor_test("Optimize struct_get with string literal to hashed access",
@'var value = struct_get(someStruct, "key");',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  statements:{
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  callee:{
				value: struct_get_from_hash,
				type: __GMLC_NodeType.Function,
				name:"struct_get_from_hash",
			  },
			  arguments:[
				{
				  value:"someStruct",
				  type: __GMLC_NodeType.Identifier,
				},
				{
				  value: variable_get_hash("key"),
				  type: __GMLC_NodeType.Literal,
				  scope:"Const"
				}
			  ],
			  type: __GMLC_NodeType.FunctionCall,
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"value",
		  }
		],
		type: __GMLC_NodeType.BlockStatement,
	  },
	  type: __GMLC_NodeType.VariableDeclarationList,
	}
  ],
}
);
#endregion
#region Optimization of Struct Set with Literal to Hashed Access
run_post_processor_test("Optimize struct_set with string literal to hashed access",
@'struct_set(someStruct, "key", 10);',
{
  statements:[
	{
	  expr:{
		callee:{
		  value: struct_set_from_hash,
		  type: __GMLC_NodeType.Function,
		  name:"struct_set_from_hash",
		},
		arguments:[
		  {
			value:"someStruct",
			type: __GMLC_NodeType.Identifier,
		  },
		  {
			value: variable_get_hash("key"),
			type: __GMLC_NodeType.Literal,
			scope:"Const"
		  },
		  {
			value: 10,
			type: __GMLC_NodeType.Literal,
			scope:"Const"
		  }
		],
		type: __GMLC_NodeType.FunctionCall,
	  },
	  type: __GMLC_NodeType.ExpressionStatement,
	}
  ],
  type: __GMLC_NodeType.Script,
}
);
#endregion
#region Optimization of Simple String Concatenation
run_post_processor_test("Optimize simple string concatenation",
@'var fullName = "John" + " Doe";',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"fullName",
			expr:{
			  type: __GMLC_NodeType.Literal,
			  value:"John Doe",
			  scope:"Const"
			}
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Precomputed Hash Value for Frequent Struct Keys
run_post_processor_test("Precompute hash for frequent struct keys",
@'var userAge = struct_get(user, "age");',
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"userAge",
			expr:{
			  type: __GMLC_NodeType.FunctionCall,
			  callee:{
				value: struct_get_from_hash,
				type: __GMLC_NodeType.Function,
				name:"struct_get_from_hash",
			  },
			  arguments:[
				{type: __GMLC_NodeType.Identifier, value:"user"},
				{value: variable_get_hash("age"), type: __GMLC_NodeType.Literal, scope:"Const"}
			  ]
			}
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Precomputed Hash Value for Frequent Struct Keys
run_post_processor_test("Struct dot accessor and modification with error handling",
@'struct.zero = 1; var test = struct.two;',
{
  statements:[
	{
	  expr:{
		callee:{
		  value: struct_set_from_hash,
		  type: __GMLC_NodeType.Function,
		  name:"struct_set_from_hash",
		},
		arguments:[
		  {
			value:"struct",
			type: __GMLC_NodeType.Identifier,
		  },
		  {
			value: variable_get_hash("zero"),
			type: __GMLC_NodeType.Literal,
			scope:"Const"
		  },
		  {
			value:1.0,
			type: __GMLC_NodeType.Literal,
			scope:"Const"
		  }
		],
		type: __GMLC_NodeType.FunctionCall,
	  },
	  type: __GMLC_NodeType.ExpressionStatement,
	},
	{
	  statements:{
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  callee:{
				value: __struct_get_with_error,
				type: __GMLC_NodeType.Function,
				name:"__struct_get_with_error",
			  },
			  arguments:[
				{
				  value:"struct",
				  type: __GMLC_NodeType.Identifier,
				},
				{
				  value:"two",
				  type: __GMLC_NodeType.Literal,
				  scope:"Const"
				}
			  ],
			  type: __GMLC_NodeType.FunctionCall,
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"test",
		  }
		],
		type: __GMLC_NodeType.BlockStatement,
	  },
	  type: __GMLC_NodeType.VariableDeclarationList,
	}
  ],
  type: __GMLC_NodeType.Script,
}
);
run_post_processor_test("Struct access and modification with error handling",
@'struct[$ "zero"] = 1; var test = struct[$ "two"];',
{
  statements:[
	{
	  expr:{
		callee:{
		  value: struct_set_from_hash,
		  type: __GMLC_NodeType.Function,
		  name:"struct_set_from_hash",
		},
		arguments:[
		  {
			value:"struct",
			type: __GMLC_NodeType.Identifier,
		  },
		  {
			value: variable_get_hash("zero"),
			type: __GMLC_NodeType.Literal,
			scope:"Const"
		  },
		  {
			value:1.0,
			type: __GMLC_NodeType.Literal,
			scope:"Const"
		  }
		],
		type: __GMLC_NodeType.FunctionCall,
	  },
	  type: __GMLC_NodeType.ExpressionStatement,
	},
	{
	  statements:{
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  callee:{
				value: struct_get_from_hash,
				type: __GMLC_NodeType.Function,
				name: "struct_get_from_hash",
			  },
			  arguments:[
				{
				  value:"struct",
				  type: __GMLC_NodeType.Identifier,
				},
				{
				  value: variable_get_hash("two"),
				  type: __GMLC_NodeType.Literal,
				  scope:"Const"
				}
			  ],
			  type: __GMLC_NodeType.FunctionCall,
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"test",
		  }
		],
		type: __GMLC_NodeType.BlockStatement,
	  },
	  type: __GMLC_NodeType.VariableDeclarationList,
	}
  ],
  type: __GMLC_NodeType.Script,
}
);
#endregion

#region Arrays
#region 1. Array Creation and Direct Assignment
run_post_processor_test("Array Creation and Direct Assignment",
@'var arr = [1, 2, 3];
arr[0] = 10;
return arr[0];',
{})

#endregion
#region 2. Array Modification Through Function
run_post_processor_test("Array Modification Through Function",
@'var arr = [1, 7, 5, 6];
array_sort(arr, true);
return arr[1];',
{})

#endregion
#region 3. Array Element Increment
run_post_processor_test("Array Element Increment",
@'var arr = [10, 20, 30];
arr[2]++;
return arr[2];',
{})
#endregion
#region 4. Dynamic Array Creation with Loop
run_post_processor_test("Dynamic Array Creation with Loop",
@'var arr = [];
for (var i = 0; i < 5; i++) {
  arr[i] = i * 2;
}
return arr[3];',
{})
#endregion
#region 5. Array Access and Function Call
run_post_processor_test("Array Access and Function Call",
@'var arr = [100, 200, 300];
var result = string(arr[1]);
return result;',
{})
#endregion
#endregion


#region UNUSED
/*
#region Inlining Simple Functions
run_post_processor_test("Inline simple constant-return function",
@'function getConstant() { return 42; } var x = getConstant();,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value:42.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"x",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Constant Propagation Through Function Calls
run_post_processor_test("Propagate constants through function calls",
@'function addTwo(a) { return a + 2; } var y = addTwo(3);,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value:5.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"y",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Inlining Function Calls with Literal Arguments
run_post_processor_test("Inline function call with literal arguments",
@'function multiply(a, b) { return a * b; } var result = multiply(6, 7);,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value:42.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"result",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Optimizing Redundant Function Calls
run_post_processor_test("Optimize redundant function calls",
@'function getId(x) { return x; } var id = getId(15);,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  value:15.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"id",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Inlining Functions within Conditionals
run_post_processor_test("Inline function within if condition",
@'function isActive() { return true; } if (isActive()) { var x = 1; },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.IfStatement,
	  condition:{
		value:true,
		type: __GMLC_NodeType.Literal,
		scope:"Const"
	  },
	  consequent:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.VariableDeclarationList,
			statements:{
			  type: __GMLC_NodeType.BlockStatement,
			  statements:[
				{
				  scope:"LocalVar",
				  expr:{
					value:1.0,
					type: __GMLC_NodeType.Literal,
					scope:"Const"
				  },
				  type: __GMLC_NodeType.VariableDeclaration,
				  identifier:"x",
				}
			  ],
			},
		  }
		]
	  },
	  alternate:undefined
	}
  ],
}
);
#endregion
#region Inlining Functions in Loop Conditions
run_post_processor_test("Inline function in while loop condition",
@'function hasItems() { return false; } while (hasItems()) { var y = 2; },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.WhileStatement,
	  condition:{
		value:false,
		type: __GMLC_NodeType.Literal,
		scope:"Const"
	  },
	  codeBlock:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[]
	  }
	}
  ],
}
);
#endregion
#region Inlining Functions in Return Statements
run_post_processor_test("Inline function in return statement",
@'function calculateValue() { return 42; } function wrapper() { return calculateValue(); },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.FunctionDeclaration,
	  functionName:"wrapper",
	  body:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.ReturnStatement,
			expr:{
			  value:42.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			}
		  }
		]
	  }
	}
  ],
}
);
#endregion
#region Inlining Functions with Multiple Calls in a Single Expression
run_post_processor_test("Inline multiple calls in a single expression",
@'function getFive() { return 5; } var result = getFive() + getFive();,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  type: __GMLC_NodeType.BinaryExpression,
			  operator:"+",
			  left:{
				value:5.0,
				type: __GMLC_NodeType.Literal,
				scope:"Const"
			  },
			  right:{
				value:5.0,
				type: __GMLC_NodeType.Literal,
				scope:"Const"
			  }
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"result",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Inlining Functions with Arguments Used Multiple Times
run_post_processor_test("Inline function with arguments used multiple times",
@'function double(x) { return x * 2; } var total = double(3) + double(3);,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			scope:"LocalVar",
			expr:{
			  type: __GMLC_NodeType.BinaryExpression,
			  operator:"+",
			  left:{
				value:6.0,
				type: __GMLC_NodeType.Literal,
				scope:"Const"
			  },
			  right:{
				value:6.0,
				type: __GMLC_NodeType.Literal,
				scope:"Const"
			  }
			},
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"total",
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Loop Unrolling with a Constant Loop Count
run_post_processor_test("Unroll loop with constant count",
@'for (var i = 0; i < 4; i++) { var x = x + 1; },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.ExpressionStatement,
	  expr:{
		type: __GMLC_NodeType.AssignmentExpression,
		operator:"=",
		left:{type: __GMLC_NodeType.Identifier, value:"x"},
		right:{
		  type: __GMLC_NodeType.BinaryExpression,
		  operator:"+",
		  left:{type: __GMLC_NodeType.Identifier, value:"x"},
		  right:{value:4.0, type: __GMLC_NodeType.Literal, scope:"Const"}
		}
	  }
	}
  ],
}
);
#endregion
#region Constant Propagation in Loop Initialization
run_post_processor_test("Propagate constant in loop initialization",
@'var limit = 10; for (var i = 0; i < limit; i++) { var y = i; },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.ForStatement,
	  initialization:{type: __GMLC_NodeType.VariableDeclaration, identifier:"i", expr:{value:0.0, type: __GMLC_NodeType.Literal, scope:"Const"}},
	  condition:{
		type: __GMLC_NodeType.BinaryExpression,
		operator:"<",
		left:{type: __GMLC_NodeType.Identifier, value:"i"},
		right:{value:10.0, type: __GMLC_NodeType.Literal, scope:"Const"}
	  },
	  increment:{
		type: __GMLC_NodeType.PostfixExpression,
		operator:"++",
		expr:{type: __GMLC_NodeType.Identifier, value:"i"}
	  },
	  codeBlock:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[]
	  }
	}
  ],
}
);
#endregion
#region Loop Invariant Code Motion
run_post_processor_test("Loop invariant code motion",
@'var a = 5; for (var i = 0; i < 10; i++) { var z = a * 2; },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"z",
			expr:{
			  value:10.0,
			  type: __GMLC_NodeType.Literal,
			  scope:"Const"
			}
		  }
		],
	  },
	}
  ],
}
);
#endregion
#region Loop with Break Condition Simplified
run_post_processor_test("Simplify loop with constant break condition",
@'while (true) { break; },
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.BlockStatement,
	  statements:[]
	}
  ],
}
);
#endregion
#region Removing Redundant Computations in Loops							 //////////////////////////////////////NOT ACTIVE!
run_post_processor_test("Remove redundant computations in loop",
@'for (var i = 0; i < 10; i++) {
	var temp = "constant";
	var result = temp;
},
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.ForStatement,
	  initialization:{type: __GMLC_NodeType.VariableDeclaration, identifier:"i", expr:{value:0.0, type: __GMLC_NodeType.Literal, scope:"Const"}},
	  condition:{
		type: __GMLC_NodeType.BinaryExpression,
		operator:"<",
		left:{type: __GMLC_NodeType.Identifier, value:"i"},
		right:{value:10.0, type: __GMLC_NodeType.Literal, scope:"Const"}
	  },
	  increment:{
		type: __GMLC_NodeType.PostfixExpression,
		operator:"++",
		expr:{type: __GMLC_NodeType.Identifier, value:"i"}
	  },
	  codeBlock:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.VariableDeclarationList,
			statements:{
			  type: __GMLC_NodeType.BlockStatement,
			  statements:[
				{
				  type: __GMLC_NodeType.VariableDeclaration,
				  identifier:"result",
				  expr:{value:"constant", type: __GMLC_NodeType.Literal, scope:"Const"}
				}
			  ],
			},
		  }
		]
	  }
	}
  ],
}
);
#endregion
#region Inlining Small Functions Directly into Call Sites
run_post_processor_test("Inline small function directly into call site",
@'function addOne(x) { return x + 1; } var result = addOne(5);,
{
  type: __GMLC_NodeType.Script,
  statements:[
	{
	  type: __GMLC_NodeType.VariableDeclarationList,
	  statements:{
		type: __GMLC_NodeType.BlockStatement,
		statements:[
		  {
			type: __GMLC_NodeType.VariableDeclaration,
			identifier:"result",
			expr:{
			  type: __GMLC_NodeType.BinaryExpression,
			  operator:"+",
			  left:{value:5.0, type: __GMLC_NodeType.Literal, scope:"Const"},
			  right:{value:1.0, type: __GMLC_NodeType.Literal, scope:"Const"}
			}
		  }
		],
	  },
	}
  ],
}
);
#endregion
//*/
#endregion
}
//run_all_post_processor_tests();
#endregion
